<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
<!--
Uncomment line below to generate index.
-->
<!--
<!ENTITY indice SYSTEM "indice.sgml">
-->
<!-- by rojy
&nbsp; 所产生的一个小问题, 会造成一点乱码. 这也是openjade的bug. 
&lt;computeroutput&gt; 的问题, 在多列时, 第一列总会比后边的列少个空格. 
&eacute; 会产生乱码, 这是由于openjade的bug所造成的, 在经过openjade编译后, 
这个字符应该被翻译成相应的&#233;才对, 不应该直接想当然的认为应该翻译成
iso-8859-1相应的扩展ascii码. 这样的话所有的扩展ascii码都会产生问题. 
已经有人提交给openjade的buglist了. 
看来openjade对于这种bug也不会再修改了, 郁闷:(
已经把那个人的字符改为e了, Stephane. 
原书作者也闲麻烦, 他自己也这么写. 
-->
<!ENTITY ex1 SYSTEM "ex1.sh">
<!ENTITY ex1a SYSTEM "ex1a.sh">
<!ENTITY ex2 SYSTEM "ex2.sh">
<!ENTITY ex3 SYSTEM "ex3.sh">
<!ENTITY ex4 SYSTEM "ex4.sh">
<!ENTITY ex5 SYSTEM "ex5.sh">
<!ENTITY ex6 SYSTEM "ex6.sh">
<!ENTITY ex7 SYSTEM "ex7.sh">
<!ENTITY ex8 SYSTEM "ex8.sh">
<!ENTITY ex9 SYSTEM "ex9.sh">
<!ENTITY ex10 SYSTEM "ex10.sh">
<!ENTITY ex11 SYSTEM "ex11.sh">
<!ENTITY ex12 SYSTEM "ex12.sh">
<!ENTITY ex13 SYSTEM "ex13.sh">
<!ENTITY ex14 SYSTEM "ex14.sh">
<!ENTITY ex15 SYSTEM "ex15.sh">
<!ENTITY ex16 SYSTEM "ex16.sh">
<!ENTITY ex17 SYSTEM "ex17.sh">
<!ENTITY ex18 SYSTEM "ex18.sh">
<!ENTITY ex19 SYSTEM "ex19.sh">
<!ENTITY ex20 SYSTEM "ex20.sh">
<!ENTITY ex21 SYSTEM "ex21.sh">
<!ENTITY ex22 SYSTEM "ex22.sh">
<!ENTITY ex22a SYSTEM "ex22a.sh">
<!ENTITY ex23 SYSTEM "ex23.sh">
<!ENTITY ex24 SYSTEM "ex24.sh">
<!ENTITY ex25 SYSTEM "ex25.sh">
<!ENTITY ex26 SYSTEM "ex26.sh">
<!ENTITY ex26a SYSTEM "ex26a.sh">
<!ENTITY ex27 SYSTEM "ex27.sh">
<!ENTITY ex28 SYSTEM "ex28.sh">
<!ENTITY ex29 SYSTEM "ex29.sh">
<!ENTITY ex30 SYSTEM "ex30.sh">
<!ENTITY ex30a SYSTEM "ex30a.sh">
<!ENTITY ex31 SYSTEM "ex31.sh">
<!ENTITY ex32 SYSTEM "ex32.sh">
<!ENTITY ex33 SYSTEM "ex33.sh">
<!ENTITY ex33a SYSTEM "ex33a.sh">
<!ENTITY ex34 SYSTEM "ex34.sh">
<!ENTITY ex35 SYSTEM "ex35.sh">
<!ENTITY ex36 SYSTEM "ex36.sh">
<!ENTITY ex37 SYSTEM "ex37.sh">
<!ENTITY ex38 SYSTEM "ex38.sh">
<!ENTITY ex38bis SYSTEM "data-file">
<!ENTITY ex39 SYSTEM "ex39.sh">
<!ENTITY ex40 SYSTEM "ex40.sh">
<!ENTITY ex41 SYSTEM "ex41.sh">
<!ENTITY ex42 SYSTEM "ex42.sh">
<!ENTITY ex43 SYSTEM "ex43.sh">
<!ENTITY ex44 SYSTEM "ex44.sh">
<!ENTITY ex45 SYSTEM "ex45.sh">
<!ENTITY ex45a SYSTEM "ex45a.sh">
<!ENTITY ex46 SYSTEM "ex46.sh">
<!ENTITY ex47 SYSTEM "ex47.sh">
<!ENTITY ex48 SYSTEM "ex48.sh">
<!ENTITY ex49 SYSTEM "ex49.sh">
<!ENTITY ex50 SYSTEM "ex50.sh">
<!ENTITY ex51 SYSTEM "ex51.sh">
<!ENTITY ex52 SYSTEM "ex52.sh">
<!ENTITY ex53 SYSTEM "ex53.sh">
<!ENTITY ex54 SYSTEM "ex54.sh">
<!ENTITY ex55 SYSTEM "ex55.sh">
<!ENTITY ex56 SYSTEM "ex56.sh">
<!ENTITY ex57 SYSTEM "ex57.sh">
<!ENTITY ex58 SYSTEM "ex58.sh">
<!ENTITY ex59 SYSTEM "ex59.sh">
<!ENTITY ex60 SYSTEM "ex60.sh">
<!ENTITY ex61 SYSTEM "ex61.sh">
<!ENTITY ex62 SYSTEM "ex62.sh">
<!ENTITY ex63 SYSTEM "ex63.sh">
<!ENTITY ex64 SYSTEM "ex64.sh">
<!ENTITY ex65 SYSTEM "ex65.sh">
<!ENTITY ex66 SYSTEM "ex66.sh">
<!ENTITY ex67 SYSTEM "ex67.sh">
<!ENTITY ex68 SYSTEM "ex68.sh">
<!ENTITY ex69 SYSTEM "ex69.sh">
<!ENTITY ex70 SYSTEM "ex70.sh">
<!ENTITY ex71 SYSTEM "ex71.sh">
<!ENTITY ex71a SYSTEM "ex71a.sh">
<!ENTITY ex71b SYSTEM "ex71b.sh">
<!ENTITY ex71c SYSTEM "ex71c.sh">
<!ENTITY ex72 SYSTEM "ex72.sh">
<!ENTITY ex73 SYSTEM "ex73.sh">
<!ENTITY ex74 SYSTEM "ex74.sh">
<!ENTITY ex75 SYSTEM "ex75.sh">
<!ENTITY ex76 SYSTEM "ex76.sh">
<!ENTITY ex77 SYSTEM "ex77.sh">
<!ENTITY ex78 SYSTEM "ex78.sh">
<!ENTITY ex79 SYSTEM "ex79.sh">
<!ENTITY andor SYSTEM "and-or.sh">
<!ENTITY lnum SYSTEM "line-number.sh">
<!ENTITY manview SYSTEM "manview.sh">
<!ENTITY rfe SYSTEM "rfe.sh">
<!ENTITY behead SYSTEM "behead.sh">
<!ENTITY ftpget SYSTEM "ftpget.sh">
<!ENTITY encryptedpw SYSTEM "encryptedpw.sh">
<!ENTITY rpmcheck SYSTEM "rpm-check.sh">
<!ENTITY subshell SYSTEM "subshell.sh">
<!ENTITY lowercase SYSTEM "lowercase.sh">
<!ENTITY online SYSTEM "online.sh">
<!ENTITY reply SYSTEM "reply.sh">
<!ENTITY seconds SYSTEM "seconds.sh">
<!ENTITY numbers SYSTEM "numbers.sh">
<!ENTITY indref SYSTEM "ind-ref.sh">
<!ENTITY bubble SYSTEM "bubble.sh">
<!ENTITY paramsub SYSTEM "param-sub.sh">
<!ENTITY restricted SYSTEM "restricted.sh">
<!ENTITY pw SYSTEM "pw.sh">
<!ENTITY rn SYSTEM "rn.sh">
<!ENTITY coltotaler SYSTEM "col-totaler.sh">
<!ENTITY coltotaler2 SYSTEM "col-totaler2.sh">
<!ENTITY coltotaler3 SYSTEM "col-totaler3.sh">
<!ENTITY tmdin SYSTEM "timed-input.sh">
<!ENTITY fifo SYSTEM "fifo.sh">
<!ENTITY tree SYSTEM "tree.sh">
<!ENTITY secretpw SYSTEM "secret-pw.sh">
<!ENTITY stripc SYSTEM "strip-comments.sh">
<!ENTITY al SYSTEM "alias.sh">
<!ENTITY unal SYSTEM "unalias.sh">
<!ENTITY redir1 SYSTEM "redir1.sh">
<!ENTITY redir2 SYSTEM "redir2.sh">
<!ENTITY redir2a SYSTEM "redir2a.sh">
<!ENTITY redir3 SYSTEM "redir3.sh">
<!ENTITY redir4 SYSTEM "redir4.sh">
<!ENTITY redir4a SYSTEM "redir4a.sh">
<!ENTITY redir5 SYSTEM "redir5.sh">
<!ENTITY wipedir SYSTEM "wipedir.sh">
<!ENTITY grp SYSTEM "grp.sh">
<!ENTITY killprocess SYSTEM "kill-process.sh">
<!ENTITY killbyname SYSTEM "kill-byname.sh">
<!ENTITY strtest SYSTEM "str-test.sh">
<!ENTITY colm SYSTEM "colm.sh">
<!ENTITY lookup SYSTEM "lookup.sh">
<!ENTITY arglist SYSTEM "arglist.sh">
<!ENTITY rot13 SYSTEM "rot13.sh">
<!ENTITY rot13a SYSTEM "rot13a.sh">
<!ENTITY rot14 SYSTEM "rot14.sh">
<!ENTITY filecomp SYSTEM "file-comparison.sh">
<!ENTITY adddrv SYSTEM "add-drive.sh">
<!ENTITY whloopc SYSTEM "wh-loopc.sh">
<!ENTITY forloopc SYSTEM "for-loopc.sh">
<!ENTITY forloopcmd SYSTEM "for-loopcmd.sh">
<!ENTITY cvars SYSTEM "c-vars.sh">
<!ENTITY bingrep SYSTEM "bin-grep.sh">
<!ENTITY mailformat SYSTEM "mail-format.sh">
<!ENTITY symlinks SYSTEM "symlinks.sh">
<!ENTITY symlinks2 SYSTEM "symlinks2.sh">
<!ENTITY string SYSTEM "string.sh">
<!ENTITY nestedloop SYSTEM "nested-loop.sh">
<!ENTITY casecmd SYSTEM "case-cmd.sh">
<!ENTITY uns SYSTEM "unset.sh">
<!ENTITY base SYSTEM "base.sh">
<!ENTITY allprofs SYSTEM "allprofs.sh">
<!ENTITY pidid SYSTEM "pid-identifier.sh">
<!ENTITY constat SYSTEM "connect-stat.sh">
<!ENTITY subpit SYSTEM "subshell-pitfalls.sh">
<!ENTITY readredir SYSTEM "read-redir.sh">
<!ENTITY andlist2 SYSTEM "and-list2.sh">
<!ENTITY qfunction SYSTEM "q-function.sh">
<!ENTITY viewdata SYSTEM "viewdata.sh">
<!ENTITY VIEWDAT SYSTEM "VIEWDATA.BAT">
<!ENTITY what SYSTEM "what.sh">
<!ENTITY max SYSTEM "max.sh">
<!ENTITY max2 SYSTEM "max2.sh">
<!ENTITY findstring SYSTEM "findstring.sh">
<!ENTITY listglob SYSTEM "list-glob.sh">
<!ENTITY realname SYSTEM "realname.sh">
<!ENTITY escaped SYSTEM "escaped.sh">
<!ENTITY fileinfo SYSTEM "file-info.sh">
<!ENTITY weirdvars SYSTEM "weirdvars.sh">
<!ENTITY breaklevels SYSTEM "break-levels.sh">
<!ENTITY copycd SYSTEM "copy-cd.sh">
<!ENTITY arithops SYSTEM "arith-ops.sh">
<!ENTITY continuelevels SYSTEM "continue-nlevel.sh">
<!ENTITY timeout SYSTEM "timeout.sh">
<!ENTITY randomtest SYSTEM "random-test.sh">
<!ENTITY seedingrandom SYSTEM "seeding-random.sh">
<!ENTITY pattmatching SYSTEM "patt-matching.sh">
<!ENTITY isalpha SYSTEM "isalpha.sh">
<!ENTITY rnd SYSTEM "rnd.sh">
<!ENTITY du SYSTEM "Du.sh">
<!ENTITY refparams SYSTEM "ref-params.sh">
<!ENTITY indfunc SYSTEM "ind-func.sh">
<!ENTITY primes SYSTEM "primes.sh">
<!ENTITY vartrace SYSTEM "vartrace.sh">
<!ENTITY amiroot SYSTEM "am-i-root.sh">
<!ENTITY twodim SYSTEM "twodim.sh">
<!ENTITY arithtests SYSTEM "arith-tests.sh">
<!ENTITY incompat SYSTEM "incompat.sh">
<!ENTITY ifsh SYSTEM "ifs.sh">
<!ENTITY ifsempty SYSTEM "ifs-empty.sh">
<!ENTITY logevents SYSTEM "logevents.sh">
<!ENTITY keypress SYSTEM "keypress.sh">
<!ENTITY ddkeypress SYSTEM "dd-keypress.sh">
<!ENTITY objoriented SYSTEM "obj-oriented.sh">
<!ENTITY emptyarray SYSTEM "empty-array.sh">
<!ENTITY length SYSTEM "length.sh">
<!ENTITY monthlypmt SYSTEM "monthlypmt.sh">
<!ENTITY derpm SYSTEM "de-rpm.sh">
<!ENTITY blotout SYSTEM "blot-out.sh">
<!ENTITY readr SYSTEM "read-r.sh">
<!ENTITY cryptoquote SYSTEM "crypto-quote.sh">
<!ENTITY erase SYSTEM "erase.sh">
<!ENTITY returntest SYSTEM "return-test.sh">
<!ENTITY daysbetween SYSTEM "days-between.sh">
<!ENTITY varmatch SYSTEM "var-match.sh">
<!ENTITY recurse SYSTEM "recurse.sh">
<!ENTITY assert SYSTEM "assert.sh">
<!ENTITY intorstring SYSTEM "int-or-string.sh">
<!ENTITY ramdisk SYSTEM "ramdisk.sh">
<!ENTITY m4 SYSTEM "m4.sh">
<!ENTITY idelete SYSTEM "idelete.sh">
<!ENTITY matchstring SYSTEM "match-string.sh">
<!ENTITY bashandperl SYSTEM "bashandperl.sh">
<!ENTITY cvt SYSTEM "cvt.sh">
<!ENTITY wf SYSTEM "wf.sh">
<!ENTITY wf2 SYSTEM "wf2.sh">
<!ENTITY hypot SYSTEM "hypotenuse.sh">
<!ENTITY random2 SYSTEM "random2.sh">
<!ENTITY altbc SYSTEM "alt-bc.sh">
<!ENTITY substringex SYSTEM "substring-extraction.sh">
<!ENTITY stupscr SYSTEM "stupid-script-tricks.sh">
<!ENTITY resistor SYSTEM "resistor-inventory.sh">
<!ENTITY stackex SYSTEM "stack.sh">
<!ENTITY gcd SYSTEM "gcd.sh">
<!ENTITY selfmailer SYSTEM "self-mailer.sh">
<!ENTITY collatz SYSTEM "collatz.sh">
<!ENTITY wstrings SYSTEM "wstrings.sh">
<!ENTITY multiplication SYSTEM "multiplication.sh">
<!ENTITY sumproduct SYSTEM "sum-product.sh">
<!ENTITY userlist SYSTEM "userlist.sh">
<!ENTITY bgloop SYSTEM "background-loop.sh">
<!ENTITY tout SYSTEM "t-out.sh">
<!ENTITY csubloop SYSTEM "csubloop.sh">
<!ENTITY arrfunc SYSTEM "array-function.sh">
<!ENTITY lifeslow SYSTEM "life.sh">
<!ENTITY commentblock SYSTEM "commentblock.sh">
<!ENTITY selfdocument SYSTEM "self-document.sh">
<!ENTITY hf SYSTEM "here-function.sh">
<!ENTITY fileintegrity SYSTEM "file-integrity.sh">
<!ENTITY readnovar SYSTEM "read-novar.sh">
<!ENTITY setpos SYSTEM "set-pos.sh">
<!ENTITY revposparams SYSTEM "revposparams.sh">
<!ENTITY badread SYSTEM "badread.sh">
<!ENTITY selfexec SYSTEM "self-exec.sh">
<!ENTITY selfdestruct SYSTEM "self-destruct.sh">
<!ENTITY reassignstdout SYSTEM "reassign-stdout.sh">
<!ENTITY upperconv SYSTEM "upperconv.sh">
<!ENTITY pbook SYSTEM "pb.sh">
<!ENTITY makedict SYSTEM "makedict.sh">
<!ENTITY missingkeyword SYSTEM "missing-keyword.sh">
<!ENTITY blankrename SYSTEM "blank-rename.sh">
<!ENTITY scriptdetector SYSTEM "script-detector.sh">
<!ENTITY hexconvert SYSTEM "hexconvert.sh">
<!ENTITY factr SYSTEM "factr.sh">
<!ENTITY cannon SYSTEM "cannon.sh">
<!ENTITY agram SYSTEM "agram.sh">
<!ENTITY agram2 SYSTEM "agram2.sh">
<!ENTITY poem SYSTEM "poem.sh">
<!ENTITY soundex SYSTEM "soundex.sh">
<!ENTITY tempfilename SYSTEM "tempfile-name.sh">
<!ENTITY unitconversion SYSTEM "unit-conversion.sh">
<!ENTITY usagemessage SYSTEM "usage-message.sh">
<!ENTITY colorecho SYSTEM "color-echo.sh">
<!ENTITY selfsource SYSTEM "self-source.sh">
<!ENTITY selfcopy SYSTEM "self-copy.sh">
<!ENTITY arrowdetect SYSTEM "arrow-detect.sh">
<!ENTITY paragraphspace SYSTEM "paragraph-space.sh">
<!ENTITY brokenlink SYSTEM "broken-link.sh">
<!ENTITY continuenex SYSTEM "continue-n.example">
<!ENTITY pickcard SYSTEM "pick-card.sh">
<!ENTITY copyarray SYSTEM "CopyArray.sh">
<!ENTITY directoryinfo SYSTEM "directory-info.sh">
<!ENTITY embarr SYSTEM "embedded-arrays.sh">
<!ENTITY generatescript SYSTEM "generate-script.sh">
<!ENTITY scriptarray SYSTEM "script-array.sh">
<!ENTITY randombetween SYSTEM "random-between.sh">
<!ENTITY arrayops SYSTEM "array-ops.sh">
<!ENTITY arraystrops SYSTEM "array-strops.sh">
<!ENTITY arrayappend SYSTEM "array-append.bash">
<!ENTITY arrayassign SYSTEM "array-assign.bash">
<!ENTITY lettercount SYSTEM "letter-count.sh">
<!ENTITY lettercount2 SYSTEM "letter-count2.sh">
<!ENTITY protectliteral SYSTEM "protect_literal.sh">
<!ENTITY unprotectliteral SYSTEM "unprotect_literal.sh">
<!ENTITY usbinst SYSTEM "usb.sh">
<!ENTITY basicsreviewed SYSTEM "basics-reviewed.bash">
<!ENTITY readpipe SYSTEM "readpipe.sh">
<!ENTITY usrmnt SYSTEM "usrmnt.sh">
<!ENTITY dialog SYSTEM "dialog.sh">
<!ENTITY hellol SYSTEM "hello.sh">
<!ENTITY hanoi SYSTEM "hanoi.bash">
<!ENTITY horserace SYSTEM "horserace.sh">
<!ENTITY remote SYSTEM "remote.bash">
<!ENTITY prependex SYSTEM "prepend.sh">
<!ENTITY setnewpw SYSTEM "setnew-passwd.sh">
<!ENTITY badop SYSTEM "bad-op.sh">
<!ENTITY dereferencecl SYSTEM "dereference.sh">
<!ENTITY archiveweblogs SYSTEM "archiveweblogs.sh">
<!ENTITY devtcp SYSTEM "dev-tcp.sh">
<!ENTITY multipleproc SYSTEM "multiple-processes.sh">
<!ENTITY funccmdlinearg SYSTEM "func-cmdlinearg.sh">
<!ENTITY isspammer SYSTEM "is-spammer.sh">
<!ENTITY isspammer2 SYSTEM "is_spammer.bash">
<!ENTITY wgetter2 SYSTEM "wgetter2.bash">
<!ENTITY exercisingdd SYSTEM "exercising-dd.sh">
<!ENTITY quotefetch SYSTEM "quote-fetch.sh">
<!ENTITY avoidsubshell SYSTEM "avoid-subshell.sh">
<!ENTITY loggingwrapper SYSTEM "logging-wrapper.sh">
<!ENTITY dictlookup SYSTEM "dict-lookup.sh">
<!ENTITY bashpodder SYSTEM "bashpodder.sh">
<!ENTITY drawbox SYSTEM "Draw-box.sh">
<!ENTITY evalex SYSTEM "eval.example">
<!ENTITY testcgi SYSTEM "test-cgi.sh">
<!ENTITY spawnscr SYSTEM "spawn.sh">
<!ENTITY iscan SYSTEM "iscan.sh">
<!ENTITY ra2ogg SYSTEM "ra2ogg.sh">
<!ENTITY namesdata SYSTEM "names.data">
<!ENTITY hashlib SYSTEM "Hash.lib">
<!ENTITY hashexample SYSTEM "hash-example.sh">
<!ENTITY hashex2 SYSTEM "ha.sh">
<!ENTITY getoptsimple SYSTEM "getopt-simple.sh">
<!ENTITY prasc SYSTEM "pr-asc.sh">
<!ENTITY whx SYSTEM "whx.sh">
<!ENTITY spamlookup SYSTEM "spam-lookup.sh">
<!ENTITY mailboxgrep SYSTEM "mailbox_grep.sh">
<!ENTITY fc4upd SYSTEM "fc4upd.sh">
<!ENTITY gen0data SYSTEM "gen0">
<!ENTITY cdll SYSTEM "cdll">
<!ENTITY bashrc SYSTEM "bashrc">
]>

<book>
  <bookinfo>
    <title>高级Bash脚本编程指南</title>
    <subtitle>一本深入学习shell脚本艺术的书籍</subtitle>

    <author>
      <firstname>Mendel</firstname>
      <surname>Cooper</surname>
      <affiliation>
      <orgname></orgname>
      <address><email>thegrendel@theriver.com</email></address>
      </affiliation>
    </author>

<othercredit role='translator'>
  <firstname>春敏</firstname> 
  <surname>杨</surname> 
  <contrib></contrib>
  <affiliation>
  <orgname></orgname>
  <address><email>chunmin.yang@gmail.com</email></address>
  </affiliation>
</othercredit>

<othercredit role='translator'>
  <firstname>毅</firstname> 
  <surname>黄</surname> 
  <contrib></contrib>
  <affiliation>
  <orgname></orgname>
  <address><email>linuxprogram@gmail.com</email></address>
  </affiliation>
</othercredit>

    <releaseinfo>3.9.1</releaseinfo>
    <pubdate>2006年5月26日</pubdate>


    <revhistory>

      <revision>
        <revnumber>3.7</revnumber>
        <date>2005年10月23日</date>
        <authorinitials>mc</authorinitials>
    <revremark>'WHORTLEBERRY' release: Bugfix Update.</revremark>
      </revision>

      <revision>
        <revnumber>3.8</revnumber>
        <date>2006年2月26日</date>
        <authorinitials>mc</authorinitials>
    <revremark>'BLAEBERRY' release: Minor Update.</revremark>
      </revision>

      <revision>
        <revnumber>3.9</revnumber>
        <date>2006年5月15日</date>
        <authorinitials>mc</authorinitials>
    <revremark>'SPICEBERRY' release: Minor Update.</revremark>
      </revision>

    </revhistory>


    <abstract>

        <para>这本书假定你没有任何关于脚本或一般程序的编程知识, 但是如果你具备相关的知识, 
        那么你将很容易就能够达到中高级的水平<emphasis>. . . 所有这些只是<trademark
        class=registered>UNIX</trademark>浩瀚知识的一小部分</emphasis>. 你可以把本书作为教材, 
        自学手册, 或者是关于shell脚本技术的文档. 书中的练习和样例脚本中的注释将会与读者进行更好的互动,
        但是最关键的前提是: 
		<userinput>想真正学习脚本编程的唯一途径就是亲自动手编写脚本.
        </userinput></para>

      <para>这本书也可作为教材来讲解一般的编程概念.</para>

      <para><ulink
        url="http://personal.riverusers.com/~thegrendel/abs-guide-3.9.tar.bz2">
		本文档的最新版本</ulink>是作为一个归档文件<link linkend="bzipref">bzip2-ed</link>,
	<quote>tar包</quote>来发布的, 
	其中还包括SGML源代码和编译好的HTML版本. 
	读者可以从作者的主页上下载. 
	<ulink url="http://www.tldp.org/LDP/abs/abs-guide.pdf">pdf版本</ulink>也可以从作者的主页上下载. 
	查看<ulink url="http://personal.riverusers.com/~thegrendel/Change.log">change log</ulink>来查看校订历史. </para>

    </abstract>
  </bookinfo>

  <dedication>
    <para>献给Anita, 我所有动力的源泉!</para>
  </dedication>

  <preface id="preface">
	  <title>序</title>

	  	  <sect1 id="preface_author_en">
			  <title>原书作者致中国读者(英文)</title>
		  <para>Greetings to Linux users in the great nation of China!</para>
		  <para>I hope that the Advanced Bash Scripting Guide will 
			  help you learn the intricacies of Linux and appreciate 
			  its utility. Time spent writing scripts
			  will reward you in increased understanding of the 
			  operating system and appreciation of the power at 
			  your fingertips. </para>
		  <para>In past eras China was a shining light when much of 
			  the rest of the world lay in darkness. Perhaps a new 
			  generation of Chinese computer science scholars can 
			  help liberate us from the darkness of the 
			  Microsoft monopoly. </para>
		  <para>The translators of this book deserve a great deal 
			  of credit and praise for all the time and effort 
			  they have invested in this project. I wish to give
			  special thanks to them. </para>
		  <para><emphasis>Mendel Cooper</emphasis></para>
		  <para>Author, Advanced Bash Scripting Guide</para>
		  </sect1>

	  	  <sect1 id="preface_author_cn">
			  <title>原书作者致中国读者(译文)</title>
		  <para>向伟大的中华民族的Linux用户致意! </para>
		  <para>我希望这本书能够帮助你们学习和理解Linux的复杂之处, 并充分认识和使用这些工具. 花在编写脚本上的时间不会白费, 这会增强你对操作系统的了解, 还能够稳步提高你的水平. </para>
		  <para>在过去时代中, 当世界上大多数的地方都处于黑暗的时候, 中国发出了耀眼的光芒. 或许新一代的中国计算机科学学者们可以帮助我们摆脱黑暗, <emphasis>摆脱微软的垄断</emphasis>. </para>
		  <para>这本书的译者们在这个项目上投入了很多的时间和精力, 他们的行为应该得到很大的赞赏和肯定. 我特此感谢他们. </para>
		  <para><emphasis>Mendel Cooper</emphasis></para>
		  <para>本书作者</para>
		  <para></para>
		  </sect1>

	  	  <sect1 id="preface_huang_yi">
		  <title>黄毅</title>
	  <para>毫无疑问, UNIX/Linux最重要的软件之一就是shell, 
		  目前最流行的shell被称为Bash(Bourne Again Shell), 
		  几乎所有的Linux和绝大部分的UNIX都可以使用Bash. 
		  作为系统与用户之间的交互接口, 
		  shell几乎是你在UNIX工作平台上最亲密的朋友, 
		  因此, 学好shell, 是学习Linux/UNIX的的开始, 
		  并且它会始终伴随你的工作和学习. </para>
	  <para>shell是如此地重要, 但令人惊奇的是, 
		  介绍shell的书没有真正令人满意的. 所幸的是, 
		  我看到了这本被人称为abs的书, 
		  这本书介绍了bash大量的细节和广阔的范围, 
		  我遇到的绝大部分的技术问题--无论是我忘记的或是以前没有发现的--都可以在这本书里找到答案. 
		  这本使用大量的例子详细地介绍了Bash的语法, 各种技巧, 
		  调试等等的技术, 以循序渐进的学习方式, 让你了解Bash的所有特性, 
		  在书中还有许多练习可以引导你思考, 以得到更深入的知识. 
		  无论你是新手还是老手, 或是使用其他语言的程序员, 
		  我能肯定你能在此书用受益. 而本书除了介绍BASH的知识之外, 
		  也有许多有用的关于 Linux/UNIX的知识和其他shell的介绍. </para>
	  <para>在看到本书的英文版后, 我决定把它翻译出来, 
		  在Linuxsir论坛上结识了译者之一杨春敏, 我们一起把这本书翻译了出来. 
		  </para>
	  <para>关于版权的问题, 英文版的作者Mendel 
		  Cooper对英文版的版权做了详细的约定, 
		  请参考: Q. 版权. 中文版版权由译者杨春敏和黄毅共同所有, 
		  在遵守英文版版权相应条款的条件下, 
		  欢迎在保留本书译者名字和版权说明以非盈利的方式自由发布此中文版, 
		  以盈利目的的所有行为必须联系英文作者和两位中文译者以获得许可. </para>
	  <para>本书得以成稿, 我(黄毅)要多谢我的女朋友, 
		  本该给予她的时间我用来了翻译, 多谢你的理解, 
		  你是一个很棒的女朋友! </para>
	  </sect1>
	  <sect1 id="preface_chunmin_yang">
		  <title>杨春敏</title>
		  <para>这本书如此的有名, 根本用不着我在这里多说什么. </para>
		  <para>我只希望编写Bash脚本的朋友们, 在遇到问题之前, 先在此书中查阅一番. </para>
		  <para>我相信, 如果每个人都能做到这点的话, 那么与Bash脚本相关的论坛, 就会是另外一番景象! </para>
		  <para>在这里非常感谢我的老婆----<emphasis>常宇</emphasis>. </para> 
		  <para>我俩长期在两地生活, 由于翻译本书, 甚至抢占了我俩打电话的时间. </para>
		  <para>如果没有老婆的支持, 我想也不会有这份译本. </para>
	  </sect1>
  </preface>

  <part label="第一部分" id="part1">
    <title>热身</title>

  <partintro>  

      <para>shell是一个命令解释器. 是介于操作系统内核与用户之间的一个绝缘层. 
      准确地说,它也是能力很强的计算机语言, 一种shell程序,
	  同时也被称为一种<firstterm>脚本语言</firstterm>. 它是非常容易使用的工具, 
	  它可以通过将系统调用, 公共程序, 工具, 和编译过的二进制程序<quote>粘合</quote>在一起来建立应用.
	  事实上, 所有的UNIX命令和工具再加上公共程序, 对于shell脚本来说,都是可调用的.
	  如果这些你还觉得不够,那么shell内建命令, 比如条件测试与循环结构,
	  也会给脚本添加强力的支持和增加灵活性. Shell脚本对于管理系统任务和其它的重复工作的例程来说, 表现的非常好, 
	  根本不需要那些华而不实的成熟紧凑的程序语言. </para>

  </partintro>  

  <chapter id="why-shell">
    <title>为什么使用shell编程?</title>

    <epigraph>
      <attribution>Herbert Mayer</attribution>
	  <para>没有程序语言是完美的. 甚至没有一个唯一最好的语言, 只有对于特定目的,
		  比较适合和不适合的程序语言. </para>
    </epigraph>
    
    
	<para>对于任何想适当精通一些系统管理知识的人来说, 掌握shell脚本知识都是最基本的,
		即使这些人可能并不打算真正的编写一些脚本. 想一下Linux机器的启动过程, 在这个过程中, 
		必将运行<filename class="directory">/etc/rc.d</filename>目录下的脚本来存储系统配置和建立服务.
    详细的理解这些启动脚本对于分析系统的行为是非常重要的, 并且有时候可能必须修改它.
    </para>

	<para>学习如何编写shell脚本并不是一件很困难的事, 因为脚本可以分为很小的块,
		并且相对于shell特性的操作和选项
		<footnote><para>这些将在<link linkend="builtinref">内建</link>章节被引用, 
				这些都是shell的内部特征.
		</para></footnote>部分,只需要学习很小的一部分就可以了. 语法是简单并且直观的, 
		编写脚本很像是在命令行上把一些相关命令和工具连接起来, 并且只有很少的一部分<quote>规则</quote>需要学习.
		绝大部分脚本第一次就可以正常的工作, 而且即使调试一个长一些的脚本也是很直观的.
    </para>

	<para>一个shell脚本是一个类似于<quote>小吃店的(quick and dirty)</quote>方法,
		在你使用原型设计一个复杂的应用的时候. 在工程开发的第一阶段,
		即使从功能中取得很有限的一个子集放到shell脚本中来完成往往都是非常有用的.
		使用这种方法, 程序的结果可以被测试和尝试运行, 
		并且在处理使用诸如C/C++, Java或者Perl语言编写的最终代码前, 主要的缺陷和陷阱往往就被发现了.
    </para>

	<para>Shell脚本遵循典型的UNIX哲学, 就是把大的复杂的工程分成小规模的子任务, 
		并且把这些部件和工具组合起来. 许多人认为这种办法更好一些, 至少这种办法比使用那种高\大\全的语言更美, 
		更愉悦, 更适合解决问题. 比如Perl就是这种能干任何事能适合任何人的语言, 
		但是代价就是你需要强迫自己使用这种语言来思考解决问题的办法. </para>

    <para>什么时候不适合使用Shell脚本

      <itemizedlist>
    <listitem>
      <para>资源密集型的任务, 尤其在需要考虑效率时(比如, 排序, hash等等). </para>
    </listitem> <listitem>
	<para>需要处理大任务的数学操作, 尤其是浮点运算, 精确运算, 
		或者复杂的算术运算(这种情况一般使用C++或FORTRAN来处理). </para>
    </listitem> <listitem>
      <para>有跨平台移植需求(一般使用C或Java). </para>
    </listitem> <listitem>
      <para>复杂的应用, 在必须使用结构化编程的时候(需要变量的类型检查, 函数原型, 等等). </para>
    </listitem> <listitem>
      <para>至关重要的应用, 比如说为了这个应用, 你需要赌上自己的农场, 甚至赌上你们公司的未来. 
      </para>
    </listitem> <listitem>
      <para>对于安全有很高要求的任务, 比如你需要一个健壮的系统来防止入侵, 破解, 恶意破坏等等. </para>
    </listitem> <listitem>
      <para>工程的每个组成部分之间, 需要连锁的依赖性. </para>
    </listitem> <listitem>
    <para>需要大规模的文件操作(Bash受限于顺序地进行文件访问, 而且只能使用这种笨拙的效率低下的一行接一行的处理方式. ). </para>
    </listitem> <listitem>
      <para>需要多维数组的支持. </para>
    </listitem> <listitem>
      <para>需要数据结构的支持,比如链表或数组等数据结构. </para>
    </listitem> <listitem>
      <para>需要产生或操作图形化界面GUI. </para>
    </listitem> <listitem>
      <para>需要直接操作系统硬件. </para>
    </listitem> <listitem>
      <para>需要I/O或socket接口. </para>
    </listitem> <listitem>
      <para>需要使用库或者遗留下来的旧代码的接口. </para>
    </listitem> <listitem>
      <para>个人的, 闭源的应用(shell脚本把代码就放在文本文件中, 全世界都能看到). </para>
        
    </listitem>
      </itemizedlist></para>

    <para>如果你的应用符合上边的任意一条, 那么就考虑一下更强大的语言吧--或许是Perl, Tcl, Python,
		Ruby -- 或者是更高层次的编译语言比如C/C++, 或者是Java. 即使如此, 你会发现,
		使用shell来原型开发你的应用, 在开发步骤中也是非常有用的. </para>

	<para>我们将开始使用<acronym>Bash</acronym>, 
		Bash是<quote>Bourne-Again shell</quote>首字母的缩写, 
		也是Stephen Bourne的经典的Bourne shell的一个双关语, (译者: 说实话, 我一直搞不清这个双关语是什么意思, 
		为什么叫"Bourn-Again shell", 这其中应该有个什么典故吧, 哪位好心, 告诉我一下^^). 
		对于所有UNIX上的shell脚本来说, Bash已经成为了<foreignphrase>事实上</foreignphrase>的标准了. 
		同时这本书也覆盖了绝大部分的其他一些shell的原则, 
		比如Korn Shell, Bash从ksh中继承了一部分特性,
       <footnote><para><emphasis>ksh88</emphasis>的许多特性,甚至是一些<emphasis>ksh93</emphasis>的特性都被合并到Bash中了.
    </para></footnote>
	C Shell和它的变种. 
	(注意: C Shell编程是不被推荐的, 因为一些特定的内在问题, 
	Tom Christiansen在1993年10月上的<ulink url="http://www.etext.org/Quartz/computer/unix/csh.harmful.gz">Usenet post</ulink>指出了这个问题). 
      </para>

	  <para>接下来是脚本的一些说明. 在展示shell不同的特征之前, 它可以减轻一些阅读书中例子的负担. 
		  本书中的例子脚本, 都在尽可能的范围内进行了测试, 并且其中的一些将使用在真实的生活中. 
		  读者可以运行这些例子脚本(使用<filename>scriptname.sh</filename>或者<filename>scriptname.bash</filename>的形式),

		  <footnote><para>根据惯例,用户编写的Bourne shell脚本应该在脚本的名字后边加上<filename>.sh</filename>扩展名. 
				  一些系统脚本, 比如那些在<filename class="directory">/etc/rc.d</filename>中的脚本,则不遵循这种命名习惯. 
     </para></footnote>

	 并给这些脚本执行权限(<userinput>chmod u+rx scriptname</userinput>), 然后执行它们, 看看发生了什么. 
	 如果你没有相应的源代码, 
	 那么就从本书的 <ulink url="http://www.tldp.org/LDP/abs/abs-guide.html.tar.gz">HTML</ulink>,
      <ulink url="http://www.tldp.org/LDP/abs/abs-guide.pdf">pdf</ulink>,
	  或者<ulink url="http://www.ibiblio.org/pub/Linux/docs/linux-doc-project/abs-guide/abs-guide.txt.gz">text</ulink>版本中将这些源代码拷贝出来. 
	  考虑到这些脚本中的内容在我们还没解释它之前就被列在这里, 可能会影响读者的理解, 
	  这就需要读者暂时忽略这些内容. </para>

  <para>除非特别注明, 
	  本书<ulink url="mailto:thegrendel@theriver.com">作者</ulink>编写了本书中的绝大部分例子脚本.
       </para>

  </chapter> <!-- Why Shell Programming? -->


  <chapter id="sha-bang">
    <title>带着一个Sha-Bang出发(Sha-Bang指的是#!)</title>

    <epigraph>
      <attribution>Larry Wall</attribution>
      <para>Shell程序设计是1950年的光盘机 . . .</para> 
    </epigraph>

	<para>在一个最简单的例子中, 一个shell脚本其实就是将一堆系统命令列在一个文件中. 
		它的最基本的用处就是, 在你每次输入这些特定顺序的命令时可以少敲一些字. </para>

    <example id="ex1">
      <title><command>清除</command>: 清除/var/log下的log文件</title> <programlisting>&ex1;</programlisting>
    </example>

	<para>这根本就没什么稀奇的, 只不过是命令的堆积, 
		来让从console或者<firstterm>xterm</firstterm>中一个一个的输入命令更方便一些. 
		好处就是把所有命令都放在一个脚本中,不用每次都敲它们. 
      这样的话, 这个脚本就成为了一个<emphasis>工具</emphasis>, 
    对于特定的应用来说,这个脚本就很容易被修改或定制.
      </para>

    <example id="ex1a">
      <title><command>清除</command>:一个改良的清除脚本
      </title> <programlisting>&ex1a;</programlisting>
    </example>

    <para>现在,让我们看一下一个真正意义的脚本.而且我们可以走得更远 . . .</para>

    <example id="ex2">
      <title><command>清除</command>: 一个增强的和广义的删除logfile的脚本
      </title>
      <programlisting>&ex2;</programlisting>
    </example>

	<para>因为你可能希望将系统log全部消灭, 这个版本留下了log消息最后的部分.
		你将不断地找到新的方法来完善这个脚本,并提高效率. </para>

    <para>要注意,在每个脚本的开头都使用
      <firstterm><indexterm>
	  <primary>sha-bang</primary>
	</indexterm> sha-bang</firstterm>
      (<token>
	<indexterm>
	  <primary>#!</primary>
  </indexterm> #!</token>), 这意味着告诉你的系统这个文件的执行需要指定一个解释器. 
  <anchor id="magnumref">
      <token>#!</token> 实际上是一个2字节的
	  <footnote><para>那些具有UNIX味道的脚本(基于4.2BSD)需要一个4字节的魔法数字, 在<token>!</token>后边需要一个空格 
	  -- <userinput>#! /bin/sh</userinput>.</para></footnote>

	<indexterm>
	  <primary>魔法数字</primary>
	</indexterm>
	<emphasis>魔法数字</emphasis>, 
	这是指定一个文件类型的特殊标记, 换句话说, 
	在这种情况下, 
	指的就是一个可执行的脚本(键入<userinput>man magic</userinput>来获得关于这个迷人话题的更多详细信息). 
	在<emphasis>sha-bang</emphasis>之后接着是一个<firstterm>路径名</firstterm>. 
	这个路径名就是解释脚本中命令的解释程序所在的路径,
	可能是一个shell, 也可能是一个程序语言, 也可能是一个工具包中的命令程序.
	这个解释程序从头开始解释并且执行脚本中的命令(从<emphasis>sha-bang</emphasis>行下边的一行开始), 忽略注释.

	  <footnote>
	    <para>脚本中的<token>#!</token>所在的行的最重要的任务就是告诉系统本脚本是使用哪种命令解释器.
	      (<command>sh</command>或者<command>bash</command>).
	      因为这行是以<token>#</token>作为行的开头,
		  当命令解释器执行这个脚本的时候,会把它作为一个注释行. 当然, 在这之前, 
		  这行语句已经完成了它的任务, 就是调用命令解释器. </para>
	    <para>如果脚本中还包含有
			<emphasis>其他</emphasis>的<token>#!</token>行, 
		那么<command>bash</command>将会把它看成是一个一般的注释行.
	        <programlisting>#!/bin/bash

echo "Part 1 of script."
a=1

#!/bin/bash
# 这将*不会*启动一个新脚本.

echo "Part 2 of script."
echo $a  # Value of $a stays at 1.</programlisting></para>
	   </footnote>

	</para>


    <para><programlisting>#!/bin/sh
#!/bin/bash
#!/usr/bin/perl
#!/usr/bin/tcl
#!/bin/sed -f
#!/usr/awk -f</programlisting></para>

    <para>上边每一个脚本头的行都指定了一个不同的命令解释器,
      如果是<filename>/bin/sh</filename>, 那么就是默认shell
	  (在Linux系统上默认就是<command>bash</command>), 
	  否则的话就是其他解释器. 

        <footnote>
	  <para>这里可以玩一些小技巧.</para>
	  <para><programlisting>#!/bin/rm
# 自删除脚本.

# 当你运行这个脚本时, 基本上什么都不会发生. . . 当然这个文件消失不见了. 

WHATEVER=65

echo "This line will never print (betcha!)."

exit $WHATEVER  # 不要紧, 脚本是不会在这退出的. </programlisting> </para>

	  <para>当然,你还可以试试在一个<filename>README</filename>文件的开头加上一个<userinput>#!/bin/more</userinput>, 
		  并让它具有执行权限.
		  结果将是文档自动列出自己的内容. 
		  (一个使用<link linkend="catref">cat</link>命令的
		  <link linkend="heredocref">here document</link>在这里可能是一个更好的选择, 
	-- 参见<xref linkend="ex71">).</para>
	</footnote>

	使用<userinput>#!/bin/sh</userinput>, 
	因为大多数的商业UNIX系统上都是以Bourne shell作为默认shell,
    这样可以使脚本<link linkend="portabilityissues">移植</link>到non-Linux的机器上, 
    虽然这将会牺牲Bash一些独特的特征.
    但是脚本将与<acronym>POSIX</acronym>

	 <footnote>
	 <para><anchor id="posix2ref"><emphasis role="strong">P</emphasis>ortable
	 <emphasis role="strong">O</emphasis>perating
	 <emphasis role="strong">S</emphasis>ystem <emphasis
	 role="bold">I</emphasis>nterface(可移植的操作系统接口), 
	 标准化类UNI<emphasis role="strong">X</emphasis>操作系统的一种尝试. 
	 POSIX规范可以在<ulink url="http://www.opengroup.org/onlinepubs/007904975/toc.htm">Open
	 Group site</ulink>中进行查阅.</para>
	 </footnote>

     的<command>sh</command>标准相一致. </para>

    <para>注意<quote>sha-bang</quote>后边给出的路径名必须是正确的, 
		否则将会出现一个错误消息 -- 通常是<quote>Command not found</quote> 
		-- 这将是你运行这个脚本时所得到的唯一结果. </para>

	<para>当然<token>#!</token>也可以被忽略, 
	不过这样你的脚本文件就只能是一些命令的集合, 不能够使用shell内建的指令了. 
	上边第二个例子必须以<token>#!</token>开头, 
	是因为分配变量了, <userinput>lines=50</userinput>, 
	这就使用了一个shell特有的用法.
	<footnote><para>如果Bash是你的默认shell, 
	那么脚本的开头也不用非得写上<token>#!</token>.
	但是如果你使用不同的shell来开启一个脚本的话,
	比如<firstterm>tcsh</firstterm>, 
	那么你就<emphasis>必须</emphasis>需要<token>#!</token>了. </para></footnote>
	  再次提醒你<userinput>#!/bin/sh</userinput>将会调用默认的shell解释器,
	  在Linux机器上默认是<filename>/bin/bash</filename>. </para>


      <tip>
		  <para>这个例子鼓励你使用模块化的方式来编写脚本. 
			 平时也要多注意收集一些比较有代表性的
	<quote>模版</quote>代码, 这些零碎的代码可能用在你将来编写的脚本中.
	最后你就能生成一个很好的可扩展的例程库.
	以下边这个脚本为例, 这个脚本用来测试脚本被调用的参数数量是否正确. </para>

	<para><programlisting>E_WRONG_ARGS=65
script_parameters="-a -h -m -z"
#                  -a = all, -h = help, 等等.

if [ $# -ne $Number_of_expected_args ]
then
  echo "Usage: `basename $0` $script_parameters"
  # `basename $0` 是这个脚本的文件名.
  exit $E_WRONG_ARGS
fi</programlisting>
      </para>

	  <para>大多数情况下,你需要编写一个脚本来执行一个特定的任务, 
		  在本章中第一个脚本就是一个这样的例子, 然后你会修改它来完成一个不同的, 
		  但比较相似的任务. 使用变量来代替写死(<quote>硬编码(hard-wired)</quote>)的常量, 就是一个很好的习惯, 
        将重复的代码放到一个<link linkend="functionref">函数</link>中,也是一种好习惯. </para>

      </tip>



    <sect1 id="invoking">
      <title>调用一个脚本</title>

      <para>编写完脚本之后,你可以使用<userinput>sh scriptname</userinput>,

	  <footnote><para>小心: 使用<userinput>sh
	  scriptname</userinput>来调用脚本的时候将会关闭一些Bash特定的扩展, 
	  脚本可能因此而调用失败. </para></footnote>
	
	或者<userinput>bash scriptname</userinput>来调用这个脚本. 
	(不推荐使用<userinput>sh &lt;scriptname</userinput>,
	因为这禁用了脚本从<filename>stdin</filename>中读数据的功能. )
	更方便的方法是让脚本本身就具有可执行权限, 
	通过<link linkend="chmodref">chmod</link>命令可以修改.

	<variablelist>
	  <varlistentry>
	    <term>比如:</term> <listitem>
	      <para><userinput>chmod 555 scriptname</userinput> (允许任何人都具有可读和执行权限)
	        <footnote><para>脚本需要<emphasis>读</emphasis>和可执行的权限, 
			因为shell需要读这个脚本. </para></footnote>
	      </para>
	    </listitem>
	  </varlistentry> <varlistentry>
	    <term>或者</term> <listitem>
			<para><userinput>chmod +rx scriptname</userinput> (允许任何人都具有可读和执行权限)</para>
		   	<para><userinput>chmod u+rx scriptname</userinput> (只给脚本的所有者可读和执行权限)</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </para>

      <para>既然脚本已经具有了可执行权限,现在你可以使用
	<userinput>./scriptname</userinput>
	
	<footnote><para>为什么不直接使用<userinput>scriptname</userinput>来调用脚本? 
	如果你当前的目录下(<link linkend="pwdref">$PWD</link>) 正好是
	  <emphasis>scriptname</emphasis>所在的目录, 为什么它运行不了呢? 
	  失败的原因是出于安全考虑, 当前目录并没有被加在用户的
	  <link linkend="pathref">$PATH</link>环境变量中. 
	  因此,在当前目录下调用脚本必须使用<userinput>./scriptname</userinput>这种形式.</para></footnote>

	来测试这个脚本了. 
	如果这个脚本以一个<quote>sha-bang</quote>行开头, 那么脚本将会调用合适的命令解释器来运行. </para>

<para>最后一步, 在脚本被测试和debug之后, 你可能想把它移动到<filename class="directory">/usr/local/bin</filename>下, 
	(当然是以root身份), 来让你的脚本对所有用户都有用. 
     这样以来, 用户就可以在命令行上简单的输入<command>scriptname</command>
        <keycap>[ENTER]</keycap>就可以运行这个脚本了. </para>

    </sect1> <!-- Invoking the script -->


    <sect1 id="prelimexer">
      <title>初步的练习</title>

      <orderedlist>

        <listitem>
	<para>系统管理员经常会为了自动化一些常用的任务而编写脚本.举出几个这种有用的脚本的实例. </para>
	</listitem>  

	<listitem>  
	<para>编写一个脚本,显示<link linkend="dateref">时间和日期</link>, 
		<link linkend="whoref">列出所有登陆的用户</link>, 
		然后给出系统的<link linkend="uptimeref">更新时间</link>. 
		最后这个脚本将会<link linkend="ioredirref">把这些信息保存</link>到一个log file中. </para>
	</listitem>

      </orderedlist>

    </sect1> <!-- Preliminary Exercises -->

  </chapter> <!-- Starting Off With a Sha-Bang -->


  </part> <!-- Part 1 (Introduction) -->



  <part label="第二部分" id="part2">
    <title>基本</title>


  <chapter id="special-chars">
    <title>特殊字符</title>

      <variablelist id="scharlist">
        <title><anchor id="scharlist1">用在脚本和其他地方的特殊字符</title>

	<varlistentry><term><token>#</token></term>
	  <indexterm>
	    <primary>#</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>#</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>comment</primary>
	  </indexterm>	  
	  <listitem>
	    <formalpara><title>注释</title>
	      <para>行首以<token>#</token>(<link linkend="magnumref"><token>#!</token>是个例外</link>)开头是注释. </para>
	    </formalpara>

	    <para><programlisting># This line is a comment.</programlisting></para>

	    <para>注释也可以放在于本行命令的后边. </para>
	    
	    <para><programlisting>echo "A comment will follow." # 注释在这里.
#                            ^ 注意#前边的空白</programlisting></para>

	    <para>注释也可以放在本行行首<link linkend="whitespaceref">空白</link>的后面. </para>

	    <para><programlisting>	# A tab precedes this comment.</programlisting></para>

	    <caution><para>命令是不能放在同一行上注释的后边的. 因为没有办法把注释结束掉, 
				好让同一行上后边的<quote>代码生效</quote>. 
				只能够另起一行来使用下一个命令. </para></caution>

		<note><para>当然, 在<command>echo</command>中转义的<token>#</token>是<emphasis>不能</emphasis>作为注释的. 
				同样的, <token>#</token>也可以出现在<link linkend="psub2">特定的参数替换结构</link>中, 
			   	或者是出现在<link linkend="numconstants">数字常量表达式</link>中.

	    <programlisting>echo "The # here does not begin a comment."
echo 'The # here does not begin a comment.'
echo The \# here does not begin a comment.
echo The # 这里开始一个注释.

echo ${PATH#*:}       # 参数替换, 不是一个注释.
echo $(( 2#101011 ))  # 数制转换, 不是一个注释.

# 感谢, S.C.</programlisting>

	  标准的<link linkend="quotingref">引用和转义</link>字符(&quot; ' \)可以用来转义#. </para></note>

	  <para>某些特定的<link linkend="psorex1">模式匹配操作</link>也可以使用<token>#</token>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry><term><token>;</token></term>
	  <indexterm>
	    <primary>;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>separator</primary>
	  </indexterm>	  
	  
	  <listitem>
	    <formalpara><title>命令分隔符[分号, 即;]</title>
	      <para>可以在同一行上写两个或两个以上的命令. </para>
	    </formalpara>

	    <para>
	      <programlisting>echo hello; echo there


if [ -x "$filename" ]; then    # 注意: "if"和"then"需要分隔. 
                               # 为什么?
  echo "File $filename exists."; cp $filename $filename.bak
else
  echo "File $filename not found."; touch $filename
fi; echo "File test complete."</programlisting>
</para>
	    
	    <para>注意一下<quote><token>;</token></quote>某些情况下需要<link linkend="escp">转义</link>.</para>

	    </listitem>
	</varlistentry>

	<varlistentry><term><token>;;</token></term>
	  <indexterm>
	    <primary>;;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>case</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>;;</primary>
	  </indexterm>	  
	  
	  <listitem>
	    <formalpara><title>终止<link linkend="caseesac1">case</link>选项[双分号, 即;;]</title>
	      <para><anchor id="doublesemicolon"></para>
	    </formalpara>

	    <para><programlisting>case "$variable" in
abc)  echo "\$variable = abc" ;;
xyz)  echo "\$variable = xyz" ;;
esac</programlisting></para>

	    </listitem>
	</varlistentry>


	<varlistentry><term><token>.</token></term>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>.</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dot command</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>source</primary>
	  </indexterm>	  

	  <listitem>
	    <para><anchor id="dotref"></para>
	    <formalpara><title><quote>点</quote>命令[句点, 即.]</title>
			<para>等价于<link linkend="sourceref">source</link>命令(参见 <xref linkend="ex38">). 
					这是一个bash的<link linkend="builtinref">内建命令</link>.</para>
	    </formalpara>

	    </listitem>
	</varlistentry>


	<varlistentry><term><token>.</token></term>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>.</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>filename</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>part of a filename</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title><quote>点</quote>作为文件名的一部分</title>
			<para>如果点放在文件名的开头的话, 那么这个文件将会成为<quote>隐藏</quote>文件, 
				并且<link linkend="lsref">ls</link>命令将不会正常的显示出这个文件. 
	        <screen><prompt>bash$ </prompt><userinput>touch .hidden-file</userinput>
<prompt>bash$ </prompt><userinput>ls -l</userinput>	      
<computeroutput>total 10
 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook</computeroutput>


<prompt>bash$ </prompt><userinput>ls -al</userinput>	      
<computeroutput>total 14
 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
 drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
 -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file</computeroutput>
	        </screen>
	      </para>
	    </formalpara>

	      <para>如果作为目录名的话, <emphasis>一个单独的点</emphasis>代表当前的工作目录, 
		而<emphasis>两个点</emphasis>表示上一级目录. </para>

	      <para>
	        <screen>
<prompt>bash$ </prompt><userinput>pwd</userinput>
<computeroutput>/home/bozo/projects</computeroutput>

<prompt>bash$ </prompt><userinput>cd .</userinput>
<prompt>bash$ </prompt><userinput>pwd</userinput>
<computeroutput>/home/bozo/projects</computeroutput>

<prompt>bash$ </prompt><userinput>cd ..</userinput>
<prompt>bash$ </prompt><userinput>pwd</userinput>
<computeroutput>/home/bozo/</computeroutput>
	        </screen>
	      </para>

	      <para><emphasis>点</emphasis>经常会出现在文件移动命令的目的参数(目录)的位置上. </para>
	      
	      <para>
	        <screen>
<prompt>bash$ </prompt><userinput>cp /home/bozo/current_work/junk/* .</userinput>
	        </screen>
	      </para>

	  </listitem>
	</varlistentry>


	<varlistentry><term><token>.</token></term>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>.</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>character match</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>match single character</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title><quote>点</quote>字符匹配</title>
			<para>当用作<link linkend="regexdot">匹配字符</link>的作用时, 
				通常都是作为<link linkend="regexref">正则表达式</link>的一部分来使用,
			   	<quote>点</quote>用来匹配任何的单个字符. </para>
	    </formalpara>

	    </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>"</token></term>
	  <listitem><formalpara><title><link linkend="dblquo">部分引用</link>[双引号, 即"]</title>
	      <para><emphasis>"STRING"</emphasis>将会阻止(解释)<emphasis>STRING</emphasis>中大部分特殊的字符. 
	      参见<xref linkend="quoting">.</para>
	    </formalpara> </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>'</token></term>
	  <listitem><formalpara><title><link linkend="snglquo">全引用</link>[单引号, 即']</title>
	      <para><emphasis>'STRING'</emphasis>将会阻止<emphasis>STRING</emphasis>中所有特殊字符的解释. 
	      这是一种比使用<token>"</token>更强烈的形式.
	      参见<xref linkend="quoting">.</para>
	    </formalpara> </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>,</token></term>
	  <listitem><formalpara><title><link linkend="commaop">逗号操作符</link></title>
	      <para><command>逗号操作符</command>链接了一系列的算术操作. 
	      虽然里边所有的内容都被运行了,但只有最后一项被返回. 
               <programlisting>let "t2 = ((a = 9, 15 / 3))"  # Set "a = 9" and "t2 = 15 / 3"</programlisting>
	      </para> 
	    </formalpara> </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>\</token></term>
	  <listitem><formalpara><title><link linkend="escp">转义符</link>[反斜线, 即\]</title>
	      <para>一种对单字符的引用机制. </para>
	    </formalpara>
	      
		<para><userinput>\X</userinput>将会<quote>转义</quote>字符<emphasis>X</emphasis>. 
			这等价于<emphasis><quote>X</quote></emphasis>, 也等价于<emphasis>'X'</emphasis>. 
		   	<token>\</token>通常用来转义<token>"</token>和<token>'</token>, 
			这样双引号和但引号就不会被解释成特殊含义了. </para>
	      <para>参见<xref linkend="quoting">来深入地了解转义符的详细解释. </para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/</token></term>
	  <listitem><formalpara><title>文件名路径分隔符[斜线, 即/]</title>
	      <para>分隔文件名不同的部分(比如 <filename>/home/bozo/projects/Makefile</filename>). </para>
	    </formalpara>
	    <para>也可以用来作为除法<link linkend="arops1">算术操作符</link>. </para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>`</token></term>
	  <listitem><formalpara><title><link
	  linkend="commandsubref">命令替换</link></title>
	   <para><command>`command`</command>结构可以将<command>命令</command>的输出赋值到一个变量中去. 
		 我们在后边的<link linkend="backquotesref">后置引用(backquotes)</link>或后置标记(backticks)中也会讲解. 
	  </para>
  </formalpara>
  </listitem>
	</varlistentry>

	<varlistentry><term><token>:</token></term>
	  <indexterm>
	    <primary>:</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>:</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>null command</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>true</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>endless loop</primary>
	  </indexterm>	  

	  <listitem>
	    <para><anchor id="nullref"></para>
	    <formalpara><title>空命令[冒号, 即:]</title>
	      <para>等价于<quote>NOP</quote> (<replaceable>no op</replaceable>, 
		一个什么也不干的命令). 也可以被认为与shell的内建命令<link linkend="trueref">true</link>作用相同. 
		<quote><token>:</token></quote>命令是一个bash的<link linkend="builtinref">内建命令</link>, 
		它的<link linkend="exitstatusref">退出码(exit status)</link>是<quote>true</quote>(<returnvalue>0</returnvalue>). 
	    </para>
	    </formalpara>

	    <para><programlisting>:
echo $?   # 0</programlisting></para>


	    <para>死循环:</para>

	    <para><programlisting>
while :
do
   operation-1
   operation-2
   ...
   operation-n
done

# 与下边相同:
#    while true
#    do
#      ...
#    done</programlisting>
	    </para>

	    <para>在if/then中的占位符:</para>

	    <para><programlisting>
if condition
then :   # 什么都不做,引出分支. 
else
   take-some-action
fi</programlisting>
	    </para>

		<para>在一个二元命令中提供一个占位符, 具体参见<xref linkend="arithops">, 
		和<link linkend="defparam">默认参数</link>.</para>

	    <para><programlisting>: ${username=`whoami`}
# ${username=`whoami`}   如果没有开头的":"的话, 将会给出一个错误, 
#                        除非"username"是一个命令或者内建命令...</programlisting>
</para>

		<para>在<link linkend="heredocref">here document</link>中提供一个命令所需的占位符. 
		参见<xref linkend="anonheredoc">. </para>

	    <para>使用<link linkend="paramsubref">参数替换</link>来评估字符串变量
		(参见<xref linkend="ex6">).

	    <programlisting>: ${HOSTNAME?} ${USER?} ${MAIL?}
#  如果一个或多个必要的环境变量没被设置的话, 
#+ 就打印错误信息. </programlisting>
		</para>
            
            <para><command><link linkend="exprepl1">变量扩展/子串替换</link></command>. </para>
	    
	    <para>在与<token>&gt;</token><link linkend="ioredirref">重定向操作符</link>结合使用时,
	      将会把一个文件清空, 但是并不会修改这个文件的权限. 
	      如果之前这个文件并不存在, 那么就创建这个文件. 

	      <programlisting>: > data.xxx   # 文件"data.xxx"现在被清空了. 

# 与 cat /dev/null >data.xxx 的作用相同 
# 然而,这并不会产生一个新的进程, 因为":"是一个内建命令. </programlisting>
              参见<xref linkend="ex12">.</para>

			  <para>在与<token>&gt;&gt;</token>重定向操作符结合使用时, 
				  将不会对预先存在的目标文件(<userinput>: &gt;&gt; target_file</userinput>)产生任何影响. 
	      如果这个文件之前并不存在, 那么就创建它. </para>

	  <note><para>这只适用于正规文件, 而不适用于管道, 
			  符号连接, 和某些特殊文件. </para></note>


	    <para>也可能用来作为注释行, 虽然我们不推荐这么做.
		使用<token>#</token>来注释的话, 将关闭剩余行的错误检查, 
		所以可以在注释行中写任何东西. 
	    然而, 使用<token>:</token>的话将不会这样.
	      <programlisting>: This is a comment that generates an error, ( if [ $x -eq 3] ).</programlisting>
	    </para>

	    <para><quote><token>:</token></quote>还用来在<filename>/etc/passwd</filename>和<link linkend="pathref">$PATH</link>变量中做分隔符.
	      <screen><prompt>bash$ </prompt><userinput>echo $PATH</userinput>
<computeroutput>/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</computeroutput></screen>
	    </para>



	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>!</token></term>
	  <indexterm>
	    <primary>!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>not</primary>
	    <secondary>logical</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>not</primary>
	  </indexterm>	  

	  <listitem>
	  <para><anchor id="notref"></para>
	  <formalpara><title>取反操作符[叹号, 即!]</title>

	      <para><token>!</token>操作符将会反转命令的<link linkend="exitstatusref">退出码</link>的结果, 
		(具体参见<xref linkend="negcond">). 也会反转测试操作符的意义, 
			比如修改<quote>等号</quote>( <link linkend="equalsignref">=</link> )为<quote>不等号</quote>( != ). 
			<token>!</token>操作符是Bash的<link linkend="keywordref">关键字</link>. </para>

	    </formalpara>
		<para>在一个不同的上下文中, 
			<token>!</token>也会出现在<link linkend="ivrref">变量的间接引用</link>中. </para>

		<para>在另一种上下文中, 如<emphasis>命令行</emphasis>模式下, 
		<token>!</token>还能反转bash的<emphasis>历史机制</emphasis> (参见<xref linkend="histcommands">). 
			需要注意的是, 在一个脚本中, <emphasis>历史机制</emphasis>是被禁用的. </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>*</token></term>
	  <indexterm>
	    <primary>*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>wild card</primary>
	    <secondary>globbing</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>regular expression</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>通配符[星号, 即*]</title>

			  <para><token>*</token>可以用来做文件名匹配(这个东西有个专有名词叫<link 
					  linkend="globbingref">globbing</link>)的<quote>通配符</quote>. 
		含义是, 可以用来匹配给定目录下的任何文件名. </para>
	    </formalpara>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo *</userinput>
<computeroutput>abs-book.sgml add-drive.sh agram.sh alias.sh</computeroutput>
	      </screen>
	    </para>
		
	      <para><token>*</token>也可以用在<link
		linkend="regexref">正则表达式</link>中, 用来匹配任意个数(包含0个)的字符. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*</token></term>
	  <indexterm>
	    <primary>*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>multiplication</primary>
	    <secondary>exponentiation</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>arithmetic operator</primary>
	  </indexterm>	  

	  <listitem><formalpara><title><link linkend="arops1">算术操作符</link></title>

	      <para>在算术操作符的上下文中, <token>*</token>号表示乘法运算. </para>

	    </formalpara>

		<para>如果要做求幂运算, 使用<token>**</token>, 
			这是<link linkend="exponentiationref">求幂操作符</link>. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>?</token></term>
	  <indexterm>
	    <primary>?</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>?</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>test</primary>
	    <secondary>operator</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>test token</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>测试操作符</title>
	      <para>在一个特定的表达式中, <token>?</token>用来测试一个条件的结果. </para>
	    </formalpara>

		<para>在一个<link linkend="dblparens">双括号结构</link>中, 
		<token>?</token>就是C语言的三元操作符. 参见<xref linkend="cvars">.</para>

		<para>在<link linkend="paramsubref">参数替换</link>表达式中, 
			<token>?</token><link linkend="qerrmsg">用来测试一个变量是否被set了. </link>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>?</token></term>
	  <indexterm>
	    <primary>?</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>?</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>wild card</primary>
	    <secondary>globbing</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>regular expression</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>通配符</title>

			  <para><token>?</token>在<link linkend="globbingref">通配(globbing)</link>中, 
				  用来做匹配单个字符的<quote>通配符</quote>, 
				  在<link linkend="extregex">正则表达式</link>中, 
			也是用来<link linkend="quexregex">表示一个字符</link>. </para>

	    </formalpara>

	  </listitem>
	</varlistentry>

	<varlistentry><term><token>$</token></term>
	  <indexterm>
	    <primary>$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>variable substitution</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title><link linkend="varsubn">变量替换</link>(引用变量的内容)</title>
             <para>
	       <programlisting>var1=5
var2=23skidoo

echo $var1     # 5
echo $var2     # 23skidoo</programlisting>
	       </para>
	       </formalpara>

	       <para>在一个变量前面加上<token>$</token>用来引用这个变量的<emphasis>值</emphasis>. </para>

	  </listitem>
	</varlistentry>  

	<varlistentry><term><token>$</token></term>
	  <indexterm>
	    <primary>$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>regular expression</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>end of line</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title>行结束符</title>
		<para>在<link linkend="regexref">正则表达式中</link>, 
		<quote>$</quote>表示行结束符. </para>
	    </formalpara>

	    </listitem>
	</varlistentry>

	<varlistentry><term><token>${}</token></term>
	  <indexterm>
	    <primary>${}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>${}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter substitution</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title><link linkend="paramsubref">参数替换</link></title><para></para></formalpara>
	  </listitem>
	</varlistentry>  

	<varlistentry>
	  <term><token>$*</token></term>
	  <term><token>$@</token></term>
	  <indexterm>
	    <primary>$*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>$*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$@</primary>
	    <secondary>positional parameters</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>$@</primary>
	  </indexterm>	  

	  <listitem><formalpara><title><link linkend="appref">位置参数</link></title><para></para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>$?</token></term>
	  <indexterm>
	    <primary>$?</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>?</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>exit status</primary>
	    <secondary>variable</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>exit status</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>退出状态码变量</title>
	      <para><link linkend="exsref">$? 变量</link>
			  保存了一个命令, 一个<link linkend="functionref">函数</link>, 
			  或者是脚本本身的<link linkend="exitstatusref">退出状态码</link>. </para>
	    </formalpara>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="processidref"><token>$$</token></term>
	  <indexterm>
	    <primary>$$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>$$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>process ID</primary>
	    <secondary>variable</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>process ID</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>进程ID变量</title>
	      <para>这个<link linkend="proccid">$$ 变量</link>
	        保存了它所在脚本的<emphasis>进程 ID</emphasis>
		  <footnote><para><firstterm>PID</firstterm>, 
		    或<firstterm>进程 ID</firstterm>, 是分配给运行进程的一个数字. 
		    要想察看所有运行进程的<emphasis>PID</emphasis>可以使用<link
		    linkend="ppssref">ps</link>命令. </para>
		  </footnote></para></formalpara>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>()</token></term>

	  <listitem><formalpara><title>命令组</title>
	      <para><programlisting>(a=hello; echo $a)</programlisting></para>
	    </formalpara>

	  <important>
	  
		 <para>在<replaceable>括号</replaceable>中的命令列表, 
		 将会作为一个<link linkend="subshellsref">子shell</link>来运行.</para>

	    <para>在括号中的变量,由于是在子shell中,所以对于脚本剩下的部分是不可用的.
	      父进程, 也就是脚本本身, 
	      <link linkend="parvis">将不能够读取在子进程中创建的变量</link>, 也就是在子shell中创建的变量.
	      <programlisting>a=123
( a=321; )	      

echo "a = $a"   # a = 123
# 在圆括号中a变量, 更像是一个局部变量. </programlisting></para>
	  </important>


	  <formalpara><title>初始化数组</title>
	    <para><programlisting>Array=(element1 element2 element3)</programlisting></para>
	    </formalpara>
	  </listitem>

	</varlistentry>

	<varlistentry>
	  <indexterm>
	    <primary>{xxx,yyy,zzz..}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>brace expansion</primary>
	  </indexterm>	  
	  <term><token>{xxx,yyy,zzz,...}</token></term>
	  <listitem><formalpara><title>大括号扩展</title>
	      <para><anchor id="braceexpref"><programlisting>cat {file1,file2,file3} > combined_file
# 把file1, file2, file3连接在一起, 并且重定向到combined_file中.


cp file22.{txt,backup}
# 拷贝"file22.txt"到"file22.backup"中
</programlisting></para>
	    </formalpara>
	  <para>一个命令可能会对<replaceable>大括号</replaceable>

	     <footnote><para>The shell does the <emphasis>brace
	       expansion</emphasis>. The command itself acts upon the
	       <emphasis>result</emphasis> of the expansion.</para></footnote>
	  
   	  中的以逗号分割的文件列表起作用. 
	  (<link linkend="globbingref">通配(globbing)</link>)将对大括号中的文件名做扩展. </para>

	  <caution>
	    <para>在大括号中, 不允许有空白, <emphasis>除非</emphasis>这个空白被引用或转义. </para>
	    
	    <para><userinput>echo {file1,file2}\ :{\ A," B",' C'}</userinput></para>
	    <para><computeroutput>file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</computeroutput></para>

	   </caution>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>{}</token></term>
	  <indexterm>
	    <primary>{}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>block of code</primary>
	  </indexterm>	  

	  <listitem>
	  <para><anchor id="codeblockref"></para>
		  <formalpara><title>代码块[大括号, 即{}]</title>
	      <para>又被称为<firstterm>内部组</firstterm>,
		这个结构事实上创建了一个<firstterm>匿名函数</firstterm>(一个没有名字的函数). 
		然而, 与<quote>标准</quote><link linkend="functionref">函数</link>不同的是, 
		在其中声明的变量,对于脚本其他部分的代码来说还是可见的. </para></formalpara>

	      <para> <screen><prompt>bash$ </prompt><userinput>{ local a;
	      a=123; }</userinput>
<computeroutput>bash: local: can only be used in a
function</computeroutput>
	      </screen> </para>

	      <para><programlisting>a=123
{ a=321; }
echo "a = $a"   # a = 321   (说明在代码块中对变量a所作的修改, 影响了外边的变量)

# 感谢, S.C.</programlisting></para>


	    <para>下边的代码展示了在大括号结构中代码的<link
	      linkend="ioredirref">I/O 重定向</link>. </para>

	    <example id="ex8">
	      <title>代码块和I/O重定向</title>
	      <programlisting>&ex8;</programlisting>
	    </example>

	    <example id="rpmcheck">
	      <title>将一个代码块的结果保存到文件</title>
	      <programlisting>&rpmcheck;</programlisting>
	    </example>

	    <note><para>与上面所讲到的()中的命令组不同的是, 
		{大括号}中的代码块将<emphasis>不会</emphasis>开启一个新的<link
	      linkend="subshellsref">子shell</link>.

		<footnote><para>例外: 在pipe中的一个大括号中的代码段<emphasis>可能</emphasis>运行在一个
		  <link linkend="subshellsref">子shell</link>中.

		<programlisting>ls | { read firstline; read secondline; }
#  错误. 在大括号中的代码段, 将运行到子shell中, 
#+ 所以"ls"的输出将不能传递到代码块中. 
echo "First line is $firstline; second line is $secondline"  # 不能工作.

# 感谢, S.C.</programlisting></para></footnote>

	      </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>{} \;</token></term>
	  <listitem>

	  <formalpara><title>路径名</title>
		  <para>一般都在<link linkend="findref">find</link>命令中使用. 
		这<emphasis>不是</emphasis>一个shell<link linkend="builtinref">内建命令</link>. </para>
	    </formalpara>

	      <note><para><quote><token>;</token></quote>用来结束<command>find</command>命令序列的<option>-exec</option>选项. 
		 它需要被保护以防止被shell所解释. </para></note>

	  </listitem>
	</varlistentry>


	<varlistentry><term><token>[ ]</token></term>
	  <indexterm>
	    <primary>[]</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>[ ]</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>test</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title>条件测试</title>
             <para></para></formalpara>
	     <para><anchor id="leftbracket"><link
			linkend="ifthen">条件测试</link>表达式放在<command>[ ]</command>中. 
		值得注意的是<command>[</command>是shell内建<command>test</command>命令的一部分, 
		<emphasis>并不是</emphasis><filename>/usr/bin/test</filename>中的外部命令的一个链接.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>[[ ]]</token></term>
	  <indexterm>
	    <primary>[[]]</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>[[ ]]</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>test</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title>测试</title>
             <para></para></formalpara>
	     <para>测试表达式放在<token>[[ ]]</token>中. (shell<link linkend="keywordref">关键字</link>). </para>
	     <para>具体参见关于<link
	     linkend="dblbrackets">[[ ... ]]结构的讨论</link>.</para> 
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>[ ]</token></term>
	  <indexterm>
	    <primary>[ ]</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>array_element[ ]</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>array element</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title>数组元素</title>
             <para></para></formalpara>
	     <para>在一个<link linkend="arrayref">array</link>结构的上下文中,
	       中括号用来引用数组中每个元素的编号. 
	         <programlisting>Array[1]=slot_1
echo ${Array[1]}</programlisting></para>		 
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>[ ]</token></term>
	  <indexterm>
	    <primary>[ ]</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>character range</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>regular expression</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title>字符范围</title>
             <para></para></formalpara>
	     <para>用作<link linkend="regexref">正则表达式</link>的一部分, 
	       方括号描述一个匹配的<link linkend="bracketsref">字符范围</link>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>(( ))</token></term>
	  <indexterm>
	    <primary>(( ))</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>(( ))</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>integer comparison</primary>
	  </indexterm>	  
	  <listitem>
            <formalpara><title>整数扩展</title>
             <para></para></formalpara>
		 <para>扩展并计算在<token>(( ))</token>中的整数表达式. </para>
	     <para>请参考关于<link linkend="dblparens">(( ... )) 结构</link>的讨论.</para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>></token> <token>&></token> <token>>&</token> <token>>></token> <token>&lt;</token> <token>&lt;&gt;</token></term>
	  <indexterm>
	    <primary>></primary>
	  </indexterm>
	  <indexterm>
	    <primary>>&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>>></primary>
	  </indexterm>
	  <indexterm>
	    <primary><</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>>&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary><</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	  </indexterm>	  

	  <listitem><formalpara><title><link linkend="ioredirref">重定向</link></title>
	      <para></para>
	    </formalpara>

		<para>
			<userinput>scriptname >filename</userinput> 
			重定向<filename>scriptname</filename>的输出到文件<filename>filename</filename>中. 
			如果<filename>filename</filename>存在的话, 那么将会被覆盖. </para>

		<para>
			<userinput>command &>filename</userinput> 
			重定向<filename>command</filename>的<filename>stdout</filename>和<filename>stderr</filename>到<filename>filename</filename>中. </para>

	    <para><userinput>command >&2</userinput> 重定向<filename>command</filename>的<filename>stdout</filename>到<filename>stderr</filename>中. </para>

		<para><userinput>scriptname >>filename</userinput> 
			把<filename>scriptname</filename>的输出追加到文件<filename>filename</filename>中. 
			如果<filename>filename</filename>不存在的话, 
	      将会被创建. </para>

	    <para><userinput>[i]&lt;&gt;filename</userinput>
			打开文件<filename>filename</filename>用来读写, 
			并且分配<link linkend="fdref">文件描述符</link><token>i</token>给这个文件. 
			如果<filename>filename</filename>不存在, 这个文件将会被创建. </para>


	    <formalpara><title><link linkend="processsubref">进程替换</link></title>
	      <para></para>
	    </formalpara>

	    <para><userinput>(command)></userinput></para>
		<para><userinput><(command)</userinput></para>


	    <para><link linkend="ltref">在一种不同的上下文中</link>,
			<quote><token>&lt;</token></quote>和<quote><token>&gt;</token></quote>可用来做
			<link linkend="scomparison1">字符串比较操作</link>. </para>

	    <para><link linkend="intlt">在另一种上下文中</link>,
			<quote><token>&lt;</token></quote>和<quote><token>&gt;</token></quote>可用来做
			<link linkend="icomparison1">整数比较操作</link>. 
			参见<xref linkend="ex45">. </para>

	  </listitem>


	</varlistentry>

	<varlistentry>
	  <term><token><<</token></term>
	  <listitem><formalpara><title>用在<link
	    linkend="heredocref">here document</link>中的重定向.</title> 
	      <para></para></formalpara></listitem></varlistentry>

	<varlistentry>
	  <term><token><<<</token></term>
	  <listitem><formalpara><title>用在<link
	    linkend="herestringsref">here string</link>中的重定向.</title> 
	      <para></para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><</token></term>
	  <term><token>></token></term>
	  <indexterm>
	    <primary><</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary><</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>></primary>
	    <secondary>ASCII 比较</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>></primary>
	  </indexterm>	  

	  <listitem><formalpara><title><link linkend="ltref">ASCII
	    comparison</link></title>
	      <para><programlisting>veg1=carrots
veg2=tomatoes

if [[ "$veg1" < "$veg2" ]]
then
  echo "Although $veg1 precede $veg2 in the dictionary,"
  echo "this implies nothing about my culinary preferences."
else
  echo "What kind of dictionary are you using, anyhow?"
fi</programlisting></para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>\<</token></term>
	  <term><token>\></token></term>
	  <indexterm>
	    <primary>\<</primary>
	  </indexterm>
	  <indexterm>
	    <primary>regular expression</primary>
	    <secondary>\<</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>></primary>
	    <secondary>word boundary</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>></primary>
	  </indexterm>	  

	  <listitem>
		  <formalpara>
			  <title>
				  <link linkend="regexref">正则表达式</link>中的<link linkend="anglebrac">单词边界</link>
			  </title>
	    <para></para>
	    </formalpara>
	      <para><prompt>bash$ </prompt><userinput>grep '\&lt;the\&gt;' textfile</userinput></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|</token></term>
	  <indexterm>
	    <primary>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>pipe</primary>
	  </indexterm>	  

	  <listitem>
	  <para><anchor id="piperef"></para>
	  <formalpara><title>管道</title>
		  <para>分析前边命令的输出, 
			  并将输出作为后边命令的输入. 
			  这是一种产生命令链的好方法. </para>
	    </formalpara>

	    <para>
              <programlisting>echo ls -l | sh
#  传递"echo ls -l"的输出到shell中,
#+ 与一个简单的"ls -l"结果相同.


cat *.lst | sort | uniq
# 合并和排序所有的".lst"文件, 然后删除所有重复的行. </programlisting>
	    </para>

	    <sidebar>
			<para>管道是进程间通讯的一个典型办法, 
				将一个进程的<filename>stdout</filename>放到另一个进程的<filename>stdin</filename>中. 
	      标准的方法是将一个一般命令的输出, 
	      比如<link linkend="catref">cat</link>或者<link
	      linkend="echoref">echo</link>, 传递到一个
	      <quote>过滤命令</quote>(在这个过滤命令中将处理输入)中, 然后得到结果. </para>
	    <para>  
	      <userinput>cat $filename1 $filename2 | grep $search_word</userinput>
            </para>
	    </sidebar>


	    <para><anchor id="ucref">当然输出的命令也可以传递到脚本中. 

	      <programlisting>#!/bin/bash
# uppercase.sh : 修改输入, 全部转换为大写.

tr 'a-z' 'A-Z'
#  字符范围必须被""引用起来
#+ 来阻止产生单字符的文件名.

exit 0</programlisting>
              现在让我们输送<command>ls -l</command>的输出到一个脚本中. 

	      <screen><prompt>bash$ </prompt><userinput>ls -l | ./uppercase.sh</userinput>
<computeroutput>-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE</computeroutput>
	      </screen>
	    </para>

	     <note>

	     <para>管道中的每个进程的<filename>stdout</filename>比须被下一个进程作为<filename>stdin</filename>来读入. 
			 否则, 数据流会<emphasis>阻塞</emphasis>, 
			 并且管道将产生一些非预期的行为. 
	         <programlisting>cat file1 file2 | ls -l | sort
# 从"cat file1 file2"中的输出并没出现. </programlisting>
             </para>

			 <para>作为<link linkend="childref">子进程</link>的运行的管道, 
				 不能够改变脚本的变量.
	         <programlisting>variable="initial_value"
echo "new_value" | read variable
echo "variable = $variable"     # variable = initial_value</programlisting>
             </para>

	     <para>如果管道中的某个命令产生了一个异常,并中途失败,那么这个管道将过早的终止.
			 这种行为被叫做<emphasis>broken pipe</emphasis>, 
			 并且这种状态下将发送一个<emphasis>SIGPIPE</emphasis> <link
	       linkend="signald">信号</link>.</para>

	      </note>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>|</token></term>
	  <indexterm>
	    <primary>>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	    <secondary>force</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>noclobber</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>强制重定向(即使设置了<link linkend="noclobberref">noclobber选项</link>
		-- 就是-C选项)</title>
	      <para>这将强制的覆盖一个现存文件. </para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>||</token></term>
	  <indexterm>
	    <primary>||</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>||</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>or</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>logical operator</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title><link linkend="orref">或-逻辑操作</link></title>
			<para>在一个<link linkend="testconstructs1">条件测试结构</link>中, 
				如果条件测试结构两边中的<emphasis>任意一边</emphasis>结果为true的话, 
				<token>||</token>操作就会返回<returnvalue>0</returnvalue>(代表执行成功). 
			</para>
	    </formalpara>

	    </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>&amp;</token></term>
	  <listitem><formalpara><title>后台运行命令</title>
	      <para>一个命令后边跟一个<token>&amp;</token>
	        表示在后台运行. </para>
	    </formalpara>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>sleep 10 &</userinput>
<computeroutput>[1] 850</computeroutput>
<computeroutput>[1]+  Done                    sleep 10</computeroutput>
	      </screen>
	    </para>

	    <para>在一个脚本中,命令和<link
	      linkend="forloopref1">循环</link>都可能运行在后台. </para>

	    <example id="bgloop">
			<title>在后台运行一个循环</title>
	      <programlisting>&bgloop;</programlisting>
	    </example>

	    <caution><para>在一个脚本内后台运行一个命令,有可能造成这个脚本的挂起,等待一个按键
			响应. 幸运的是, 我们有针对这个问题的<link
	      linkend="waithang">解决办法</link>. </para></caution>

	    </listitem>
	</varlistentry>

	<varlistentry><term><token>&&</token></term>
	  <indexterm>
	    <primary>&&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>&&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>and</primary>
	  </indexterm>
	  <indexterm>
	    <primary>logical operator</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title><link linkend="logops1">与-逻辑操作</link></title>

		<para>在一个<link linkend="testconstructs1">条件测试结构</link>中, 
			只有在条件测试结构的<emphasis>两边</emphasis>结果都为true的时候, 
			<token>&&</token>操作才会返回<returnvalue>0</returnvalue>(代表sucess). 
		</para>

	    </formalpara>

	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="dashref"><token>-</token></term>
	  <listitem><formalpara><title>选项, 前缀</title>
			  <para>在所有的命令内如果想使用选项参数的话,前边都要加上<quote>-</quote>. </para>
	    </formalpara>
	      <para><userinput>COMMAND -[Option1][Option2][...]</userinput></para>
	      <para><userinput>ls -al</userinput></para>
	      <para><userinput>sort -dfu $filename</userinput></para>
	      <para><userinput>set -- $variable</userinput></para>
	      <para>
	      <programlisting>if [ $file1 -ot $file2 ]
then
  echo "File $file1 is older than $file2."
fi

if [ "$a" -eq "$b" ]
then
  echo "$a is equal to $b."
fi

if [ "$c" -eq 24 -a "$d" -eq 47 ]
then
  echo "$c equals 24 and $d equals 47."
fi</programlisting>  
	      </para>
  
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="dashref2"><token>-</token></term>
	  <indexterm>
	    <primary>-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	    <secondary>from/to stdin/stdout</secondary>
	  </indexterm>	  
	  <listitem><formalpara><title>用于重定向<filename>stdin</filename>或<filename>stdout</filename>[破折号, 即-]</title>
	    <para><anchor id="coxex"></para>
	    </formalpara>


	    <para><programlisting>(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
# 从一个目录移动整个目录树到另一个目录
# [感谢Alan Cox &lt;a.cox@swansea.ac.uk&gt;, 走出了部分修改]

# 1) cd /source/directory    源目录
# 2) &&                     "与列表": 如果'cd'命令成功了, 那么就执行下边的命令. 
# 3) tar cf - .              'c'创建一个新文档, 'f'后边跟'-'指定目标文件作为stdout
#                            '-'后边的'f'(file)选项, 指明作为stdout的目标文件. 
#                            并且在当前目录('.')执行.
# 4) |                       管道...
# 5) ( ... )                 一个子shell
# 6) cd /dest/directory      改变当前目录到目标目录.
# 7) &&                     "与列表", 同上
# 8) tar xpvf -              'x'解档, 'p'保证所有权和文件属性,
#                            'v'发完整消息到stdout,
#                            'f'后边跟'-',从stdin读取数据. 
#
#                            注意:'x' 是一个命令, 'p', 'v', 'f' 是选项.
# Whew!



# 更优雅的写法应该是:
#   cd source/directory
#   tar cf - . | (cd ../dest/directory; tar xpvf -)
#
#     当然也可以这么写:
# cp -a /source/directory/* /dest/directory
#     或者:
# cp -a /source/directory/* /source/directory/.[^.]* /dest/directory
#     如果在/source/directory中有隐藏文件的话.
</programlisting></para>

	    <para><programlisting>bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -
#  --未解压的tar文件--    | --然后把它传递到"tar"中--
#  如果 "tar" 没能够正常的处理"bunzip2",
#+ 这就需要使用管道来执行2个单独的步骤来完成它.
#  这个练习的目的是解档"bzipped"的kernel源文件.
</programlisting></para>
       
<para>注意, 在这个上下文中<quote>-</quote>本身并不是一个Bash操作, 
	而是一个可以被特定的UNIX工具识别的选项, 
	这些特定的UNIX工具特指那些可以写输出到<filename>stdout</filename>的工具, 
	    比如<command>tar</command>, <command>cat</command>, 等等.</para>


	    <para>
	      <screen><prompt>bash$ </prompt><userinput>echo "whatever" | cat -</userinput>
<computeroutput>whatever</computeroutput> </screen>
	    </para>


	    <para>在需要一个文件名的位置, 
			<replaceable>-</replaceable>重定向输出到<filename>stdout</filename>(有时候会在<userinput>tar和cf</userinput>中出现), 
			或者从<filename>stdin</filename>接受输入, 而不是从一个文件中接受输入. 
			这是在管道中使用文件导向(file-oriented)工具来作为过滤器的一种方法. </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>file</userinput>
<computeroutput>Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...</computeroutput>
	      </screen>

	    在命令行上单独给出一个<link linkend="fileref">file</link>, 会给出一个错误信息.
	    </para>

	    <para>
			添加一个<quote>-</quote>将得到一个更有用的结果. 
			这会使shell等待用户输入.

	      <screen>
<prompt>bash$ </prompt><userinput>file -</userinput>
<userinput>abc</userinput>
<computeroutput>standard input:              ASCII text</computeroutput>



<prompt>bash$ </prompt><userinput>file -</userinput>
<userinput>#!/bin/bash</userinput>
<computeroutput>standard input:              Bourne-Again shell script text executable</computeroutput>
	      </screen>

	      现在命令从<filename>stdin</filename>中接受了输入, 并分析它.
	    </para>

		<para><quote>-</quote>可以被用来将<filename>stdout</filename>通过管道传递到其他命令中. 
			这样就允许使用<link linkend="prependref">在一个文件开头添加几行</link>的技巧. </para>

	    <para>使用<link linkend="diffref">diff</link>命令来和另一个文件的<emphasis>某一段</emphasis>进行比较: </para>

<para><userinput>grep Linux file1 | diff file2 -</userinput></para>	      


            <para>最后, 来展示一个使用<replaceable>-</replaceable>的<link
	      linkend="tarref">tar</link>命令的一个真实的例子.</para>

	    <example id="ex58">
	      <title>备份最后一天所有修改的文件</title>
	      <programlisting>&ex58;</programlisting>
	    </example>

	    <caution>

			<para>以<quote>-</quote>开头的文件名在使用<quote>-</quote>作为重定向操作符的时候, 
				可能会产生问题. 应该写一个脚本来检查这个问题, 并给这个文件加上合适的前缀. 
	      比如: <filename>./-FILENAME</filename>, 
	      <filename>$PWD/-FILENAME</filename>, 或者 
	      <filename>$PATHNAME/-FILENAME</filename>. </para>

	      <para>如果变量以<replaceable>-</replaceable>开头进行命名, 可能也会引起问题. 
		<programlisting>var="-n"
echo $var		
# 具有"echo -n"的效果了,这样什么都不会输出的. </programlisting>
              </para>
	      </caution>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><token>-</token></term>
	  <listitem><formalpara><title>先前的工作目录</title>
			  <para><command>cd -</command>将会回到先前的工作目录. 
				 它使用了<link linkend="oldpwd">$OLDPWD</link> <link
		linkend="envref">环境变量</link>.</para>
	    </formalpara>
	      <caution><para>不要混淆这里所使用的<quote>-</quote>和先前我们所讨论的<quote>-</quote>重定向操作符. 
		对于<quote>-</quote>的具体解释只能依赖于具体的上下文. 
		</para></caution>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-</token></term>
	  <listitem><formalpara><title>减号</title>
	      <para>减号属于<link linkend="arops1">算术操作</link>. </para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>=</token></term>
	  <listitem><formalpara><title>等号</title>
	      <para><link linkend="eqref">赋值操作</link>
	        <programlisting>a=28
echo $a   # 28</programlisting></para>
	    </formalpara>
	    <para>在<link linkend="equalsignref">另一种上下文环境中</link>,
	      <quote><token>=</token></quote>也用来做<link
	      linkend="scomparison1">字符串比较</link>操作. </para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>+</token></term>
	  <listitem><formalpara><title>加号</title>
	      <para>加法<link linkend="arops1">算术操作</link>. </para>
	    </formalpara>
	    <para>在<link linkend="plusref">另一种上下文环境中</link>, 
	      <token>+</token>也是一种<link linkend="regexp">正则表达式</link>操作. </para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>+</token></term>
	  <listitem><formalpara><title>选项</title>
	      <para>一个命令或者过滤器的选项标记. </para>
	    </formalpara>
	    <para>某些命令<link
	      linkend="builtinref">内建命令</link>使用<token>+</token>来打开特定的选项,  
	      用<token>-</token>来禁用这些特定的选项. </para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>%</token></term>
	  <listitem><formalpara><title><link linkend="moduloref">取模</link></title>
	      <para>取模(一次除法的余数)<link linkend="arops1">算术操作</link>. </para>
	    </formalpara>
	    <para>在<link linkend="pctpatref">不同的上下文中</link>, 
	      <token>%</token>也是一种<link linkend="psub2">模式匹配</link>操作. </para>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~</token></term>
	  <listitem><formalpara><title>home目录[波浪号, 即~]</title>

	      <para>相当于<link
	        linkend="homedirref">$HOME</link>内部变量.

	      <emphasis>~bozo</emphasis>是bozo的home目录,
		并且<command>ls ~bozo</command>将列出其中的内容.
		<token>~/</token>就是当前用户的home目录,
		并且<command>ls ~/</command>将列出其中的内容. 

	      <screen><prompt>bash$ </prompt><userinput>echo ~bozo</userinput>
<computeroutput>/home/bozo</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~</userinput>
<computeroutput>/home/bozo</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~/</userinput>
<computeroutput>/home/bozo/</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~:</userinput>
<computeroutput>/home/bozo:</computeroutput>

<prompt>bash$ </prompt><userinput>echo ~nonexistent-user</userinput>
<computeroutput>~nonexistent-user</computeroutput>
	      </screen>
	      </para>

	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~+</token></term>
	  <listitem><formalpara><title>当前工作目录</title>
	      <para>相当于<link
	        linkend="pwdref">$PWD</link>内部变量. </para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~-</token></term>
	  <listitem><formalpara><title>先前的工作目录</title>
	      <para>相当于<link
	        linkend="oldpwd">$OLDPWD</link>内部变量. </para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>=~</token></term>
	  <listitem><formalpara><title><link linkend="regexmatchref">正则表达式匹配</link></title>
	      <para>这个操作将会在<link
	        linkend="bash3ref">version 3</link>版本的Bash部分进行讲解. </para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry><term><token>^</token></term>
	  <indexterm>
	    <primary>^</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>^</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>regular expression</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>beginning of line</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title>行首</title>
	      <para>在<link linkend="regexref">正则表达式</link>中, 
	        <quote>^</quote>表示定位到文本行的行首. </para>
	    </formalpara>

	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term>控制字符</term>
	  <listitem>
	  <para><anchor id="controlcharref"></para>
	  <formalpara><title>修改终端或文本显示的行为. </title>

	    <para>控制字符以<keycap>CONTROL</keycap>
	      + <keycap>key</keycap>这种方式进行组合(同时按下). 
	      
	      控制字符也可以使用<firstterm>8进制</firstterm>或<firstterm>16进制</firstterm>表示法来进行表示, 
	      但是前边必须要加上<firstterm>转义符</firstterm>. </para>
	  </formalpara>
	  <para>控制字符在脚本中不能正常使用. </para>


	    <itemizedlist id="ctlchar">

	      <listitem>
	        <para><userinput>Ctl-B</userinput></para>
		<para>退格(非破坏性的), 就是退格但是不删掉前面的字符.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-C</userinput></para>
		<para>break. 终结一个前台作业.</para>
	      </listitem>

	      <listitem>

	        <para><anchor id="ctldref"></para>
	        <para><userinput>Ctl-D</userinput></para>
		<para>从一个shell中登出(与<link linkend="exitcommandref">exit</link>很相像). </para>
		<para><quote>EOF</quote>(文件结束). 
			这也能从<filename>stdin</filename>中终止输入. </para>
                <para>在console或者在<firstterm>xterm</firstterm>窗口中输入的时候, 
					<userinput>Ctl-D</userinput>将删除光标下字符. 
					当没有字符时, <userinput>Ctl-D</userinput>将退出当前会话, 
		  在一个xterm窗口中, 则会产生关闭此窗口的效果. </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-G</userinput></para>
		<para><quote>哔</quote> (beep). 在一些老式的打字机终端上, 它会响一下铃. </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-H</userinput></para>
		<para><quote>退格</quote>(破坏性的), 就是在退格之后, 还要删掉前边的字符. </para>
		<para>
		<programlisting>#!/bin/bash
# Embedding Ctl-H in a string.

a="^H^H"                  # 两个 Ctl-H's (backspaces).
echo "abcdef"             # abcdef
echo -n "abcdef$a "       # abcd f
#  Space at end  ^              ^ 两次退格.
echo -n "abcdef$a"        # abcdef
#  结尾没有空格                   没有 backspace 的效果了(why?).
                          # 结果并不像期望的那样.
echo; echo</programlisting>
                </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-I</userinput></para>
		<para>水平制表符.</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-J</userinput></para>
			<para>重起一行(换一行并到行首). 在脚本中, 也可以使用8进制表示法 
				-- '\012' 或者16进制表示法 -- '\x0a' 来表示. </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-K</userinput></para>
		<para>垂直制表符.</para>
                <para>当在console或者<emphasis>xterm</emphasis>窗口中输入文本时, 
					<userinput>Ctl-K</userinput>将会删除从光标所在处到行为的全部字符. 
					在脚本中, <userinput>Ctl-K</userinput>的行为有些不同, 
		  具体请参见下边的Lee Maschmeyer的例子程序. </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-L</userinput></para>
		<para>清屏(清除终端的屏幕显示). 在终端中,
			与<link linkend="clearref">clear</link>命令的效果相同. 
			当发送到打印机上时, <userinput>Ctl-L</userinput>会让打印机将打印纸卷到最后. </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-M</userinput></para>
		<para>回车.</para>
		<para>
		<programlisting>#!/bin/bash
# Thank you, Lee Maschmeyer, for this example.

read -n 1 -s -p $'Control-M leaves cursor at beginning of this line. Press Enter. \x0d'
                                  # 当然, '0d'就是二进制的回车. 
echo >&2   #  '-s'参数使得任何输入都不将回显出来.
           #+ 所以, 明确的重起一行是必要的.

read -n 1 -s -p $'Control-J leaves cursor on next line. \x0a'
           #  '0a' 等价于Control-J, 换行.
echo >&2

###

read -n 1 -s -p $'And Control-K\x0bgoes straight down.'
echo >&2   #  Control-K 是垂直制表符.

# 关于垂直制表符效果的一个更好的例子见下边:

var=$'\x0aThis is the bottom line\x0bThis is the top line\x0a'
echo "$var"
#  这句与上边的例子使用的是同样的办法, 然而:
echo "$var" | col
#  这将造成垂直制表符右边的部分比左边部分高. 
#  这也解释了为什么我们要在行首和行尾加上一个换行符 --
#+ 这样可以避免屏幕显示混乱. 

# Lee Maschmeyer的解释:
# --------------------------
#  在这里[第一个垂直制表符的例子中] . . . 
#+ 这个垂直制表符使得还没回车就直接打印下来. 
#  这只能在那些不能"后退"的设备中才行, 
#+ 比如说Linux的console. 
#  垂直制表符的真正意义是向上移, 而不是向下. 
#  它可以用来让打印机打印上标. 
#  col工具可以模拟垂直制表符的正确行为. 

exit 0</programlisting>
		</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-Q</userinput></para>
		<para>恢复(XON).</para>
		<para>在一个终端中恢复<filename>stdin</filename>. </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-S</userinput></para>
		<para>挂起(XOFF).</para>
		<para>在一个终端中冻结<filename>stdin</filename>. 
		  (使用Ctl-Q可以恢复输入.)</para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-U</userinput></para>
		<para>删除光标到行首的所有字符. 
			在某些设置下, 
			<emphasis>不管光标的所在位置</emphasis><userinput>Ctl-U</userinput>都将删除整行输入. </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-V</userinput></para>
			<para>当输入字符时, <userinput>Ctl-V</userinput>允许插入控制字符. 
				比如, 下边的两个例子是等价的: 
		    <programlisting>echo -e '\x0a'
echo &lt;Ctl-V&gt;&lt;Ctl-J&gt;</programlisting></para>
                <para><userinput>Ctl-V</userinput>主要用于文本编辑. </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-W</userinput></para>
                <para>当在控制台或一个xterm窗口敲入文本时,
		  <userinput>Ctl-W</userinput>将会删除当前光标到左边最近一个空格间的全部字符. 
		  在某些设置下, 
		  <userinput>Ctl-W</userinput>将会删除当前光标到左边第一个非字母或数字之间的全部字符. </para>
	      </listitem>

	      <listitem>
	        <para><userinput>Ctl-Z</userinput></para>
		<para>暂停前台作业.</para>
	      </listitem>

	    </itemizedlist>



	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>空白</term>
	  <listitem>
	  <para><anchor id="whitespaceref"></para>
	  <formalpara><title>用来分隔函数, 命令或变量. </title>
	      <para>空白包含<firstterm>空格</firstterm>,
			  <firstterm>tab</firstterm>, 
			  <firstterm>空行</firstterm>, 或者是它们之间任意的组合体.

		  <footnote><para>一个换行符(<quote>重起一行</quote>)也被认为是空白符. 
			这也就解释了为什么一个只包含换行符的<emphasis>空行</emphasis>也被认为是空白. </para></footnote>

	在某些上下文中, 
	比如<link linkend="wsbad">变量赋值</link>, 
	空白是不被允许的, 会产生语法错误. </para>
	    </formalpara>

	  <para>空行不会影响脚本的行为, 因此使用空行可以很好的划分独立的函数段以增加可读性. </para>

	  <para>特殊变量<link linkend="ifsref">$IFS</link>用来做一些输入命令的分隔符, 默认情况下是空白. </para>

	  <para>如果想在字符串或变量中使用空白, 
		  那么应该使用<link linkend="quotingref">引用</link>.</para>

	  </listitem>
	</varlistentry>


      </variablelist>

  </chapter> <!-- Special characters used in shell scripts -->



  <chapter id="variables">
      <title>变量和参数的介绍</title>

      <para><firstterm>变量</firstterm>是脚本编程中进行数据表现的一种方法. 
		  说白了, 变量不过是计算机为了保留数据项, 
		  而在内存中分配的一个位置或一组位置的<emphasis>标识</emphasis>或名字. </para>

      <para>变量既可以出现在算术操作中, 也可以出现在字符串分析过程中. </para>


     <sect1 id="varsubn">
        <title>变量替换</title>

		<para>变量的<emphasis>名字</emphasis>就是变量保存<emphasis>值</emphasis>的地方. 
        引用变量的值就叫做<emphasis>变量替换</emphasis>. </para>

      <variablelist id="dollarsign">

	<varlistentry>
	  <term><token>$</token></term> <indexterm>
	    <primary>$</primary>
	  </indexterm> <indexterm>
	    <primary>variable</primary> <secondary>$</secondary>
	  </indexterm> <indexterm>
	    <primary>variable</primary>
	    <secondary>substitution</secondary>
	  </indexterm>

	  <listitem>

		  <para>让我们仔细的区别变量的<emphasis>名字</emphasis>和变量的<emphasis>值</emphasis>. 
			  如果<userinput>variable1</userinput>是一个变量的名字, 
			  那么<userinput>$variable1</userinput>就是引用这变量的<emphasis>值</emphasis>,
			  即这边变量所包含的数据. </para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>variable=23</userinput>


<prompt>bash$ </prompt><userinput>echo variable</userinput>
<computeroutput>variable</computeroutput>

<prompt>bash$ </prompt><userinput>echo $variable</userinput>
<computeroutput>23</computeroutput></screen>	      
	      </para>
		
		
              <para>当变量<quote>裸体</quote>出现的时候
				  -- 也就是说没有<token>$</token>前缀的时候 
				  -- 那么变量可能存在如下几种情况.
		变量被声明或被赋值, 变量被<emphasis>unset</emphasis>, 
		变量被<link linkend="exportref">exporte</link>,
		或者是变量处在一种特殊的情况 -- 
		变量代表一种<link linkend="signald">信号</link>(参见 <xref linkend="ex76">). 
		变量赋值可以使用<token>=</token>(比如 <emphasis>var1=27</emphasis>), 
		也可以在<link linkend="readref">read</link>命令中或者循环头进行赋值
		(<emphasis>for var2 in 1 2 3</emphasis>).</para>


	    <para><anchor id="dblquo">被一对<firstterm>双引号</firstterm>(<token>" "</token>)括起来的变量替换是不会被阻止的.
			所以双引号被称为<firstterm>部分引用</firstterm>, 
			有时候又被称为<quote>弱引用</quote>. 
			<anchor id="snglquo">但是如果使用单引号的话(<token>' '</token>), 
			那么变量替换就会被禁止了, 变量名只会被解释成字面的意思, 不会发生变量替换. 
			所以单引号被称为<firstterm>全引用</firstterm>, 有时候也被称为<quote>强引用</quote>. 
			详细讨论参见<xref linkend="quoting">. </para>

			<para>注意<userinput>$variable</userinput>事实上只是<userinput>${variable}</userinput>的简写形式. 
				在某些上下文中<userinput>$variable</userinput>可能会引起错误, 
				这时候你就需要用<userinput>${variable}</userinput>了(参见下边的<xref
	      linkend="Parameter-Substitution">). </para>

	    <example id="ex9">
	      <title>变量赋值和替换</title>
	      <programlisting>&ex9;</programlisting>
	    </example>

	    <caution>

			<para>一个未初始化的变量将会是<quote>null</quote>值 
				- 就是未赋值(但并不是代表值是0!). 
			   	在给变量赋值之前就使用这个变量通常都会引起问题. </para>

	    <para>但是在执行算术操作的时候, 仍然有可能使用未初始化过的变量. 

	        <programlisting>echo "$uninitialized"                                # (blank line)
let "uninitialized += 5"                             # Add 5 to it.
echo "$uninitialized"                                # 5

#  结论:
#  一个未初始化的变量是没有值的, 
#+ 但是在做算术操作的时候, 这个未初始化的变量看起来值为0. 
#  这是一个未文档化(并且可能不具可移植性)的行为. </programlisting>

              参见<xref linkend="selfsource">.</para>

	      </caution>

	  </listitem>
	</varlistentry>
      </variablelist>
    </sect1> <!-- Variable Substitution -->  


    <sect1 id="varassignment">
      <title>变量赋值</title>

      <variablelist>
	<varlistentry>
	  <term><anchor id="eqref"><token>=</token></term>
	  <indexterm>
	    <primary>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>assignment</secondary>
	  </indexterm>
	  <listitem><para>赋值操作(<emphasis>前后都不能有空白</emphasis>)</para>


	    <caution>
	    <para>因为<link linkend="equalsignref">=</link>和<link
				linkend="equalref">-eq</link>都可以用做条件测试操作, 
			所以不要与这里的赋值操作相混淆. </para>

		<para>注意: <token>=</token>既可以用做条件测试操作, 
		   也可以用于赋值操作, 这需要视具体的上下文而定. </para>
	    </caution>


	<example id="ex15">
	  <title>简单的变量赋值</title>
	  <programlisting>&ex15;</programlisting>
	</example>

	<example id="ex16">
	  <title>简单和复杂, 两种类型的变量赋值</title>
	  <programlisting>&ex16;</programlisting>
	</example>

	    <para>使用<firstterm>$(...)</firstterm>机制来进行变量赋值(这是一种比<link
				linkend="backquotesref">后置引用(反引号`)</link>更新的一种方法). 
			事实上这两种方法都是<link 
				linkend="commandsubref">命令替换</link>的一种形式.</para>

	    <para><programlisting># From /etc/rc.d/rc.local
R=$(cat /etc/redhat-release)
arch=$(uname -m)</programlisting></para>
	  </listitem>
	</varlistentry>
      </variablelist>

    </sect1> <!-- Variable Assignment -->

    <sect1 id="untyped">
      <title>Bash变量是不区分类型的</title>
      
      <para><anchor id="bvuntyped"></para>
		  <para>不像其他程序语言一样, Bash并不对变量区分<quote>类型</quote>. 
		本质上, Bash变量都是字符串.
		但是依赖于具体的上下文, Bash也允许比较操作和整数操作.
		其中的关键因素就是, 变量中的值是否只有数字. </para>

	    <example id="intorstring">
	      <title>整型还是字符串?</title>
	      <programlisting>&intorstring;</programlisting>
	    </example>	    

		<para>不区分变量的类型既是幸运的事情也是悲惨的事情. 
			它允许你在编写脚本的时候更加的灵活(但是也足够把你搞晕!), 
			并且可以让你能够更容易的编写代码.
			然而, 这也很容易产生错误, 并且让你养成糟糕的编程习惯.</para>

      <para>这样的话, 程序员就承担了区分脚本中变量类型的责任. 
        Bash是不会为你区分变量类型的. </para>
    
    </sect1> <!-- Bash Variables Are Untyped-->


    <sect1 id="othertypesv">
      <title>特殊的变量类型</title>

      <variablelist>

	<varlistentry>
	  <term><replaceable>局部变量</replaceable></term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>local</secondary>
	  </indexterm>

	  <listitem><para>这种变量只有在<link
				  linkend="codeblockref">代码块</link>或者函数中(参见<link 
				  linkend="functionref">函数</link>中的<link 
				  linkend="localref">局部变量</link>)才可见. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="envref"><replaceable>环境变量</replaceable></term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>environmental</secondary>
	  </indexterm>
	  <listitem>

	  <para>这种变量将影响用户接口和shell的行为</para>

	      <note>

			  <para>在通常情况下, 每个进程都有自己的<quote>环境</quote>, 
				  这个环境是由一组变量组成的, 这些变量中存有进程可能需要引用的信息.
		在这种情况下, shell与一个一般的进程没什么区别. </para>

	      <para>每次当一个shell启动时, 它都将创建适合于自己环境变量的shell变量.
			  更新或者添加一个新的环境变量的话, 这个shell都会立刻更新它自己的环境(译者注: 换句话说, 更改或增加的变量会立即生效), 
			  并且所有的shell子进程(即这个shell所执行的命令)都会继承这个环境.
			  (译者注: 准确地说, 应该是后继生成的子进程才会继承Shell的新环境变量, 已经运行的子进程并不会得到它的新环境变量). </para>

	      </note>

	      <caution>
	      <para>分配给环境变量的空间是有限的.
	        创建太多环境变量, 或者给一个环境变量分配太多的空间都会引起错误. </para>
	      <para>
	          <screen>
<prompt>bash$ </prompt><userinput>eval "`seq 10000 | sed -e 's/.*/export var&=ZZZZZZZZZZZZZZ/'`"</userinput>

<prompt>bash$ </prompt><userinput>du</userinput>
<computeroutput>bash: /usr/bin/du: Argument list too long</computeroutput>
	          </screen>
	      </para>
	      <para>(感谢 Stephane Chazelas 对这个问题的澄清, 
	        并且提供了上边的例子程序.)</para>
	      </caution>

		  <para>如果一个脚本要设置一个环境变量, 
			  那么需要将这些变量<quote>export</quote>出来, 
			  也就是需要通知到脚本本地的环境. 
	      这是<link linkend="exportref">export</link>命令的功能. </para>

            <anchor id="childref">
	    <note><para>一个脚本只能够<command>export</command>变量到这个脚本所产生的子进程, 
	      也就是说只能够对这个脚本所产生的命令和进程起作用.
		  如果脚本是从命令行中调用的, 
		  那么这个脚本所export的变量是<replaceable>不能</replaceable>影响命令行环境的. 
		  也就是说, 
		  <emphasis><link
	      linkend="forkref">子进程</link>是不能够export变量来影响产生自己的父进程的环境的. </emphasis></para></note>

	      <para>---</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="posparamref1"><replaceable>位置参数</replaceable></term>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	  </indexterm>
	  <listitem>
	    <para>从命令行传递到脚本的参数: <varname>$0</varname>, <varname>$1</varname>,
	      <varname>$2</varname>, <varname>$3</varname> . . .</para>
	      
	    <para><varname>$0</varname>就是脚本文件自身的名字, 
	      <varname>$1</varname> 是第一个参数,
		  <varname>$2</varname>是第二个参数, 
		  <varname>$3</varname>是第三个参数, 然后是第四个.

		  <footnote><para><varname>$0</varname>参数是由调用这个脚本的进程所设置的. 
				  按照约定, 这个参数一般就是脚本的名字. 
				  具体请参考<command>execv</command>的man页.</para></footnote>

	      <anchor id="bracketnotation">
	      <varname>$9</varname>之后的位置参数就必须用大括号括起来了, 
	      比如, <varname>${10}</varname>,
	      <varname>${11}</varname>, <varname>${12}</varname>. </para>

	    <para>两个比较特殊的变量<link linkend="appref">$*和$@</link>
	      表示<emphasis>所有的</emphasis>位置参数. </para>

	    <example id="ex17">
	      <title>位置参数</title>
	      <programlisting>&ex17;</programlisting>
	    </example>

		<para><firstterm>{}标记法</firstterm>提供了一种提取从命令行传递到脚本的<emphasis>最后</emphasis>一个位置参数的简单办法.
	      但是这种方法同时还需要使用<link
	      linkend="varrefnew">间接引用</link>.</para>

	    <para><programlisting>args=$#           # 位置参数的个数.
lastarg=${!args}
# 或:       lastarg=${!#}
#           (感谢, Chris Monson.)
# 注意, 不能直接使用 lastarg=${!$#} , 这会产生错误.
</programlisting></para>


<para>一些脚本可能会依赖于使用不同的调用名字, 来表现出不同的行为. 
	如果想要达到这种目的, 一般都需要在脚本中检查<varname>$0</varname>.
	      因为脚本只能够有一个真正的文件名, 如果要产生多个名字, 必须使用符号链接.
	      参见<xref linkend="hellol">. </para>

		  <tip><para>如果脚本需要一个命令行参数, 而在调用的时候, 这个参数没被提供, 
				  那么这就可能造成给这个参数赋一个null变量, 通常情况下, 这都会产生问题.
				  一种解决这个问题的办法就是使用添加额外字符的方法, 
				  在使用这个位置参数的变量和位置参数本身的后边全部添加同样的额外字符.
	      </para></tip>

	      <programlisting>variable1_=$1_  # 而不是 variable1=$1
# 这将阻止报错, 即使在调用时没提供这个位置参数.

critical_argument01=$variable1_

# 这个扩展的字符是可以被消除掉的, 就像这样.
variable1=${variable1_/_/}
# 副作用就是$variable1_多了一个下划线.
# 这里使用了参数替换模版的一种形式(后边会有具体的讨论).
# (在一个删除动作中, 节省了一个替换模式.)

#  处理这个问题的一个更简单的办法就是
#+ 判断一下这个位置参数是否传递下来了. 
if [ -z $1 ]
then
  exit $E_MISSING_POS_PARAM
fi


#  然而, 象Fabian Kreutz所指出的那样,
#+ 上边的方法将可能产生一个意外的副作用.
#  参数替换才是更好的方法:
#         ${1:-$DefaultVal}
#  具体参见"参数替换"的相关章节
#+ 在"变量重游"那章.
</programlisting>

	      <para>---</para>

	    <example id="ex18">
	      <title><command>wh</command>, <link
	        linkend="whoisref">whois</link>节点名字查询</title>
	      <programlisting>&ex18;</programlisting>
	    </example>

	      <para>---</para>

	    <para><anchor id="shiftref"></para>
	    <para>
	      <indexterm>
		<primary>shift</primary>
	      </indexterm>
	      <indexterm>
		<primary>command</primary>
		<secondary>shift</secondary>
	      </indexterm>
	      <command>shift</command>命令会重新分配位置参数, 
	      其实就是把所有的位置参数都向左移动一个位置. </para>
	      
	    <para><varname>$1</varname> <--- <varname>$2</varname>, <varname>$2</varname> <--- <varname>$3</varname>, <varname>$3</varname> <--- <varname>$4</varname>, 等等.</para>

		<para>原来的<varname>$1</varname>就消失了, 
			但是<emphasis><varname>$0</varname> (脚本名)是不会改变的</emphasis>. 
			如果传递了大量的位置参数到脚本中, 那么<command>shift</command>命令允许你访问的位置参数的数量超过<literal>10</literal>个,
	      当然<link linkend="bracketnotation">{}标记法</link>也提供了这样的功能. </para>

	    <example id="ex19">
	      <title>使用<command>shift</command>命令</title>
	      <programlisting>&ex19;</programlisting>
	    </example>

          <note><para>在将参数传递到<link
					  linkend="functionref">函数</link>中的时候, 
				 <command>shift</command>命令的工作方式也差不多. 
	    参考<xref linkend="multiplication">. </para></note>

	  </listitem>
	</varlistentry>
      </variablelist>

    </sect1> <!-- Special Variable Types -->  


  </chapter> <!-- Variables -->



  <chapter id="quoting">
    <title>引用</title>
    
      <para><anchor id="quotingref"></para>

      <indexterm>
	<primary>"</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>"</secondary>
      </indexterm>
      <indexterm>
	<primary>'</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>'</secondary>
      </indexterm>
      <indexterm>
	<primary>quote</primary>
      </indexterm>
      <indexterm>
	<primary>\</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>\</secondary>
      </indexterm>
      <indexterm>
	<primary>escape</primary>
      </indexterm>
	  <para>引用的字面意思就是将字符串用双引号括起来. 
		  它的作用就是保护字符串中的<link 
		  linkend="scharlist1">特殊字符</link>不被shell或者shell脚本重新解释, 或者扩展. 
	  (我们这里所说的<quote>特殊</quote>指的是一些字符在shell中具有的特殊意义, 
	 而不是字符的字面意思, 比如<token>通配符</token> --
      <token>*</token>.)</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>ls -l [Vv]*</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
 -rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
 -rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh
</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l '[Vv]*'</userinput>
<computeroutput>ls: [Vv]*: No such file or directory</computeroutput></screen>	      
	      </para>

		  <sidebar><para>在日常的演讲和写作中, 
			当我们<quote>引用</quote>一个短语的时候, 
			这意味着这个短语被区分以示它有特别的含义.
			但是在Bash脚本中, 当我们<firstterm>引用</firstterm>一个字符串的时候, 
			我们区分这个字符串是为了保护它的<emphasis>字面</emphasis>含义. </para></sidebar>

      <para>某些程序和工具能够重新解释或者扩展被引用的特殊字符. 
		  引用的一个重要作用就是保护命令行参数不被shell解释, 
		  但是还是能够让正在调用的程序来扩展它. </para>

              <para>
	      <screen><prompt>bash$ </prompt><userinput>grep '[Ff]irst' *.txt</userinput>
<computeroutput>file1.txt:This is the first line of file1.txt.
 file2.txt:This is the First line of file2.txt.</computeroutput></screen>
	      </para>

	<para>注意一下未引用的 <userinput>grep [Ff]irst *.txt</userinput>
	  在Bash shell下的行为.
	    <footnote><para>除非正好当前工作目录下有一个名字为
				<filename>first</filename>的文件. 
				然而这是<emphasis>引用的</emphasis>另一个原因. 
				(感谢, Harald Koenig, 指出这一点. </para></footnote>
	  </para>


      <para>引用还可以改掉<link linkend="echoref">echo's</link>不换行的<quote>毛病</quote>. </para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>echo $(ls -l)</userinput>
<computeroutput>total 8 -rw-rw-r-- 1 bozo bozo 130 Aug 21 12:57 t222.sh -rw-rw-r-- 1 bozo bozo 78 Aug 21 12:57 t71.sh</computeroutput>


<prompt>bash$ </prompt><userinput>echo "$(ls -l)"</userinput>
<computeroutput>total 8
 -rw-rw-r--  1 bozo bozo 130 Aug 21 12:57 t222.sh
 -rw-rw-r--  1 bozo bozo  78 Aug 21 12:57 t71.sh</computeroutput></screen>
	      </para>


      <sect1 id="quotingvar">
	<title>引用变量</title>


      <para>在一个双引号中通过直接使用变量名的方法来引用变量, 一般情况下都是没问题的. 
	这么做将阻止所有在引号中的特殊字符被重新解释 -- 包括变量名
	    <footnote><para>即使是变量的<firstterm>值</firstterm>也会有副作用的(见下边)</para></footnote>
		-- 但是<token>$</token>,<token>`</token>(后置引用), 
		和<token>\</token>(转义符)除外.

	    <footnote>

			<para><emphasis>当在命令行中使用时</emphasis>, 如果在双引号中包含<quote>!</quote>的话, 
	      那么会产生一个错误(译者注: 比如, echo "hello!"). 这是因为感叹号被解释成<link
	      linkend="histcommands">历史命令</link>了. 但是如果在脚本中,
	      就不会存在这个问题, 因为在脚本中Bash历史机制是被禁用的. </para>

	    <para>在双引号中使用<quote>\</quote>也可能会出现一些不一致的行为. 

	      <screen>
<prompt>bash$ </prompt><userinput>echo hello\!</userinput>
<computeroutput>hello!</computeroutput>


<prompt>bash$ </prompt><userinput>echo "hello\!"</userinput>
<computeroutput>hello\!</computeroutput>




<prompt>bash$ </prompt><userinput>echo -e x\ty</userinput>
<computeroutput>xty</computeroutput>


<prompt>bash$ </prompt><userinput>echo -e "x\ty"</userinput>
<computeroutput>x       y</computeroutput>
	      </screen>

              (感谢, Wayne Pollock, 指出这个问题.)
            </para>
	      
	      </footnote>
	
		  保留<token>$</token>作为特殊字符的意义是为了能够在双引号中也能够正常的引用变量(<replaceable>"$variable"</replaceable>), 
		  也就是说, 这个变量将被它的值所取代(参见上边的<xref linkend="ex9">).</para>

      <para>使用双引号还能够阻止单词分割(word splitting).
		  <footnote><para><quote>单词分割(Word splitting)</quote>, 在这种上下文中, 
			意味着将一个字符串分隔成一些不连续的, 分离的参数. </para></footnote>
	如果一个参数被双引号扩起来的话, 那么这个参数将认为是一个单元, 
	即使这个参数包含有<link linkend="whitespaceref">空白</link>, 那里面的单词也不会被分隔开. 

	<programlisting>variable1="a variable containing five words"
COMMAND This is $variable1    # 用下面7个参数执行COMMAND命令: 
# "This" "is" "a" "variable" "containing" "five" "words"

COMMAND "This is $variable1"  # 用下面1个参数执行COMMAND命令:
# "This is a variable containing five words"


variable2=""    # Empty.

COMMAND $variable2 $variable2 $variable2        # COMMAND将不带参数执行. 
COMMAND "$variable2" "$variable2" "$variable2"  # COMMAND将以3个空参数来执行. 
COMMAND "$variable2 $variable2 $variable2"      # COMMAND将以1个参数来执行(2空格). 

# 感谢, Stephane Chazelas.
</programlisting></para>


<tip><para>在<command>echo</command>语句中, 
		只有在单词分割(word splitting)或者需要保留<link linkend="whitespaceref">空白</link>的时候, 
		才需要把参数用双引号括起来. </para></tip>

	    <example id="weirdvars">
	      <title>echo出一些诡异变量</title>
	      <programlisting>&weirdvars;</programlisting>
	    </example>

      <para>单引号(<token>' '</token>)操作与双引号基本一样, 
		  但是不允许引用变量, 
		  因为<token>$</token>的特殊意义被关闭了.
		  在单引号中, <emphasis>任何</emphasis>特殊字符都按照字面的意思进行解释, 
		 除了<token>'</token>. 
	所以说单引号(<quote>全引用</quote>)是一种比双引号(<quote>部分引用</quote>)更严格的引用方法. </para>

      <note><para>因为即使是转义符(<token>\</token>)在单引号中也是按照字面意思解释的,
	所以如果想在一对单引号中显示一个单引号是不行的(译者注: 因为单引号对是按照就近原则完成的).
	<programlisting>echo "Why can't I write 's between single quotes"

echo

# 一种绕弯的方法.
echo 'Why can'\''t I write '"'"'s between single quotes'
#    |-------|  |----------|   |-----------------------|
# 三个被单引号引用的字符串, 在这三个字符串之间有一个用转义符转义的单引号, 和一个用双引号括起来的单引号.

# 这个例子由Stephane Chazelas所捐赠.</programlisting>
      </para></note>

      </sect1> <!-- Quoting Variables -->



      <sect1 id="escapingsection">
	<title>转义</title>

      <para><anchor id="escp"><firstterm>转义</firstterm>是一种引用单个字符的方法. 
	一个前面放上<token>转义符</token>
	(<token>\</token>)的字符就是告诉shell这个字符按照字面的意思进行解释, 
   换句话说, 就是这个字符失去了它的特殊含义. </para>

      <caution><para>在某些特定的命令和工具中, 比如<link
	linkend="echoref">echo</link>和<link
	linkend="sedref">sed</link>, 转义符往往会起到相反效果
	- 它反倒可能会引发出这个字符的特殊含义. </para></caution>

      <variablelist id="specialmeanings">
	<title><anchor id="spm">特定的转义符的特殊的含义</title>

	<varlistentry>
	<term><command>echo</command>和<command>sed</command>命令中使用</term>
	<listitem><para></para></listitem>
	</varlistentry>

	<varlistentry><term><token>\n</token></term>
	  <indexterm>
	    <primary>\n</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\n</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>newline</primary>
	  </indexterm>
	  <listitem><para>表示新的一行</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\r</token></term>
	  <indexterm>
	    <primary>\r</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\r</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>carriage return</primary>
	  </indexterm>
	  <listitem><para>表示回车</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\t</token></term>
	  <indexterm>
	    <primary>\t</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\t</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tabulation</primary>
	  </indexterm>
	  <listitem><para>表示水平制表符</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\v</token></term>
	  <indexterm>
	    <primary>\v</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\v</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>vertical tabulation</primary>
	  </indexterm>
	  <listitem><para>表示垂直制表符</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\b</token></term>
	  <indexterm>
	    <primary>\b</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\b</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>backspace</primary>
	  </indexterm>
	<listitem><para>表示后退符</para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\a</token></term>
	  <indexterm>
	    <primary>\a</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\a</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>alert</primary>
	  </indexterm>
	  <indexterm>
	    <primary>beep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>flash</primary>
	  </indexterm>
	<listitem><para>表示<quote>alert</quote>(蜂鸣或者闪烁)</para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\0xx</token></term>
	  <indexterm>
	    <primary>\0xx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\0xx</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>octal ASCII</primary>
	  </indexterm>
	  <listitem><para>转换为八进制的ASCII码, 等价于<replaceable>0xx</replaceable></para>
	      
      <example id="escaped">
	<title>转义符</title>
	<programlisting>&escaped;</programlisting>
      </example>

	  <para>参考<xref linkend="ex77">, 
			  这是关于<userinput>$'   '</userinput>字符串扩展结构的一个例子. </para>

	</listitem>
	</varlistentry>

	<varlistentry><term><token>\"</token></term>
	  <indexterm>
	    <primary>\"</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\"</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>quote</primary>
	  </indexterm>
	<listitem><para>表示引号字面的意思</para>
	<para><programlisting>echo "Hello"                  # Hello
echo "\"Hello\", he said."    # "Hello", he said.</programlisting></para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\$</token></term>
	  <indexterm>
	    <primary>\$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dollar</primary>
	  </indexterm>
	  <listitem><para>表示$本身子面的含义(跟在<token>\$</token>后边的变量名将不能引用变量的值)</para>
	    <para><programlisting>echo "\$variable01"  # 结果是$variable01</programlisting></para>
	  </listitem>
	  </varlistentry>

	<varlistentry><term><token>\\</token></term>
	  <indexterm>
	    <primary>\\</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\\</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>double backslash</primary>
	  </indexterm>
	  <listitem><para>表示反斜线字面的意思</para>
	    <para><programlisting>echo "\\"  # 结果是\

# 反之 . . .

echo "\"   # 如果从命令行调用的话, 会出现SP2, 也就是2级提示符(译者注: 提示你命令不全, 在添加一个"就好了.
           # 如果在脚本中调用的话, 那么会报错. </programlisting></para>
	  </listitem>
	  </varlistentry>
	</variablelist>

      <note>
		  <para><token>\</token>的行为依赖于它自身是否被转义, 被引用(""), 
	或者是否出现在<link
	linkend="commandsubref">命令替换</link>或<link
	linkend="heredocref">here document</link>中.

	<programlisting>                      #  简单的转义和引用
echo \z               #  z
echo \\z              # \z
echo '\z'             # \z
echo '\\z'            # \\z
echo "\z"             # \z
echo "\\z"            # \z

                      #  命令替换
echo `echo \z`        #  z
echo `echo \\z`       #  z
echo `echo \\\z`      # \z
echo `echo \\\\z`     # \z
echo `echo \\\\\\z`   # \z
echo `echo \\\\\\\z`  # \\z
echo `echo "\z"`      # \z
echo `echo "\\z"`     # \z

                      # Here document
cat &lt;&lt;EOF              
\z                      
EOF                   # \z

cat &lt;&lt;EOF              
\\z                     
EOF                   # \z

# 这些例子是由Stephane Chazelas所提供的.</programlisting>
      </para>

	  <para>赋值给变量的字符串的元素也会被转义, 但是不能把一个单独的转义符赋值给变量.
	<programlisting>variable=\
echo "$variable"
# 不能正常运行 - 会报错:
# test.sh: : command not found
# 一个"裸体的"转义符是不能够安全的赋值给变量的.
#
#  事实上在这里"\"转义了一个换行符(变成了续航符的含义), 
#+ 效果就是				variable=echo "$variable"
#+                      不可用的变量赋值

variable=\
23skidoo
echo "$variable"        #  23skidoo
                        #  这句是可以的, 因为
                        #+ 第2行是一个可用的变量赋值.

variable=\ 
#        \^    转义一个空格
echo "$variable"        # 显示空格

variable=\\
echo "$variable"        # \

variable=\\\
echo "$variable"
# 不能正常运行 - 报错:
# test.sh: \: command not found
#
#  第一个转义符把第2个\转义了,但是第3个又变成"裸体的"了,
#+ 与上边的例子的原因相同.

variable=\\\\
echo "$variable"        # \\
                        # 第2和第4个反斜线被转义了.
                        # 这是正确的. </programlisting>
      </para>
      
      </note>   



	  <para>转义一个空格会阻止命令行参数列表的<quote>单词分割</quote>问题.
        <programlisting>file_list="/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"
# 列出的文件都作为命令的参数.

# 加两个文件到参数列表中, 列出所有的文件信息.
ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list

echo "-------------------------------------------------------------------------"

# 如果我们将上边的两个空个转义了会产生什么效果?
ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
# 错误: 因为前3个路径被合并成一个参数传递给了'ls -l'
#       而且两个经过转义的空格组织了参数(单词)分割. </programlisting>
</para>


      <para> <token>转义符</token>也提供续行功能, 也就是编写多行命令的功能. 
	一般的, 每一个单独行都包含一个不同的命令, 
	但是每行结尾的<token>转义符</token>都会<emphasis>转义换行符</emphasis>,
	这样下一行会与上一行一起形成一个命令序列. </para>
      <para><programlisting>(cd /source/directory && tar cf - . ) | \
(cd /dest/directory && tar xpvf -)
# 重复Alan Cox的目录数拷贝命令,
# 但是分成两行是为了增加可读性.

# 也可以使用如下方式:
tar cf - -C /source/directory . |
tar xpvf - -C /dest/directory
# 察看下边的注意事项.
# (感谢, Stephane Chazelas.)</programlisting>
        
	<note><para>如果一个脚本以<token>|</token>结束, 管道符, 
			那么就不用非的加上转义符<token>\</token>了. 
			但是一个好的编程风格, 还是应该在行尾加上转义符. </para></note></para>

	<para><programlisting>echo "foo
bar" 
#foo
#bar

echo

echo 'foo
bar'    # 没什么区别.
#foo
#bar

echo

echo foo\
bar     # 换行符被转义.
#foobar

echo

echo "foo\
bar"     # 与上边一样, \在部分引用中还是被解释为续行符. 
#foobar

echo

echo 'foo\
bar'     # 由于是全引用, 所以\没有被解释成续行符. 
#foo\
#bar

# 由Stephane Chazelas所建议的用例.</programlisting></para>

      </sect1> <!-- Escaping -->


  </chapter> <!-- Quoting -->


  <chapter id="exit-status">
    <title>退出和退出状态码</title>

    <epigraph>
      <attribution>Chet Ramey</attribution>
      <para>...在Bourne shell中有许多黑暗的角落, 但是人们也会利用它们. </para>
    </epigraph>
    
      <para><anchor id="exitcommandref"> 
	<command>
	  <indexterm>
	    <primary>exit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exit</secondary>
	  </indexterm>
	  exit
	</command> 
	被用来结束一个脚本, 
	就像在<emphasis>C</emphasis>语言中一样. 它也返回一个值, 
	并且这个值会传递给脚本的父进程, 父进程会使用这个值做下一步的处理. </para>


      <para><anchor id="exitstatusref">每个命令都会返回一个
	<firstterm>
	  <indexterm>
	    <primary>exit status</primary>
	  </indexterm>
	  退出状态码
	</firstterm> 
	(有时候也被称为
	<firstterm>
	  <indexterm>
	    <primary>return status</primary>
	  </indexterm>
	  返回状态
  </firstterm>). 成功的命令返回<returnvalue>0</returnvalue>, 
  而不成功的命令返回<returnvalue>非零</returnvalue>值, 非零值通常都被解释成一个错误码. 
  行为良好的UNIX命令, 程序, 和工具都会返回<returnvalue>0</returnvalue>作为退出码来表示成功, 
  虽然偶尔也会有例外. </para>

	  <para>同样的, 脚本中的函数和脚本本身也会返回退出状态码. 
		  在脚本或者是脚本函数中执行的最后的命令会决定退出状态码.
		  在脚本中, <userinput>exit <replaceable>nnn</replaceable></userinput>命令将会把<returnvalue>
			  <replaceable>nnn</replaceable></returnvalue>退出码传递给shell(<returnvalue>
			  <replaceable>nnn</replaceable></returnvalue>必须是十进制数, 
		 范围必须是<returnvalue>0</returnvalue> -
	<returnvalue>255</returnvalue>).</para>

      <note>

		  <para>当脚本以不带参数的<command>exit</command>命令来结束时, 
			  脚本的退出状态码就由脚本中最后执行的命令来决定(就是<command>exit</command>之前的命令).</para>

      <para><programlisting>#!/bin/bash

COMMAND_1

. . .

# 将以最后的命令来决定退出状态码.
COMMAND_LAST

exit</programlisting></para>

      <para>不带参数的<command>exit</command>命令与
		  <command>exit $?</command>的效果是一样的, 
		  甚至脚本的结尾不写<command>exit</command>, 也与前两者的效果相同. </para>

      <para><programlisting>#!/bin/bash

COMMAND_1

. . .

# 将以最后的命令来决定退出状态码.
COMMAND_LAST

exit $?</programlisting></para>

      <para><programlisting>#!/bin/bash

COMMAND1

. . . 

# 将以最后的命令来决定退出状态码.
COMMAND_LAST</programlisting></para>
	
	</note>

      <para><anchor id="exsref"></para>

      <para>
	<varname>
	  <indexterm>
	    <primary>$?</primary>
	  </indexterm> <indexterm>
	    <primary>variable</primary> <secondary>$?</secondary>
	  </indexterm> $?</varname>保存了最后所执行的命令的退出状态码. 
	    当函数返回之后, 
	    <varname>$?</varname>保存函数中最后所执行的命令的退出状态码. 
		这就是bash对函数<quote>返回值</quote>的处理方法. 
		当一个脚本退出, <varname>$?</varname>保存了脚本的退出状态码, 
	    这个退出状态码也就是脚本中最后一个执行命令的退出状态码. 
	    一般情况下, <userinput>0</userinput>表示成功, 
	    在范围<returnvalue>1 - 255</returnvalue>的整数表示错误. </para>

      <example id="ex5">
	<title>退出/退出状态码</title>
	<programlisting>&ex5;</programlisting>
      </example>
      
      <para><link linkend="xstatvarref">$?</link>用于测试脚本中的命令结果的时候, 往往显得特别有用(见<xref
        linkend="filecomp">和<xref linkend="lookup">).</para>

      <note>
      <para><link linkend="notref">!</link>, 逻辑
		  <quote>非</quote>操作符, 将会反转命令或条件测试的结果, 
		  并且这会影响<link linkend="exitstatusref">退出状态码</link>.

	<example id="negcond">
	<title>反转一个条件的用法<token>!</token></title>
	<programlisting>true  # "true" 是内建命令.
echo "exit status of \"true\" = $?"     # 0

! true
echo "exit status of \"! true\" = $?"   # 1
# 注意: "!" 需要一个空格.
#    !true   将导致"command not found"错误
#
# 如果一个命令以'!'开头, 那么会启用Bash的历史机制. 

true
!true
# 这次就没有错误了, 也没有反转结果.
# 它只是重复了之前的命令(true).

# 感谢, Stephane Chazelas和Kristopher Newsome.</programlisting>
        </example>

      </para>
      </note>


      <caution><para>特定的退出状态码具有<link
				  linkend="exitcodesref">保留含义</link>, 
			 所以用户不应该在脚本中指定它. </para></caution>


  </chapter> <!-- Exit and Exit status -->


  <chapter id="tests">
    <title>条件判断</title>

      <para><anchor id="ifthen"></para>

      <indexterm>
	<primary>if</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>if</secondary>
      </indexterm>
      <indexterm>
	<primary>then</primary>
      </indexterm>
      <indexterm>
	<primary>else if</primary>
      </indexterm>
      <indexterm>
	<primary>elif</primary>
      </indexterm>

        <para>每个完整并且合理的程序语言都具有条件判断的功能, 并且可以根据条件测试的结果做下一步的处理. 
	  Bash有<command>test</command>命令,
	  各种中括号和圆括号操作, 和<command>if/then</command>结构.</para>

      <sect1 id="testconstructs">
	<title>条件测试结构</title>

	<para><anchor id="testconstructs1"></para>

      <itemizedlist id="testingref">

        <listitem>
			<para><command>if/then</command>结构用来判断命令列表的<link 
					linkend="exitstatusref">退出状态码</link>是否为<returnvalue>0</returnvalue>(因为在UNIX惯例, 0表示<quote>成功</quote>), 
			如果成功的话, 那么就执行接下来的一个或多个命令.	</para>
	</listitem>

        <listitem>
			<para>有一个专有命令<command>[</command> (<link 
					linkend="leftbracket">左中括号</link>, 特殊字符). 
			这个命令与<command>test</command>命令等价,
			并且出于效率上的考虑, 这是一个<link linkend="builtinref">内建</link>命令. 
			这个命令把它的参数作为比较表达式或者作为文件测试, 
			并且根据比较的结果来返回一个退出状态码(0 表示真, 1表示假). </para>
	</listitem>

        <listitem>
	<para>在版本2.02的Bash中, 引入了<link
			linkend="dblbrackets">[[ ... ]]</link><emphasis>扩展测试命令</emphasis>, 
		因为这种表现形式可能对某些语言的程序员来说更容易熟悉一些. 
		注意<command>[[</command>是一个<link
	  linkend="keywordref">关键字</link>, 并不是一个命令.</para>

	<para>Bash把<userinput>[[ $a -lt $b ]]</userinput>看作一个单独的元素, 
		并且返回一个退出状态码.</para>

	<para><link linkend="dblparens">(( ... ))</link>和<link
	  linkend="letref">let ...</link>结构也能够返回退出状态码, 
	  当它们所测试的算术表达式的结果为非零的时候, 将会返回退出状态码<returnvalue>0</returnvalue>. 
	  这些<link linkend="arithexpref">算术扩展</link>结构被用来做算术比较. 

	    <programlisting>let "1&lt;2" returns 0 (as "1&lt;2" expands to "1")
(( 0 && 1 )) returns 1 (as "0 && 1" expands to "0")</programlisting>	    
	  </para>
        </listitem>

        <listitem>
          <para><anchor id="ifgrepref"></para>

	  <para><command>if</command>命令能够测试任何命令, 并不仅仅是中括号中的条件. 


	      <programlisting>if cmp a b &amp;&gt; /dev/null  # 禁止输出.
then echo "Files a and b are identical."
else echo "Files a and b differ."
fi

# 非常有用的"if-grep"结构:
# ------------------------
if grep -q Bash file
then echo "File contains at least one occurrence of Bash."
fi

word=Linux
letter_sequence=inu
if echo "$word" | grep -q "$letter_sequence"
# "-q" 选项是用来禁止输出的.
then
  echo "$letter_sequence found in $word"
else
  echo "$letter_sequence not found in $word"
fi


if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
then echo "Command succeeded."
else echo "Command failed."
fi</programlisting>
          </para>
        </listitem>

        <listitem>

	  <para>一个<command>if/then</command>结构可以包含嵌套的比较操作和条件判断操作. 
	      <programlisting>if echo "Next *if* is part of the comparison for the first *if*."

  if [[ $comparison = "integer" ]]
    then (( a < b ))
  else
    [[ $a < $b ]]
  fi

then
  echo '$a is less than $b'
fi</programlisting>
          </para> 

	  <para><emphasis>谦虚的Stephane Chazelas解释了<quote>if-test</quote>的详细细节.</emphasis></para>

        </listitem>


      </itemizedlist>



      <example id="ex10">
	<title>什么是真?</title>
	<programlisting>&ex10;</programlisting>
      </example>

      <formalpara><title>练习</title>
	<para>解释上边的<xref linkend="ex10">的行为. </para>
      </formalpara>
      
      <para><programlisting>if [ condition-true ]
then
   command 1
   command 2
   ...
else
   # 可选的(如果不需要可以省去).
   # 如果原始的条件判断的结果为假, 那么在这里添加默认的代码块来执行.
   command 3
   command 4
   ...
fi</programlisting>
      </para>

      <note>
		  <para>如果<emphasis>if</emphasis>和<emphasis>then</emphasis>在条件判断的同一行上的话, 
			  必须使用分号来结束<emphasis>if</emphasis>表达式. 
			  <emphasis>if</emphasis>和<emphasis>then</emphasis>都是<link
				  linkend="keywordref">关键字</link>. 关键字(或者命令)如果作为表达式的开头, 
			  并且如果想在同一行上再写一个新的表达式的话, 
	那么必须使用分号来结束上一句表达式.</para>

      <para><programlisting>if [ -x "$filename" ]; then</programlisting></para>
      </note>

      <variablelist id="elifref">
        <title><anchor id="elifref1">Else if和elif</title>
	<varlistentry>
          <term><token>elif</token></term>
	  <listitem>
		  <para><userinput>elif</userinput>是<token>else if</token>的缩写形式. 
			 作用是在外部的判断结构中再嵌入一个内部的<token>if/then</token>结构. </para>

	    <para><programlisting>if [ condition1 ]
then
   command1
   command2
   command3
elif [ condition2 ]
# 与else if一样
then
   command4
   command5
else
   default-command
fi</programlisting>
	      </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>
      <indexterm>
	<primary>test</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>test</secondary>
      </indexterm>
      <indexterm>
	<primary>[</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>[</secondary>
      </indexterm>
      <indexterm>
	<primary>]</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>]</secondary>
      </indexterm>
	
	<userinput>if test condition-true</userinput>结构与<userinput>if [ condition-true ]</userinput>完全相同.
	就像我们前面所看到的, 左中括号, <command>[</command> , 
	是调用<command>test</command>命令的标识. 
	而关闭条件判断用的的右中括号, <command>]</command>, 在if/test结构中并不是严格必需的, 
	但是在Bash的新版本中必须要求使用. </para>

	<note><para><command>test</command>命令在Bash中是<link
	  linkend="builtinref">内建</link>命令, 用来测试文件类型, 或者用来比较字符串. 
	  因此, 在Bash脚本中, 
	  <command>test</command>命令并<emphasis>不会</emphasis>调用外部的<filename>/usr/bin/test</filename>中的test命令,
	  这是<emphasis>sh-utils</emphasis>工具包中的一部分. 
	  同样的, <token>[</token>也并不会调用<filename>/usr/bin/[</filename>, 
	  这是<filename>/usr/bin/test</filename>的符号链接.</para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>type test</userinput>
<computeroutput>test is a shell builtin</computeroutput>
<prompt>bash$ </prompt><userinput>type '['</userinput>
<computeroutput>[ is a shell builtin</computeroutput>
<prompt>bash$ </prompt><userinput>type '[['</userinput>
<computeroutput>[[ is a shell keyword</computeroutput>
<prompt>bash$ </prompt><userinput>type ']]'</userinput>
<computeroutput>]] is a shell keyword</computeroutput>
<prompt>bash$ </prompt><userinput>type ']'</userinput>
<computeroutput>bash: type: ]: not found</computeroutput>
	      </screen>
	    </para></note>
      

      <example id="ex11">
	<title><token>test</token>,
	  <filename>/usr/bin/test</filename>, <token>[ ]</token>,
	  和<filename>/usr/bin/[</filename>都是等价命令</title>
	<programlisting>&ex11;</programlisting>
      </example>


      <indexterm>
	<primary>test</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>test</secondary>
      </indexterm>
      <indexterm>
	<primary>[[</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>[[</secondary>
      </indexterm>
      <indexterm>
	<primary>]]</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>]]</secondary>
      </indexterm>

	  <para><anchor id="dblbrackets"><token>[[  ]]</token>结构比<token>[	]结构更加通用</token>. 
			这是一个<emphasis>扩展的test命令</emphasis>, 是从<emphasis>ksh88</emphasis>中引进的.</para>

      <note><para>在<token>[[</token>和<token>]]</token>之间所有的字符都不会发生文件名扩展或者单词分割,
	但是会发生参数扩展和命令替换. </para></note>

      <para>
	<programlisting>file=/etc/passwd

if [[ -e $file ]]
then
  echo "Password file exists."
fi</programlisting>
      </para>

      <tip>
      <para>使用<command>[[ ... ]]</command>条件判断结构,
	而不是<command>[ ... ]</command>, 能够防止脚本中的许多逻辑错误. 
	比如, <token>&&</token>,
	<token>||</token>, <token>&lt;</token>, 和<token>&gt;</token>
	操作符能够正常存在于<token>[[  ]]</token>条件判断结构中, 
	但是如果出现在<token>[  ]</token>结构中的话, 会报错.</para>
      </tip>

      <note>
      <para>在<command>if</command>后面也不一定非得是<command>test</command>命令或者是用于条件判断的中括号结构( [ ] 或 [[ ]] ).

	<programlisting>dir=/home/bozo

if cd "$dir" 2&gt;/dev/null; then   # "2&gt;/dev/null" 会隐藏错误信息.
  echo "Now in $dir."
else
  echo "Can't change to $dir."
fi</programlisting>

        "if COMMAND"结构将会返回COMMAND的退出状态码.
</para>

	
<para>与此相似, 在中括号中的条件判断也不一定非得要<command>if</command>不可, 
	也可以使用<link linkend="listconsref">列表结构</link>.

	  <programlisting>var1=20
var2=22
[ "$var1" -ne "$var2" ] && echo "$var1 is not equal to $var2"

home=/home/bozo
[ -d "$home" ] || echo "$home directory does not exist."</programlisting></para>
	  </note>


      <indexterm>
	<primary>test</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>test</secondary>
      </indexterm>
      <indexterm>
	<primary>((</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>))</secondary>
      </indexterm>
      <indexterm>
	<primary>((</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>))</secondary>
      </indexterm>

      <para><link linkend="dblparens">(( ))结构</link>扩展并计算一个算术表达式的值. 
		  如果表达式的结果为0, 那么返回的<link linkend="exitstatusref">退出状态码</link>为<returnvalue>1</returnvalue>, 
		  或者是<quote>假</quote>. 
		  而一个非零值的表达式所返回的退出状态码将为<returnvalue>0</returnvalue>,
		  或者是<quote>true</quote>. 
		  这种情况和先前所讨论的<command>test</command>命令和<token>[ ]</token>结构的行为正好相反. </para>

        <example id="arithtests">
	  <title>算术测试需要使用<token>(( ))</token></title>
	  <programlisting>&arithtests;</programlisting>
        </example>

      </sect1> <!-- Test Constructs -->


      <sect1 id="fto">
	<title>文件测试操作符</title>

	<variablelist>
	  <title><anchor id="rtif">如果下面的条件成立将会返回真. </title>
	  <varlistentry>
	    <term><token>-e</token></term>
	    <listitem><para>文件存在</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-a</token></term>
	    <listitem><para>文件存在</para>
	    <para>这个选项的效果与<token>-e</token>相同.
	      但是它已经被<quote>弃用</quote>了, 并且不鼓励使用.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-f</token></term>
	    <listitem><para>表示这个文件是一个<replaceable>一般</replaceable>文件(并不是目录或者设备文件)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-s</token></term>
	    <listitem><para>文件大小不为零</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-d</token></term>
	    <listitem><para>表示这是一个目录</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-b</token></term>
	    <listitem><para>表示这是一个块设备(软盘, 光驱, 等等.)
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-c</token></term>
	    <listitem><para>表示这是一个字符设备(键盘, modem, 声卡, 等等.)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-p</token></term>
	    <listitem><para>这个文件是一个<link linkend="piperef">管道</link></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-h</token></term>
	    <listitem><para>这是一个<link linkend="symlinkref">符号链接</link></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-L</token></term>
	    <listitem><para>这是一个符号链接</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-S</token></term>
	    <listitem><para>表示这是一个<link linkend="socketref">socket</link></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-t</token></term>
	    <listitem>
	    <para>文件(<link linkend="fdref">描述符</link>)被关联到一个终端设备上</para>
		<para>这个测试选项一般被用来检测脚本中的<filename>stdin</filename>(<userinput>[ -t 0 
				]</userinput>) 或者<filename>stdout</filename>(<userinput>[ -t 1 ]</userinput>)是否来自于一个终端. </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-r</token></term>
	    <listitem><para>文件是否具有可读权限(<emphasis>指的是正在运行这个测试命令的用户是否具有读权限</emphasis>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-w</token></term>
	    <listitem><para>文件是否具有可写权限(指的是正在运行这个测试命令的用户是否具有写权限)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-x</token></term>
	    <listitem><para>文件是否具有可执行权限(指的是正在运行这个测试命令的用户是否具有可执行权限)</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-g</token></term>
	    <listitem>
	    <para>set-group-id(sgid)标记被设置到文件或目录上</para>
		<para>如果目录具有<replaceable>sgid</replaceable>标记的话, 
			那么在这个目录下所创建的文件将属于拥有这个目录的用户组, 
			而不必是创建这个文件的用户组. 
			这个特性对于在一个工作组中共享目录非常有用. </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-u</token></term>
	    <listitem>
	    <para>set-user-id (suid)标记被设置到文件上</para>
		<para>如果一个<emphasis>root</emphasis>用户所拥有的二进制可执行文件设置了<replaceable>set-user-id</replaceable>标记位的话, 
		  那么普通用户也会以<emphasis>root</emphasis>权限来运行这个文件. 
	      
		<footnote><para>在将<emphasis>suid</emphasis>标记设置到二进制可执行文件的时候, 一定要小心. 
			因为这可能会引发安全漏洞. 但是<emphasis>suid</emphasis>标记不会影响shell脚本.</para></footnote>

	      这对于需要访问系统硬件的执行程序(比如<command>pppd</command>和<command>cdrecord</command>)非常有用. 
		  如果没有<emphasis>suid</emphasis>标志的话, 这些二进制执行程序是不能够被非root用户调用的.

	      <screen>
	      <computeroutput>-rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd</computeroutput>
	      </screen>

	      对于设置了<replaceable>suid</replaceable>标志的文件, 在它的权限列中将会以<emphasis>s</emphasis>表示. </para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-k</token></term>
	    <listitem>

	    <para>设置<replaceable>粘贴位</replaceable></para>

		<para>对于<quote>粘贴位</quote>的一般了解, 
			<emphasis>save-text-mode</emphasis>标志是一个文件权限的特殊类型. 
	      如果文件设置了这个标志, 
	      那么这个文件将会被保存到缓存中, 这样可以提高访问速度.
		  <footnote><para>在当代UNIX系统中, 
		  文件中已经不使用粘贴位了, 粘贴位只使用在目录中. </para></footnote>
	      粘贴位如果设置在目录中, 那么它将限制写权限. 
	      对于设置了粘贴位的文件或目录, 在它们的权限标记列中将会显示<emphasis>t</emphasis>.

	      <screen>
	      <computeroutput>drwxrwxrwt    7 root         1024 May 19 21:26 tmp/</computeroutput>
	      </screen>
	    
		  如果用户并不拥有这个设置了粘贴位的目录, 
		  但是他在这个目录下具有写权限, 
		  那么这个用户只能在这个目录下删除自己所拥有的文件. 
	      这将有效的防止用户在一个公共目录中不慎覆盖或者删除别人的文件. 
	      比如说<filename class="directory">/tmp</filename>目录.
	      (当然, 目录的所有者或者<emphasis>root</emphasis>用户可以随意删除或重命名其中的文件.) </para>

	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-O</token></term>
	    <listitem><para>判断你是否是文件的拥有者</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-G</token></term>
	    <listitem><para>文件的group-id是否与你的相同</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-N</token></term>
	    <listitem><para>从文件上一次被读取到现在为止, 文件是否被修改过</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -nt f2</token></term>
	    <listitem><para>文件<replaceable>f1</replaceable>比文件<replaceable>f2</replaceable>新</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -ot f2</token></term>
	    <listitem><para>文件<replaceable>f1</replaceable>比文件<replaceable>f2</replaceable>旧</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -ef f2</token></term>
	    <listitem><para>文件<replaceable>f1</replaceable>和文件<replaceable>f2</replaceable>是相同文件的硬链接</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>!</token></term>
	    <listitem><para><quote>非</quote> -- 反转上边所有测试的结果(如果没给出条件, 那么返回真).</para></listitem>
	  </varlistentry>
	</variablelist>

	<example id="brokenlink">
	  <title>测试那些断掉的链接文件</title>
	  <programlisting>&brokenlink;</programlisting>
	</example>

	<para><xref linkend="cookies">, <xref linkend="bingrep">,
	  <xref linkend="fileinfo">, <xref linkend="ramdisk">, 和<xref
	  linkend="mailformat">也会演示文件测试操作的使用过程. </para>


      </sect1> <!-- File test operators -->

      <sect1 id="comparison-ops">
	<title>其他比较操作符</title>

	<para><emphasis>二元</emphasis>比较操作符用来比较两个变量或数字. 
		注意整数比较与字符串比较的区别. </para>

	<variablelist id="icomparison">
	  <title><anchor id="icomparison1">整数比较</title>

	  <varlistentry>
	    <term><token>-eq</token></term>
	    <listitem>
	    <para><anchor id="equalref"></para>
	    <para>等于</para>
	    <para><userinput>if [ "$a" -eq "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-ne</token></term>
	    <listitem>
	    <para>不等于</para>
	    <para><userinput>if [ "$a" -ne "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-gt</token></term>
	    <listitem>
	    <para>大于</para>
	    <para><userinput>if [ "$a" -gt "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-ge</token></term>
	    <listitem>
	    <para>大于等于</para>
	    <para><userinput>if [ "$a" -ge "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-lt</token></term>
	    <listitem>
	    <para>小于</para>
	    <para><userinput>if [ "$a" -lt "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-le</token></term>
	    <listitem>
	    <para>小于等于</para>
	    <para><userinput>if [ "$a" -le "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="intlt"><token>&lt;</token></term>
	    <listitem>
	    <para>小于(在<link linkend="dblparens">双括号</link>中使用)</para>
	    <para><userinput>(("$a" &lt; "$b"))</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>&lt;=</token></term>
	    <listitem>
	    <para>小于等于(在双括号中使用)</para>
	    <para><userinput>(("$a" &lt;= "$b"))</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>&gt;</token></term>
	    <listitem>
	    <para>大于(在双括号中使用)</para>
	    <para><userinput>(("$a" &gt; "$b"))</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>&gt;=</token></term>
	    <listitem>
	    <para>大于等于(在双括号中使用)</para>
	    <para><userinput>(("$a" &gt;= "$b"))</userinput></para>
	    </listitem>
	  </varlistentry>
	  
	</variablelist>
	
	<variablelist id="scomparison">
	  <title><anchor id="scomparison1">字符串比较</title>
	  <varlistentry>
	    <term><token>=</token></term>
	    <listitem>
	    <para><anchor id="equalsignref"></para>
	    <para>等于</para>
	    <para><userinput>if [ "$a" = "$b" ]</userinput></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>==</token></term>
	    <listitem>
	      <para>等于</para>
	      <para><userinput>if [ "$a" == "$b" ]</userinput></para>
	      <para>与<token>=</token>等价.</para>

	      <note><para>
	      <token>==</token>比较操作符在<link linkend="dblbrackets">双中括号对</link>和单中括号对中的行为是不同的. 
	      <programlisting>[[ $a == z* ]]    # 如果$a以"z"开头(模式匹配)那么结果将为真
[[ $a == "z*" ]]  # 如果$a与z*相等(就是字面意思完全一样), 那么结果为真.

[ $a == z* ]      # 文件扩展匹配(file globbing)和单词分割有效. 
[ "$a" == "z*" ]  # 如果$a与z*相等(就是字面意思完全一样), 那么结果为真. 

# 感谢, Stephane Chazelas</programlisting>
              </para></note>

	      </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>!=</token></term>
	    <listitem>
	    <para>不等号</para>
	    <para><userinput>if [ "$a" != "$b" ]</userinput></para>
	    <para>这个操作符将在<link
	      linkend="dblbrackets">[[ ... ]]</link>结构中使用模式匹配. </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="ltref"><token>&lt;</token></term>
	    <listitem>
	    <para>小于, 按照ASCII字符进行排序</para>
	    <para><userinput>if [[ "$a" &lt; "$b" ]]</userinput></para>
	    <para><userinput>if [ "$a" \&lt; "$b" ]</userinput></para>
	    <para>注意<quote>&lt;</quote>使用在<userinput>[  ]</userinput>结构中的时候需要被转义. </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="gtref"><token>&gt;</token></term>
	    <listitem>
	    <para>大于, 按照ASCII字符进行排序</para>
	    <para><userinput>if [[ "$a" &gt; "$b" ]]</userinput></para>
	    <para><userinput>if [ "$a" \&gt; "$b" ]</userinput></para>
	    <para>注意<quote>&gt;</quote>使用在<userinput>[  ]</userinput>结构中的时候需要被转义. </para>  
	    <para>参考<xref linkend="bubble">, 这个例子展示了如何使用这个比较操作符. </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-z</token></term>
	    <listitem><para>字符串为<quote>null</quote>, 意思就是字符串长度为零</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-n</token></term>
	    <listitem>
	      <para>字符串不为<quote>null</quote>.</para>
	    
		  <caution><para>当<userinput>-n</userinput>使用在中括号中进行条件测试的时候, 
				  必须要把字符串用双引号引用起来. 
				  如果采用了未引用的字符串来使用<userinput>! -z</userinput>, 
				  甚至是在条件测试中括号(参见<xref
		linkend="strtest">)中只使用未引用的字符串的话, 一般也是可以工作的, 
		然而, 这是一种不安全的习惯. <emphasis>习惯于</emphasis>使用引用的测试字符串才是正路. 
		  <footnote><para>就像S.C.所指出的那样, 在一个混合测试中,
				  即使使用引用的字符串变量也可能还不够. 
				  如果<varname>$string</varname>为空的话, 
				  <userinput>[ -n "$string" -o "$a" =
		    "$b" ]</userinput>可能会在某些版本的Bash中产生错误. 
		安全的做法是附加一个额外的字符给可能的空变量, 
		<userinput>[ "x$string" != x -o "x$a" = "x$b" ]</userinput>
		    (<quote>x</quote>字符是可以相互抵消的).</para></footnote>
		</para></caution>

            </listitem>
	    </varlistentry>
	</variablelist>
	
	<example id="ex13">
	  <title>算术比较与字符串比较</title>
	  <programlisting>&ex13;</programlisting>
	</example>

	<example id="strtest">
	  <title>检查字符串是否为<emphasis>null</emphasis></title>
	  <programlisting>&strtest;</programlisting>
	</example>
      
	<example id="ex14">
	  <title><command>zmore</command></title>
	  <programlisting>&ex14;</programlisting>
	</example>

	<variablelist id="ccomparison">  
	  <title><anchor id="ccomparison1">compound comparison</title>

	  <varlistentry>
	    <term><token>-a</token></term>
	    <listitem>
	      <para>逻辑与</para>
	      <para><replaceable>exp1 -a exp2</replaceable> 如果表达式exp1和exp2<emphasis>都</emphasis>为真的话, 那么结果为真.</para>
	    </listitem>
            </varlistentry>
	  <varlistentry>
	    <term><token>-o</token></term>
	    <listitem>
	      <para>逻辑或</para>
	      <para><replaceable>exp1 -o exp2</replaceable> 如果表达式exp1和exp2中<emphasis>至少</emphasis>有一个为真的话, 那么结果为真.</para>
	    </listitem>
	    </varlistentry>
	</variablelist>

	<para>这与Bash中的比较操作符<command>&&</command>和<command>||</command>非常相像, 
		但是这个两个操作符是用在<link linkend="dblbrackets">双中括号结构</link>中的.
	   <programlisting>[[ condition1 && condition2 ]]</programlisting>
	 <command>-o</command>和<command>-a</command>操作符一般都是和<command>test</command>命令或者是单中括号结构一起使用的. 
	   <programlisting>if [ "$exp1" -a "$exp2" ]</programlisting>
	   </para>

       <para>请参考<xref linkend="andor">, <xref linkend="twodim">,
	 和<xref linkend="whx">, 这几个例子演示了混合比较操作符的行为. </para>

      </sect1> <!-- Comparison operators (binary) -->

      <sect1 id="nestedifthen">
        <title>嵌套的if/then条件测试</title>

       <para>可以通过<command>if/then</command>结构来使用嵌套的条件测试.
	最终的结果和上面使用<command>&&</command>混合比较操作符的结果是相同的. </para>

       <para><programlisting>if [ condition1 ]
then
  if [ condition2 ]
  then
    do-something  # But only if both "condition1" and "condition2" valid.
  fi  
fi</programlisting></para>  

       <para>参考<xref linkend="ex79">, 里边有一个使用<replaceable>if/then</replaceable>结构进行条件测试的例子. </para>
	
      </sect1> <!-- Nested if/then Tests -->

      <sect1 id="testtest">
        <title>检测你对测试知识的掌握情况</title>

		<para>系统范围的<filename>xinitrc</filename>文件可以用来启动X server. 
			这个文件包含了相当多的<emphasis>if/then</emphasis>条件测试, 
			下面是这个文件的部分节选. </para>

      <para><programlisting>if [ -f $HOME/.Xclients ]; then
  exec $HOME/.Xclients
elif [ -f /etc/X11/xinit/Xclients ]; then
  exec /etc/X11/xinit/Xclients
else
     # 失败后的安全设置. 虽然我们永远都不会走到这来.
     # (我们在Xclients中也提供了相同的机制) 保证它不会被破坏.
     xclock -geometry 100x100-5+5 &
     xterm -geometry 80x50-50+150 &
     if [ -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html ]; then
             netscape /usr/share/doc/HTML/index.html &
     fi
fi</programlisting></para>     

     <para>解释上边节选中<quote>条件测试</quote>结构中的内容, 
       然后检查整个文件, <filename>/etc/X11/xinit/xinitrc</filename>,
	   并且分析其中的<emphasis>if/then</emphasis>测试结构. 
	   你可能需要查阅一下后边讲解的知识, 比如说<link
       linkend="grepref">grep</link>, <link linkend="sedref">sed</link>,
       和<link linkend="regexref">正则表达式</link>.</para>


      </sect1> <!-- Testing Your Knowledge of Tests -->

  </chapter> <!-- Tests -->



  <chapter id="operations">
    <title>操作符与相关主题</title>


     <sect1 id="ops">
      <title>操作符</title>

      <variablelist id="asnop">
        <title><anchor id="asnop1">赋值</title>

	<varlistentry>
	  <term><replaceable>变量赋值</replaceable></term>
	  <listitem><para>初始化或者修改变量的值</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <indexterm>
	    <primary>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>=</secondary>
	  </indexterm>
	  <term>=</term>
	  <listitem>
	  <para>通用赋值操作符, 可用于算术和字符串赋值. </para>

	    <para>
	      <programlisting>var=27
category=minerals  # 在"="之后是不允许出现空白字符的.</programlisting>
	    </para>

            <caution>
	    <para>不要混淆<quote>=</quote>赋值操作符与<link linkend="equalsignref">=</link>测试操作符.</para>

	    <para>
	      <programlisting>#    = 在这里是测试操作符

if [ "$string1" = "$string2" ]
# if [ "X$string1" = "X$string2" ] 是一种更安全的做法,
# 这样可以防止两个变量中的一个为空所产生的错误.
# (字符"X"作为前缀在等式两边是可以相互抵消的.) 
then
   command
fi</programlisting>
	    </para>
	    </caution>


	  </listitem>
	</varlistentry>
      </variablelist>

	<indexterm>
	  <primary>expr</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>expr</secondary>
	</indexterm>
	<indexterm>
	  <primary>let</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>let</secondary>
	</indexterm>


      <variablelist id="arops">
        <title><anchor id="arops1">算术操作符</title>

	<varlistentry>
	  <term><token>+</token></term>
	  <indexterm>
	    <primary>+</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>+</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>addition</primary>
	  </indexterm>
	  <indexterm>
	    <primary>plus</primary>
	  </indexterm>
	  <listitem><para>加法计算</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-</token></term>
	  <indexterm>
	    <primary>-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>subtraction</primary>
	  </indexterm>
	  <indexterm>
	    <primary>minus</primary>
	  </indexterm>
	  <listitem><para>减法计算</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*</token></term>
	  <indexterm>
	    <primary>*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>multiplication</primary>
	  </indexterm>
	  <listitem><para>乘法计算</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/</token></term>
	  <indexterm>
	    <primary>/</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>/</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>division</primary>
	  </indexterm>
	  <listitem><para>除法计算</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="exponentiationref"><token>**</token></term>
	  <indexterm>
	    <primary>**</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>**</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>exponentiation</primary>
	  </indexterm>
	  <listitem>
	  <para>幂运算
	    <programlisting># 在Bash, 版本2.02, 中开始引入了"**" 幂运算符.

let "z=5**3"
echo "z = $z"   # z = 125</programlisting>
          </para>	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="moduloref"><token>%</token></term>
	  <indexterm>
	    <primary>%</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>%</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>modulo</primary>
	  </indexterm>
	  <listitem>

	  <para>模运算, 或者是求余运算(返回一次除法运算的<firstterm>余数</firstterm>)</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>expr 5 % 3</userinput>
<computeroutput>2</computeroutput>
	      </screen>
	      <emphasis>5/3 = 1 余数为 2</emphasis>
	    </para>

	  <para>模运算经常在其他的一些情况中出现, 
	    比如说产生特定范围的数字(参见<xref
			linkend="ex21">和<xref linkend="randomtest">), 
				或者格式化程序的输出(参见<xref linkend="qfunction">和<xref 
				linkend="collatz">). 它甚至可以用来产生质数, 
				(参见<xref linkend="primes">). 事实上模运算在算术运算中的使用频率高得惊人. </para>

	    <example id="gcd">
	      <title>最大公约数</title>
	      <programlisting>&gcd;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>+=</token></term>
	  <indexterm>
	    <primary>+=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>+=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>plus-equal</primary>
	  </indexterm>
	  <listitem><para><quote>加-等于</quote> (把变量的值增加一个常量然后再把结果赋给变量)</para>
		  <para><userinput>let "var += 5"</userinput> 
			  <varname>var</varname>变量的值会在原来的基础上加<literal>5</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-=</token></term>
	  <indexterm>
	    <primary>-=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>-=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>minus-equal</primary>
	  </indexterm>
	  <listitem><para><quote>减-等于</quote> (把变量的值减去一个常量然后再把结果赋给变量)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*=</token></term>
	  <indexterm>
	    <primary>*=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>*=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>times-equal</primary>
	  </indexterm>
	  <listitem><para><quote>乘-等于</quote> (先把变量的值乘以一个常量的值, 然后再把结果赋给变量)</para>
		  <para><userinput>let "var *= 4"</userinput> 
			  <varname>var</varname>变量的结果将会在原来的基础上乘以<literal>4</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/=</token></term>
	  <indexterm>
	    <primary>/=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>/=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>slash-equal</primary>
	  </indexterm>
	  <listitem><para><quote>除-等于</quote> (先把变量的值除以一个常量的值, 然后再把结果赋给变量)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>%=</token></term>
	  <indexterm>
	    <primary>%=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>%=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>mod-equal</primary>
	  </indexterm>
	  <listitem><para><quote>取模-等于</quote> (先对变量进行模运算, 即除以一个常量取模, 然后把结果赋给变量)</para>

      <para><emphasis>算术操作符经常会出现在
        <link linkend="exprref">expr</link>或<link
        linkend="letref">let</link>表达式中.</emphasis></para>

	    <example id="arithops">
	      <title>使用算术操作符</title>
	      <programlisting>&arithops;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>

      <note>
		  <para>在Bash中的整型变量事实上是一个有符号的<emphasis>long</emphasis>(32-bit)整型值, 
			  所表示的范围是-2147483648到2147483647. 
			  如果超过这个范围进行算术操作的话, 那么将不会得到你期望的结果.(译者注: 溢出)
	  <programlisting>a=2147483646
echo "a = $a"      # a = 2147483646
let "a+=1"         # 变量"a"加1.
echo "a = $a"      # a = 2147483647
let "a+=1"         # 变量"a"再加1, 就会超出范围限制了.
echo "a = $a"      # a = -2147483648
                   #      错误(超出范围了)</programlisting>
	</para>
	
	<para>在2.05b版本之后, Bash开始支持64位整型了.</para>
	</note>

	<caution><para>Bash不能够处理浮点运算. 
			它会把包含小数点的数字看作字符串.
        <programlisting>a=1.5

let "b = $a + 1.3"  # 错误.
# t2.sh: let: b = 1.5 + 1.3: 表达式的语法错误(错误标志为".5 + 1.3")

echo "b = $b"       # b=1</programlisting>

		如果非要做浮点运算的话, 可以在脚本中使用<link linkend="bcref">bc</link>, 
		这个命令可以进行浮点运算, 或者调用数学库函数. </para></caution>



      <formalpara><title>位操作符</title>
      <para>位操作符在shell脚本中很少被使用, 
		  它们最主要的用途就是操作和测试从端口或者<link linkend="socketref">sockets</link>中读取的值. 
		  位翻转<quote>Bit flipping</quote>与编译语言的联系很紧密, 
		  比如C/C++, 在这种语言中它可以运行的足够快. </para></formalpara>

      <variablelist id="bitwsops">
        <title><anchor id="bitwsops1">位操作符</title>

	<varlistentry>
	  <term><token><<</token></term>
	  <indexterm>
	    <primary><<</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><<</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>left shift</primary>
	  </indexterm>
	  <listitem><para>左移一位(每次左移都相当于乘以<literal>2</literal>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><<=</token></term>
	  <indexterm>
	    <primary><<=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><<=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>left-shift-equal</primary>
	  </indexterm>
	  <listitem><para><quote>左移-赋值</quote></para>
		  <para><userinput>let "var <<= 2"</userinput> 
			  这句的结果就是变量<varname>var</varname>左移<literal>2</literal>位(就是乘以<literal>4</literal>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>></token></term>
	  <indexterm>
	    <primary>>></primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>right shift</primary>
	  </indexterm>
	  <listitem><para>右移一位(每次右移都将除以<literal>2</literal>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>>=</token></term>
	  <indexterm>
	    <primary>>>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>>>=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>right-shift-equal</primary>
	  </indexterm>
	  <listitem><para><quote>右移-赋值</quote> (与<token><<=</token>正好相反)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&</token></term>
	  <indexterm>
	    <primary>&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>AND</primary>
	    <secondary>bitwise</secondary>
	  </indexterm>
	  <listitem><para>按位与</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&=</token></term>
	  <indexterm>
	    <primary>&=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>and-equal</primary>
	  </indexterm>
	  <listitem><para><quote>按位与-赋值</quote></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|</token></term>
	  <indexterm>
	    <primary>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR</primary>
	    <secondary>bitwise</secondary>
	  </indexterm>
	  <listitem><para>按位或</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|=</token></term>
	  <indexterm>
	    <primary>|=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>|=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR-equal</primary>
	  </indexterm>
	  <listitem><para><quote>按位或-赋值</quote></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~</token></term>
	  <indexterm>
	    <primary>~</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>~</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>negate</primary>
	  </indexterm>
	  <listitem><para>按位反</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>!</token></term>
	  <indexterm>
	    <primary>!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>NOT</primary>
	  </indexterm>
	  <listitem><para>按位非</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>^</token></term>
	  <indexterm>
	    <primary>^</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>^</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>XOR</primary>
	  </indexterm>
	  <listitem><para>按位异或XOR</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>^=</token></term>
	  <indexterm>
	    <primary>^=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>^=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>XOR-equal</primary>
	  </indexterm>
	  <listitem><para><quote>按位异或-赋值</quote></para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="logops">
        <title><anchor id="logops1">逻辑操作符</title>

	<varlistentry>
	  <term><token>&&</token></term>
	  <indexterm>
	    <primary>&&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operator</primary>
	    <secondary>&&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>AND</primary>
	    <secondary>logical</secondary>
	  </indexterm>
	  <listitem><para>与(逻辑)</para>
	    <para><programlisting>if [ $condition1 ] && [ $condition2 ]
# 与 if [ $condition1 -a $condition2 ] 相同
# 如果condition1和condition2都为true, 那结果就为true. 

if [[ $condition1 && $condition2 ]]    # 也可以.
# 注意: &&不允许出现在[ ... ]结构中.</programlisting></para>

	  <note><para><token>&&</token>也可以用在<link linkend="listconsref">与列表</link>中, 
			  但是使用在连接命令中时, 需要依赖于具体的上下文. </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="orref"><token>||</token></term>
	  <indexterm>
	    <primary>||</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operator</primary>
	    <secondary>||</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR</primary>
	    <secondary>logical</secondary>
	  </indexterm>
	  <listitem><para>或(逻辑)</para>
	    <para><programlisting>if [ $condition1 ] || [ $condition2 ]
# 与 if [ $condition1 -o $condition2 ] 相同
# 如果condition1或condition2中的一个为true, 那么结果就为true. 

if [[ $condition1 || $condition2 ]]    # 也可以.
# 注意||操作符是不能够出现在[ ... ]结构中的. </programlisting></para>

	  <note><para>Bash将会测试每个表达式的<link linkend="exitstatusref">退出状态码</link>, 这些表达式由逻辑操作符连接起来. </para></note>

	<example id="andor">
	  <title>使用&&和||进行混合条件测试</title>
       	    <programlisting>&andor;</programlisting>
	 </example>   

	    <para><token>&&</token>和<token>||</token>操作符也可以用在算术上下文中. </para>
	      
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo $(( 1 && 2 )) $((3 && 0)) $((4 || 0)) $((0 || 0))</userinput>
<computeroutput>1 0 1 0</computeroutput>
	      </screen>
	    </para>
	      
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist id="miscop">
        <title><anchor id="miscop1">混杂的操作符</title>

	<varlistentry>
	  <term><anchor id="commaop"><token>,</token></term>
	  <indexterm>
	    <primary>,</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>,</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>linking</primary>
	  </indexterm>
	  <listitem>
	    <para>逗号操作符</para>
	    <para><command>逗号操作符</command>可以连接两个或多个算术运算. 
	      所有的操作都会被运行(可能会有<emphasis>负作用</emphasis>),
	      但是只会返回最后操作的结果. </para>

	     <para>
	     <programlisting>let "t1 = ((5 + 3, 7 - 1, 15 - 4))"
echo "t1 = $t1"               # t1 = 11

let "t2 = ((a = 9, 15 / 3))"  # 设置"a"并且计算"t2".
echo "t2 = $t2    a = $a"     # t2 = 5    a = 9</programlisting>
	     </para>

	     <para>逗号操作符主要用在<link
	       linkend="forloopref1">for循环</link>中. 参见<xref
	       linkend="forloopc">.</para>

	  </listitem>

	</varlistentry>
      </variablelist>

    </sect1> <!-- Operators -->

    <sect1 id="Numerical-Constants">
      <title>数字常量</title>

      <para><anchor id="numconstants">shell脚本在默认情况下都是把数字作为10进制数来处理, 
	除非这个数字采用了特殊的标记或者前缀.
	如果数字以<replaceable>0</replaceable>开头的话那么就是<replaceable>8进制</replaceable>数.
	如果数字以<replaceable>0x</replaceable>开头的话那么就是<replaceable>16进制</replaceable>数. 
	如果数字中间嵌入了<replaceable>#</replaceable>的话, 那么就被认为是<replaceable>BASE#NUMBER</replaceable>形式的标记法(有范围和符号限制).</para>

	    <example id="numbers">
	      <title>数字常量表示法</title>
	      <programlisting>&numbers;</programlisting>
	    </example>

    </sect1> <!-- Numerical-Constants -->

  </chapter> <!-- Operations -->

  </part> <!-- Part 2 (Basics) -->



  <part label="第三部分" id="part3">
    <title>进阶</title>

  <chapter id="variables2">
      <title>变量重游</title>


	<para>如果变量使用的恰当, 将会使得脚本更加强大和有弹性. 但这要求我们学习变量的精妙之处及其细微的差别. </para>


    <sect1 id="internalvariables">  
      <title>内部变量</title>

      <variablelist id="internalvariables1">
	
	<varlistentry>
	  <term><replaceable><link
	  linkend="builtinref">内建</link>变量</replaceable></term>
	  <listitem><para>这些变量将会影响bash脚本的行为.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH</varname></term>
	  <indexterm>
	    <primary>$BASH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>path to bash</primary>
	  </indexterm>
	  <listitem><para><emphasis>Bash</emphasis>的二进制程序文件的路径
	      <screen><prompt>bash$ </prompt><userinput>echo $BASH</userinput>
<computeroutput>/bin/bash</computeroutput></screen>
	    </para>
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH_ENV</varname></term>
	  <indexterm>
	    <primary>$BASH_ENV</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH_ENV</secondary>
	  </indexterm>
	  <listitem><para>这个<link linkend="envref">环境变量</link>会指向一个Bash的启动文件, 
			  当一个脚本被调用的时候, 这个启动文件将会被读取. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="bashsubshellref"><varname>$BASH_SUBSHELL</varname></term>
	  <indexterm>
	    <primary>$BASH_SUBSHELL</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>subshell</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个变量用来提示<link
				linkend="subshellsref">子shell</link>的层次. 
			这是一个Bash的新特性, 直到<link linkend="bash3ref">版本3</link>的Bash才被引入近来.</para>
	    <para>参考<xref linkend="subshell">中的用法.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH_VERSINFO[n]</varname></term>
	  <indexterm>
	    <primary>$BASH_VERSINFO</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>version information</secondary>
	  </indexterm>
	  <listitem>
		  <para>这是一个含有6个元素的<link linkend="arrayref">数组</link>, 
			  它包含了所安装的Bash的版本信息. 
			  这与下边的<varname>$BASH_VERSION</varname>很相像,
	    但是这个更加详细一些.</para>
	  <para>
	  <programlisting># Bash version info:

for n in 0 1 2 3 4 5
do
  echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
done  

# BASH_VERSINFO[0] = 3                      # 主版本号.
# BASH_VERSINFO[1] = 00                     # 次版本号.
# BASH_VERSINFO[2] = 14                     # 补丁次数.
# BASH_VERSINFO[3] = 1                      # 编译版本.
# BASH_VERSINFO[4] = release                # 发行状态.
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # 结构体系
                                            # (与变量$MACHTYPE相同).</programlisting>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH_VERSION</varname></term>
	  <indexterm>
	    <primary>$BASH_VERSION</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH_VERSION</secondary>
	  </indexterm>
	  <listitem><para>安装在系统上的Bash版本号</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo $BASH_VERSION</userinput>
<computeroutput>3.00.14(1)-release</computeroutput>
	      </screen>
	    </para>

	  <para>
	      <screen><prompt>tcsh% </prompt><userinput>echo $BASH_VERSION</userinput>
<computeroutput>BASH_VERSION: Undefined variable.</computeroutput>
	      </screen>
	    </para>

		<para>检查$BASH_VERSION对于判断系统上到底运行的是哪个shell来说是一种非常好的方法. 
			变量<link linkend="shellvarref">$SHELL</link>有时候不能够给出正确的答案. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="dirstackref"><varname>$DIRSTACK</varname></term>
	  <indexterm>
	    <primary>$DIRSTACK</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$DIRSTACK</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory stack</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>stack</secondary>
	  </indexterm>
	  <listitem><para>在目录栈中最顶端的值.
	    (将会受到<link linkend="pushdref">pushd</link>和<link
			linkend="popdref">popd</link>的影响)</para>
		<para>这个内建变量与<link linkend="dirsd">dirs</link>命令相符,
	    但是<command>dirs</command>命令会显示目录栈的整个内容. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$EDITOR</varname></term>
	  <indexterm>
	    <primary>$EDITOR</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$EDITOR</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>editor</primary>
	  </indexterm>
	  <listitem><para>脚本所调用的默认编辑器, 
			 通常情况下是<command>vi</command>或者是<command>emacs</command>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="euidref"><varname>$EUID</varname></term>
	  <indexterm>
	    <primary>$EUID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$EUID</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>effective user ID</primary>
	  </indexterm>
	  <listitem><para><quote>有效</quote>用户ID</para>
	    <para>不管当前用户被假定成什么用户, 这个数都用来表示当前用户的标识号, 也可能使用<link
	      linkend="suref">su</link>命令来达到假定的目的.</para>
	    <caution><para><varname>$EUID</varname>并不一定与<link
	      linkend="uidref">$UID</link>相同.</para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$FUNCNAME</varname></term>
	  <indexterm>
	    <primary>$FUNCNAME</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>function</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>name</primary>
	  </indexterm>
	  <listitem>
	    <para>当前函数的名字</para>
	    <para><programlisting>xyz23 ()
{
  echo "$FUNCNAME now executing."  # 打印: xyz23 now executing.
}

xyz23

echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
                                   # 超出函数的作用域就变为null值了. </programlisting>
            </para>

	  </listitem>
	</varlistentry>

        <varlistentry>
	  <term><varname>$GLOBIGNORE</varname></term>
	  <indexterm>
	    <primary>$GLOBIGNORE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>globbing</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>ignore</primary>
	  </indexterm>
	  <listitem><para>一个文件名的模式匹配列表, 如果在<link linkend="globbingref">通配(globbing)</link>中匹配到的文件包含有这个列表中的某个文件, 
			  那么这个文件将被从匹配到的结果中去掉.</para>
	  </listitem>
	</varlistentry>

        <varlistentry>
	  <term><anchor id="groupsref"><varname>$GROUPS</varname></term>
	  <indexterm>
	    <primary>$GROUPS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$GROUPS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>groups</primary>
	  </indexterm>
	  <listitem><para>目前用户所属的组</para>
	    <para>这是一个当前用户的组id列表(数组), 与记录在<filename>/etc/passwd</filename>文件中的内容一样.
	    </para>

	    <para>
	      <screen>
<prompt>root# </prompt><userinput>echo $GROUPS</userinput>
<computeroutput>0</computeroutput>


<prompt>root# </prompt><userinput>echo ${GROUPS[1]}</userinput>
<computeroutput>1</computeroutput>


<prompt>root# </prompt><userinput>echo ${GROUPS[5]}</userinput>
<computeroutput>6</computeroutput>
	      </screen>
	      </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="homedirref"><varname>$HOME</varname></term>
	  <indexterm>
	    <primary>$HOME</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOME</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>home directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>home</secondary>
	  </indexterm>
	  <listitem><para>用户的home目录, 一般是<filename
	    class="directory">/home/username</filename>(参见<xref
	    linkend="ex6">)</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="hostnameref"><varname>$HOSTNAME</varname></term>
	  <indexterm>
	    <primary>$HOSTNAME</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOSTNAME</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>system name</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>name</secondary>
	  </indexterm>
	  <listitem>
	  <para><link linkend="hnameref">hostname</link>放在一个初始化脚本中, 
	    在系统启动的时候分配一个系统名字.
	    然而, <function>gethostname()</function>函数可以用来设置这个Bash内部变量<varname>$HOSTNAME</varname>.
	    参见<xref linkend="ex6">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$HOSTTYPE</varname></term>
	  <indexterm>
	    <primary>$HOSTTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOSTTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>host type</primary>
	  </indexterm>
	  <listitem><para>主机类型</para>
	    <para>就像<link linkend="machtyperef">$MACHTYPE</link>,
	      用来识别系统硬件.</para>
	    <screen><prompt>bash$ </prompt><userinput>echo $HOSTTYPE</userinput>
<computeroutput>i686</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="ifsref"><varname>$IFS</varname></term>
	  <indexterm>
	    <primary>$IFS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$IFS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>internal field separator</primary>
	  </indexterm>
	  <listitem><para>内部域分隔符</para>

            <para>这个变量用来决定Bash在解释字符串时如何识别域, 或者单词边界.</para>

	    <para>$IFS默认为<link
	      linkend="whitespaceref">空白</link>(空格,
	      制表符,和换行符), 但这是可以修改的, 比如,
		  在分析逗号分隔的数据文件时, 就可以设置为逗号. 
		  注意<link linkend="appref">$*</link>使用的是保存在<varname>$IFS</varname>中的第一个字符.  参见<xref
	      linkend="weirdvars">.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo $IFS | cat -vte</userinput>
<computeroutput>$</computeroutput>
<computeroutput>(Show tabs and display "$" at end-of-line.)</computeroutput>



<prompt>bash$ </prompt><userinput>bash -c 'set w x y z; IFS=":-;"; echo "$*"'</userinput>
<computeroutput>w:x:y:z</computeroutput>
<computeroutput>(从字符串中读取命令, 并分配参数给位置参数.)</computeroutput>
	      </screen>
	  </para>

	  <caution><para><varname>$IFS</varname>处理其他字符与处理空白字符不同. 

	  <example id="ifsh">
	    <title>$IFS与空白字符</title>
	    <programlisting>&ifsh;</programlisting>
	  </example>

	  </para></caution>

	  <para>(感谢, S. C., 进行了澄清与举例.)</para> 

	   <para>参见<xref linkend="isspammer">, <xref
	   linkend="bingrep">, 和<xref linkend="mailboxgrep">
             都是展示如何使用<varname>$IFS</varname>的例子.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$IGNOREEOF</varname></term>
	  <indexterm>
	    <primary>$IGNOREEOF</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$IGNOREEOF</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>Ignore EOF</primary>
	  </indexterm>
	  <listitem><para>忽略EOF: 告诉shell在log out之前要忽略多少文件结束符(control-D). </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$LC_COLLATE</varname></term>
	  <indexterm>
	    <primary>$LC_COLLATE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$LC_COLLATE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>lowercase collate</primary>
	  </indexterm>
	  <listitem>

		  <para>常在<filename>.bashrc</filename>或<filename>/etc/profile</filename>中设置, 
			  这个变量用来控制文件名扩展和模式匹配的展开顺序.
			  如果$LC_COLLATE设置得不正确的话, 
			  <varname>LC_COLLATE</varname>会在<link linkend="globbingref">文件名匹配(filename 
				  globbing)</link>中产生不可预料的结果.</para>

	  <note><para>在2.05以后的Bash版本中,
	    文件名匹配(filename globbing)将不在区分中括号结构中的字符范围里字符的大小写. 
	    比如, <command>ls [A-M]*</command>
		既能够匹配为<filename>File1.txt</filename>也能够匹配为<filename>file1.txt</filename>. 
		为了能够恢复中括号里字符的匹配行为(即区分大小写), 
	    可以设置变量<varname>LC_COLLATE</varname>为<option>C</option>, 
		在文件<filename>/etc/profile</filename>或<filename>~/.bashrc</filename>中使用<userinput>export LC_COLLATE=C</userinput>, 
		可以达到这个目的.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$LC_CTYPE</varname></term>
	  <indexterm>
	    <primary>$LC_CTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$LC_CTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>lowercase character type</primary>
	  </indexterm>
	  <listitem>

	  <para>这个内部变量用来控制<link linkend="globbingref">通配(globbing)</link>和模式匹配中的字符串解释. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="linenoref"><varname>$LINENO</varname></term>
	  <indexterm>
	    <primary>$LINENO</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$LINENO</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>line number</primary>
	  </indexterm>
	  <listitem><para>这个变量用来记录自身在脚本中所在的行号. 
			  这个变量只有在脚本使用这个变量的时候才有意义, 
			 并且这个变量一般用于调试目的. </para>
	  <para><programlisting># *** 调试代码块开始 ***
last_cmd_arg=$_  # Save it.

echo "At line number $LINENO, variable \"v1\" = $v1"
echo "Last command argument processed = $last_cmd_arg"
# *** 调试代码块结束 ***</programlisting></para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="machtyperef"><varname>$MACHTYPE</varname></term>
	  <indexterm>
	    <primary>$MACHTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$MACHTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>machine type</primary>
	  </indexterm>
	  <listitem><para>机器类型</para>
	    <para>标识系统的硬件.</para>
	    <screen><prompt>bash$ </prompt><userinput>echo $MACHTYPE</userinput>
<computeroutput>i686</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="oldpwd"><varname>$OLDPWD</varname></term>
	  <indexterm>
	    <primary>$OLDPWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OLDPWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>previous working directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <listitem><para>之前的工作目录(<quote>OLD-print-working-directory</quote>,
	    就是之前你所在的目录)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$OSTYPE</varname></term>
	  <indexterm>
	    <primary>$OSTYPE</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OSTYPE</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>os type</primary>
	  </indexterm>
	  <listitem><para>操作系统类型</para>
	    <screen><prompt>bash$ </prompt><userinput>echo $OSTYPE</userinput>
<computeroutput>linux</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="pathref"><varname>$PATH</varname></term>
	  <indexterm>
	    <primary>$PATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PATH</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>path to binaries</primary>
	  </indexterm>
	  <listitem><para>可执行文件的搜索路径, 
			 一般为<filename class="directory">/usr/bin/</filename>, 
	      <filename class="directory">/usr/X11R6/bin/</filename>, 
	      <filename class="directory">/usr/local/bin</filename>, 等等.</para>

	  <para>当给出一个命令时, shell会自动生成一张哈希(hash)表,  
		  并且在这张哈希表中按照<emphasis>path</emphasis>变量中所列出的路径来搜索这个可执行命令.
		  路径会存储在<link linkend="envref">环境变量</link>中, 
		  <varname>$PATH</varname>变量本身就一个以冒号分隔的目录列表. 
		  通常情况下, 系统都是在<filename>/etc/profile</filename>和<filename>~/.bashrc</filename>中存储<varname>$PATH</varname>的定义.
	      (参考<xref linkend="files">).</para>

	      <para><screen><prompt>bash$ </prompt><command>echo $PATH</command>
<computeroutput>/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</computeroutput></screen>
              </para>

	    <para><userinput>PATH=${PATH}:/opt/bin</userinput>将会把目录<filename class="directory">/opt/bin</filename>附加到当前目录列表中.
			在脚本中, 这是一种把目录临时添加到$PATH中的权宜之计. 
			当这个脚本退出时, <varname>$PATH</varname>将会恢复以前的值(一个子进程, 比如说一个脚本,
			是不能够修改父进程的环境变量的, 在这里也就是不能够修改shell本身的环境变量, 
			-- 译者注: 也就是脚本所运行的这个shell). </para>

	    <note><para>当前的<quote>工作目录</quote>, 
				<filename class="directory">./</filename>, 通常是不会出现在<varname>$PATH</varname>中的, 
				这样做的目的是出于安全的考虑. </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PIPESTATUS</varname></term>
	  <indexterm>
	    <primary>$PIPESTATUS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>pipe</secondary>
	  </indexterm>
	  <listitem>
	  <para>这个<link linkend="arrayref">数组</link>变量将保存最后一个运行的<emphasis>前台</emphasis><link
			  linkend="piperef">管道</link>的退出状态码. 
		  相当有趣的是, 这个退出状态码和最后一个命令运行的<link
	    linkend="exitstatusref">退出状态码</link>并不一定相同. </para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo $PIPESTATUS</userinput>
<computeroutput>0</computeroutput>

<prompt>bash$ </prompt><userinput>ls -al | bogus_command</userinput>
<computeroutput>bash: bogus_command: command not found</computeroutput>
<prompt>bash$ </prompt><userinput>echo $PIPESTATUS</userinput>
<computeroutput>141</computeroutput>

<prompt>bash$ </prompt><userinput>ls -al | bogus_command</userinput>
<computeroutput>bash: bogus_command: command not found</computeroutput>
<prompt>bash$ </prompt><userinput>echo $?</userinput>
<computeroutput>127</computeroutput>
	      </screen>
	      </para>


	      <para><varname>$PIPESTATUS</varname>数组的每个成员都保存了运行在管道中的相应命令的退出状态码. 
		<varname>$PIPESTATUS[0]</varname>保存管道中第一个命令的退出状态码.
		<varname>$PIPESTATUS[1]</varname>保存第二个命令的退出状态码, 依此类推. </para>


	      <caution>
	      <para>
	      <varname>$PIPESTATUS</varname>变量在一个登陆的shell中可能会包含一个不正确<errorcode>0</errorcode>值(在3.0以下版本).
              </para>

	      <para>
	      <screen>
<prompt>tcsh% </prompt><userinput>bash</userinput>

<prompt>bash$ </prompt><userinput>who | grep nobody | sort</userinput>
<prompt>bash$ </prompt><userinput>echo ${PIPESTATUS[*]}</userinput>
<computeroutput>0</computeroutput>
	      </screen>
	      </para>


	      <para>
	      如果一个脚本包含了上边的这行, 那么将会产生我们所期望的<computeroutput>0 1 0</computeroutput>的输出.
              </para>

	      <para>
	      感谢, Wayne Pollock指出这一点并提供了上边的例子. 
	      </para>

	      </caution>


	      <note>

	      <para>在某些上下文中, 变量<varname>$PIPESTATUS</varname>可能不会给出期望的结果. </para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo $BASH_VERSION</userinput>
<computeroutput>3.00.14(1)-release</computeroutput>

<prompt>bash$ </prompt><userinput>$ ls | bogus_command | wc</userinput>
<computeroutput>bash: bogus_command: command not found
 0       0       0</computeroutput>

<prompt>bash$ </prompt><userinput>echo ${PIPESTATUS[@]}</userinput>
<computeroutput>141 127 0</computeroutput>
	      </screen>
	      </para>

		  <para>Chet Ramey把上边输出不正确的原因归咎于<link linkend="lsref">ls</link>的行为. 
			 因为如果把<emphasis>ls</emphasis>的结果放到管道上, 并且这个输出并没有被读取, 
			 那么SIGPIPE将会杀掉它, 同时<link linkend="exitstatusref">退出状态码</link>变为<returnvalue>141</returnvalue>. 
			 而不是我们所期望的<returnvalue>0</returnvalue>. 
		这种情况也会发生在<link
		linkend="trref">tr</link>命令中.</para>

		</note>

		<note>

			<para><varname>$PIPESTATUS</varname>是一个<quote>不稳定</quote>变量. 
				这个变量需要在任何命令干涉之前, 并在管道询问之后立刻被查询. </para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>$ ls | bogus_command | wc</userinput>
<computeroutput>bash: bogus_command: command not found
 0       0       0</computeroutput>

<prompt>bash$ </prompt><userinput>echo ${PIPESTATUS[@]}</userinput>
<computeroutput>0 127 0</computeroutput>

<prompt>bash$ </prompt><userinput>echo ${PIPESTATUS[@]}</userinput>
<computeroutput>0</computeroutput>
	      </screen>
	      </para>
		</note>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="ppidref"><varname>$PPID</varname></term>
	  <indexterm>
	    <primary>$PPID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PPID</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>process ID</primary>
	  </indexterm>
	  <listitem><para></para>
	    <para>进程的<varname>$PPID</varname>就是这个进程的父进程的进程ID(<varname>pid</varname>).

	      <footnote>
	        <para>当然, 当前运行脚本的PID就是<varname>$$</varname></para>
              </footnote>
	      </para>

	    <para>和<link linkend="pidofref">pidof</link>命令比较一下.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PROMPT_COMMAND</varname></term>
	  <indexterm>
	    <primary>$PROMPT_COMMAND</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>prompt</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个变量保存了在主提示符<varname>$PS1</varname>显示之前需要执行的命令. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="ps1ref"><varname>$PS1</varname></term>
	  <indexterm>
	    <primary>$PS1</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS1</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	  </indexterm>
	  <listitem><para>这是主提示符, 可以在命令行中见到它. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS2</varname></term>
	  <indexterm>
	    <primary>$PS2</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS2</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>secondary</secondary>
	  </indexterm>
	  <listitem>
	    <para><anchor id="secpromptref"></para>
	    <para>第二提示符, 当你需要额外输入的时候, 你就会看到它. 默认显示<quote>&gt;</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS3</varname></term>
	  <indexterm>
	    <primary>$PS3</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS3</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>tertiary</secondary>
	  </indexterm>
	  <listitem><para>第三提示符, 它在一个<link linkend="selectref">select</link>循环中显示(参见<xref
	    linkend="ex31">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS4</varname></term>
	  <indexterm>
	    <primary>$PS4</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS4</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>quartenary</secondary>
	  </indexterm>
	  <listitem>
	  <para>第四提示符, 当你使用<token>-x</token><link linkend="optionsref">选项</link>来调用脚本时,
	    这个提示符会出现在每行输出的开头. 默认显示<quote>+</quote>.</para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="pwdref"><varname>$PWD</varname></term>
	  <indexterm>
	    <primary>$PWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>working directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <listitem>
	  <para>工作目录(你当前所在的目录)</para>
	  <para>这与内建命令<link linkend="pwd2ref">pwd</link>作用相同. </para>
          <para><programlisting>&wipedir;</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="replyref"><varname>$REPLY</varname></term>
	  <indexterm>
	    <primary>$REPLY</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$REPLY</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>default value of read</primary>
	  </indexterm>
	  <indexterm>
	    <primary>reply</primary>
	    <secondary>read</secondary>
	  </indexterm>
	  <listitem><para>当没有参数变量提供给<link linkend="readref">read</link>命令的时候, 
			  这个变量会作为默认变量提供给read命令. 
			  也可以用于<link linkend="selectref">select</link>菜单,
	    但是只提供所选择变量的编号, 而不是变量本身的值. </para>
	     <para><programlisting>&reply;</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$SECONDS</varname></term>
	  <indexterm>
	    <primary>$SECONDS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$SECONDS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>seconds execution time</primary>
	  </indexterm>
	  <indexterm>
	    <primary>runtime</primary>
	    <secondary>seconds</secondary>
	  </indexterm>
	  <listitem><para>这个脚本已经运行的时间(以秒为单位).</para>
	     <para><programlisting>&seconds;</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$SHELLOPTS</varname></term>
	  <indexterm>
	    <primary>$SHELLOPTS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$SHELLOPTS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>shell options</primary>
	  </indexterm>
	  <listitem>
	    <para>shell中已经激活的<link
	      linkend="optionsref">选项</link>的列表, 这是一个只读变量.
	      <screen><prompt>bash$ </prompt><userinput>echo $SHELLOPTS</userinput>
<computeroutput>braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$SHLVL</varname></term>
	  <indexterm>
	    <primary>$SHLVL</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$SHLVL</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>shell level</primary>
	  </indexterm>
	  <listitem><para>Shell级别, 就是Bash被嵌套的深度. 
			  如果是在命令行中, 那么$SHLVL为1, 如果在脚本中那么$SHLVL为2. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$TMOUT</varname></term>
	  <indexterm>
	    <primary>$TMOUT</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$TMOUT</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>timeout interval</primary>
	  </indexterm>
	  <listitem><para>如果<replaceable>$TMOUT</replaceable>环境变量被设置为非零值<emphasis>time</emphasis>的话, 
			  那么经过<emphasis>time</emphasis>秒后, shell提示符将会超时. 
			  这将会导致登出(logout).</para>


	  <para>在2.05b版本的Bash中, <replaceable>$TMOUT</replaceable>变量与命令<link linkend="readref">read</link>可以在脚本中结合使用.</para>

	  <para>
	  <programlisting># 只能够在Bash脚本中使用, 必须使用2.05b或之后版本的Bash.

TMOUT=3    # 提示输入时间为3秒.

echo "What is your favorite song?"
echo "Quickly now, you only have $TMOUT seconds to answer!"
read song

if [ -z "$song" ]
then
  song="(no answer)"
  # 默认响应.
fi

echo "Your favorite song is $song."</programlisting>
	  </para>


	  <para>还有更加复杂的办法可以在脚本中实现定时输入.
		一种办法就是建立一个定式循环, 当超时的时候给脚本发个信号. 
	    不过这也需要有一个信号处理例程能够捕捉(参见<xref linkend="ex76">)由定时循环所产生的中断. (哇欧!).</para>

	    <example id="tmdin">
	      <title>定时输入</title>
	      <programlisting>&tmdin;</programlisting>
	    </example>	    

	  <para>另一种选择是使用<link
	    linkend="sttyref">stty</link>.</para>

	    <example id="timeout">
	      <title>再来一个, 定时输入</title>
	      <programlisting>&timeout;</programlisting>
	    </example>	    

	  <para>可能最简单的办法就是使用<option>-t</option>选项来<link
	    linkend="readref">read</link>了.</para>
	    
	    <example id="tout">
	      <title>定时<command>read</command></title>
	      <programlisting>&tout;</programlisting>
	    </example>	    
	   

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="uidref"><varname>$UID</varname></term>
	  <indexterm>
	    <primary>$UID</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$UID</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>user ID</primary>
	  </indexterm>
	  <listitem><para>用户ID号</para>

	    <para>当前用户的用户标识号, 记录在<filename>/etc/passwd</filename>文件中
	    </para>

	    <para>这是当前用户的真实id, 即使只是通过使用<link
	      linkend="suref">su</link>命令来临时改变为另一个用户标识, 这个id也不会被改变.
	      <varname>$UID</varname>是一个只读变量, 不能在命令行或者脚本中修改它, 
	      并且和<link linkend="idref">id</link>内建命令很相像.</para>

            <example id="amiroot">
	      <title>我是root么?</title>
	      <programlisting>&amiroot;</programlisting>
            </example>

	    <para>也请参考一下<xref linkend="ex2">.</para>


	<!-- Nest note within last entry  -->
	<note>
	<para>变量<varname>$ENV</varname>,
	  <varname>$LOGNAME</varname>, <varname>$MAIL</varname>,
	  <varname>$TERM</varname>, <varname>$USER</varname>, 
	  和<varname>$USERNAME</varname>都<emphasis>不是</emphasis>Bash的<link linkend="builtinref">内建</link>变量. 
	  然而这些变量经常在Bash的<link linkend="filesref1">启动文件</link>中被当作<link 
		  linkend="envref">环境变量</link>来设置. 
	  <anchor id="shellvarref"><varname>$SHELL</varname>是用户登陆shell的名字,
	  它可以在<filename>/etc/passwd</filename>中设置, 或者也可以在<quote>init</quote>脚本中设置,
	  并且它也不是Bash内建的.</para>
	      <para>
	      <screen>
<prompt>tcsh% </prompt><userinput>echo $LOGNAME</userinput>
<computeroutput>bozo</computeroutput>
<prompt>tcsh% </prompt><userinput>echo $SHELL</userinput>
<computeroutput>/bin/tcsh</computeroutput>
<prompt>tcsh% </prompt><userinput>echo $TERM</userinput>
<computeroutput>rxvt</computeroutput>

<prompt>bash$ </prompt><userinput>echo $LOGNAME</userinput>
<computeroutput>bozo</computeroutput>
<prompt>bash$ </prompt><userinput>echo $SHELL</userinput>
<computeroutput>/bin/tcsh</computeroutput>
<prompt>bash$ </prompt><userinput>echo $TERM</userinput>
<computeroutput>rxvt</computeroutput>
	      </screen>
	      </para>
	  </note>

	<!-- Nest note after $USER  -->

	  </listitem>
	</varlistentry>


      </variablelist>

	<!-- Last entry of intrinsic BASH variables -->

      <variablelist id="posparmslist">
        <title>位置参数</title>

	<varlistentry>
	  <term><anchor id="posparamref"><varname>$0</varname>, <varname>$1</varname>,
	  <varname>$2</varname>, 等等.</term>
	  <indexterm>
	    <primary>$0</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$0</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	  </indexterm>
	  <listitem>
		  <para>位置参数, 从命令行传递到脚本, 或者传递给函数, 
			  或者<link linkend="setref">set</link>给变量(参见<xref
	      linkend="ex17">和<xref linkend="ex34">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$#</varname></term>
	  <indexterm>
	    <primary>$#</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$#</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>number of</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	    <tertiary>number of</tertiary>
	  </indexterm>
	  <listitem><para>命令行参数
		<footnote><para>术语<quote>argument</quote>和<quote>parameter</quote>通常情况下都可以互换使用. 
				在本书的上下文中, 它们的意思完全相同, 意思都是传递给脚本或者函数的变量, 或者是位置参数. 
		(译者注: 翻译时, 基本上就未加区分.)</para></footnote>
	    或者位置参数的个数(参见<xref linkend="ex4">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="appref"><varname>$*</varname></term>
	  <indexterm>
	    <primary>$*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>all</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	    <tertiary>all</tertiary>
	  </indexterm>
	  <listitem>
	  <para>所有的位置参数都被看作为一个单词.</para>
	  <note><para><quote><varname>$*</varname></quote>必须被引用起来.</para></note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$@</varname></term>
	  <indexterm>
	    <primary>$@</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>all</secondary>
	  </indexterm>

	  <listitem>
	  
	  <para>与<token>$*</token>相同, 但是每个参数都是一个独立的引用字符串, 
		  这就意味着, 参数是被完整传递的, 并没有被解释或扩展. 
		  这也意味着, 参数列表中每个参数都被看作为单独的单词.
	      </para>

	  <note><para>当然, <quote><varname>$@</varname></quote>应该被引用起来.</para></note>

	    <example id="arglist">
	      <title><command>arglist</command>: 通过$*和$@列出所有的参数</title>
	      <programlisting>&arglist;</programlisting>
	    </example>   

	    <para><command>shift</command>命令执行以后, 
	      <varname>$@</varname>将会保存命令行中剩余的参数,  
	      但是没有之前的<varname>$1</varname>,
	      因为被丢弃了.
	        <programlisting>#!/bin/bash
# 使用 ./scriptname 1 2 3 4 5 来调用这个脚本

echo "$@"    # 1 2 3 4 5
shift
echo "$@"    # 2 3 4 5
shift
echo "$@"    # 3 4 5

# 每次"shift"都会丢弃$1.
# "$@" 将包含剩下的参数. </programlisting>
            </para>


	    <para><varname>$@</varname>也可以作为工具使用, 用来过滤传递给脚本的输入. 
			<command>cat "$@"</command>结构既可以接受从<filename>stdin</filename>传递给脚本的输入, 
	      也可以接受从参数中指定的文件中传递给脚本的输入. 参见<xref
	      linkend="rot13">和<xref linkend="cryptoquote"> .</para>


	    <caution><para><varname>$*</varname>和<varname>$@</varname>中的参数有时候会表现出不一致而且令人迷惑的行为, 
	      这都依赖于<link linkend="ifsref">$IFS</link>的设置. </para></caution>

	    <example id="incompat">
	      <title><varname>$*</varname>和<varname>$@</varname>的不一致的行为</title>
	      <programlisting>&incompat;</programlisting>
	    </example>	    

	    <note><para><command>$@</command>与<command>$*</command>中的参数只有在被双引号引用起来的时候才会不同. </para></note>

	    <example id="ifsempty">
	      <title>当<varname>$IFS</varname>为空时的<varname>$*</varname>和<varname>$@</varname></title>
	      <programlisting>&ifsempty;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

    </variablelist>	

      <variablelist id="otherspecparams">
        <title>其他的特殊参数</title>

	<varlistentry>
	  <term><anchor id="flpref"><varname>$-</varname></term>
	  <indexterm>
	    <primary>$-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>flags</primary>
	  </indexterm>
	  <listitem>
	    <para>传递给脚本的标记(使用<link
	      linkend="setref">set</link>命令). 参见<xref linkend="ex34">.</para>
	    <caution><para>这本来是<emphasis>ksh</emphasis>的结构, 后来被引进到Bash中, 但是不幸的是, 
				看起来它不能够可靠的用在Bash脚本中. 一种可能的用法是让一个脚本<link 
					linkend="iitest">测试自身是不是可交互的</link>. </para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$!</varname></term>
	  <indexterm>
	    <primary>$!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>PID</primary>
	    <secondary>last job background</secondary>
	  </indexterm>
	  <listitem>

	    <para>运行在后台的最后一个作业的PID(进程ID)</para>

	    <para>
	      <programlisting>LOG=$0.log

COMMAND1="sleep 100"

echo "Logging PIDs background commands for script: $0" >> "$LOG"
# 所以它们是可以被监控的, 并且可以在必要的时候kill掉它们.
echo >> "$LOG"

# 记录命令.

echo -n "PID of \"$COMMAND1\":  " >> "$LOG"
${COMMAND1} &
echo $! >> "$LOG"
# "sleep 100"的PID:  1506

# 感谢, Jacques Lederer, 对此的建议.</programlisting>
            </para>

            <para>
	      <programlisting>possibly_hanging_job & { sleep ${TIMEOUT}; eval 'kill -9 $!' &> /dev/null; }
# 强制结束一个出错程序.
# 很有用, 比如用在init脚本中.

# 感谢, Sylvain Fourmanoit, 发现了"!"变量的创造性用法.</programlisting>

            </para>


	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="underscoreref"><varname>$_</varname></term>
	  <indexterm>
	    <primary>$_</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$_</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>underscore</primary>
	    <secondary>last argument</secondary>
	  </indexterm>
	  <listitem>
	      <para>这个变量保存之前执行的命令的最后一个参数的值. </para>


      <example id="uscref">
	<title>下划线变量</title>
        <programlisting>#!/bin/bash

echo $_              # /bin/bash
                     # 只是调用/bin/bash来运行这个脚本.

du >/dev/null        # 这么做命令行上将没有输出.
echo $_              # du

ls -al >/dev/null    # 这么做命令行上将没有输出.
echo $_              # -al  (这是最后的参数)

:
echo $_              # :</programlisting></example>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="xstatvarref"><varname>$?</varname></term>
	  <indexterm>
	    <primary>$?</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$?</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>exit status</primary>
	  </indexterm>
	  <listitem><para>命令, <link linkend="functionref">函数</link>,
	    或者是脚本本身的(参见<xref linkend="max">)<link linkend="exitstatusref">退出状态码</link></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="proccid"><varname>$$</varname></term>
	  <indexterm>
	    <primary>$$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>PID</primary>
	    <secondary>of script</secondary>
	  </indexterm>
	  <listitem><para>脚本自身的进程ID. 
			  <varname>$$</varname>变量在脚本中经常用来构造<quote>唯一的</quote>临时文件名(参见<xref linkend="ftpget">, 
				  <xref linkend="online">, <xref linkend="derpm">, 和<xref
	    linkend="selfdestruct">). 这么做通常比调用<link linkend="mktempref">mktemp</link>命令来的简单.</para>
	      
	  </listitem>
	</varlistentry>

    </variablelist>	


    </sect1> <!-- Internal Variables -->

    <sect1 id="String-Manipulation">
      <title>操作字符串</title>

            <para><anchor id="stringmanip"></para> 

	    <para>Bash所支持的字符串操作的数量多的令人惊讶. 
	      但是不幸的是, 这些工具缺乏统一的标准.
		  一些是<link linkend="paramsubref">参数替换</link>的子集, 
		  而另外一些则受到UNIX <link linkend="exprref">expr</link>命令的影响. 
		  这就导致了命令语法的不一致, 还会引起冗余的功能, 但是这些并没有引起混乱. </para>

      <variablelist id="stringlength">
        <title>字符串长度</title>

	<varlistentry>
	  <term>${#string}</term>
	  <indexterm>
	    <primary>string length</primary>
	    <secondary>parameter substitution</secondary>
	  </indexterm>

	  <listitem><para></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr length $string</term>
	  <indexterm>
	    <primary>string length</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <listitem><para></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr "$string" : '.*'</term>
	  <indexterm>
	    <primary>string length</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <listitem>
	  <para>
	  <programlisting>stringZ=abcABC123ABCabc

echo ${#stringZ}                 # 15
echo `expr length $stringZ`      # 15
echo `expr "$stringZ" : '.*'`    # 15</programlisting>
	  </para>
	  </listitem>

	</varlistentry>

      </variablelist>

	    <example id="paragraphspace">
	      <title>在一个文本文件的段落之间插入空行</title>
	      <programlisting>&paragraphspace;</programlisting>
	    </example>

      <variablelist id="lengthsubstring">
        <title>匹配字符串开头的子串长度</title>
	
	<varlistentry>
	  <term>expr match "$string" '$substring'</term>
	  <indexterm>
	    <primary>substring length</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <listitem>
	  <para><replaceable>$substring</replaceable>是一个<link
	    linkend="regexref">正则表达式</link>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr "$string" : '$substring'</term>
	  <indexterm>
	    <primary>substring length</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <listitem>
	  <para><replaceable>$substring</replaceable>是一个正则表达式.</para>
	  <para>

	  <programlisting>stringZ=abcABC123ABCabc
#       |------|

echo `expr match "$stringZ" 'abc[A-Z]*.2'`   # 8
echo `expr "$stringZ" : 'abc[A-Z]*.2'`       # 8</programlisting>
          </para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist id="substringindex">
        <title>索引</title>

	<varlistentry>
	  <term>expr index $string $substring</term>
	  <indexterm>
	    <primary>substring index</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <listitem>

	  <para>在字符串$string中所匹配到的$substring第一次所出现的位置. </para>

	  <para><programlisting>stringZ=abcABC123ABCabc
echo `expr index "$stringZ" C12`             # 6
                                             # C 字符的位置.

echo `expr index "$stringZ" 1c`              # 3
# 'c' (in #3 position) matches before '1'.</programlisting></para>

          <para>这与C语言中的<emphasis>strchr()</emphasis>函数非常相似. </para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist id="substringextraction">
        <title>提取子串</title>

	<varlistentry>
	  <term>${string:position}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>extraction</secondary>
	  </indexterm>

	  <listitem>
	  <para>在<replaceable>$string</replaceable>中从位置<replaceable>$position</replaceable>开始提取子串.</para>
	  <para>如果<varname>$string</varname>是<quote><token>*</token></quote>或者<quote><token>@</token></quote>, 
		  那么将会提取从位置<varname>$position</varname>开始的<link 
			  linkend="posparamref">位置参数</link>. 
	       <footnote><para>这适用于命令行参数或<link
	       linkend="functionref">函数</link>参数. </para></footnote></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string:position:length}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>extraction</secondary>
	  </indexterm>

	  <listitem>
	  <para>在<replaceable>$string</replaceable>中从位置<replaceable>$position</replaceable>开始提取<replaceable>$length</replaceable>长度的子串.</para>
	  <para>
	  <programlisting>stringZ=abcABC123ABCabc
#       0123456789.....
#       0-based indexing.

echo ${stringZ:0}                            # abcABC123ABCabc
echo ${stringZ:1}                            # bcABC123ABCabc
echo ${stringZ:7}                            # 23ABCabc

echo ${stringZ:7:3}                          # 23A
                                             # 提取子串长度为3.



# 能不能从字符串的右边(也就是结尾)部分开始提取子串? 
    
echo ${stringZ:-4}                           # abcABC123ABCabc
# 默认是提取整个字符串, 就象${parameter:-default}一样.
# 然而 . . .

echo ${stringZ:(-4)}                         # Cabc 
echo ${stringZ: -4}                          # Cabc
# 这样, 它就可以工作了.
# 使用圆括号或者添加一个空格可以"转义"这个位置参数.

# 感谢, Dan Jacobson, 指出这点.</programlisting>
	  </para>
	  <para>如果<varname>$string</varname>参数是<quote><token>*</token></quote>或<quote><token>@</token></quote>, 
		  那么将会从<varname>$position</varname>位置开始提取<varname>$length</varname>个位置参数, 
		  但是由于可能没有<varname>$length</varname>个位置参数了, 
		  那么就有几个位置参数就提取几个位置参数. </para>

	  <para>
	  <programlisting>echo ${*:2}          # 打印出第2个和后边所有的位置参数.
echo ${@:2}          # 同上.

echo ${*:2:3}        # 从第2个开始, 连续打印3个位置参数. </programlisting>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr substr $string $position $length</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>extraction expr</secondary>
	  </indexterm>

	  <listitem>
	  
	  <para>在<replaceable>$string</replaceable>中从<replaceable>$position</replaceable>开始提取<replaceable>$length</replaceable>长度的子串.</para>
	  
	  <para>
	  <programlisting>stringZ=abcABC123ABCabc
#       123456789......
#       以1开始计算.

echo `expr substr $stringZ 1 2`              # ab
echo `expr substr $stringZ 4 3`              # ABC</programlisting>
          </para>

	  <para><anchor id="exprparen"></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr match "$string" '\($substring\)'</term>
	  <indexterm>
	    <primary>substring extraction</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <listitem>
	  <para>从<replaceable>$string</replaceable>的开始位置提取<replaceable>$substring</replaceable>,
	    <replaceable>$substring</replaceable>是<link
	    linkend="regexref">正则表达式</link>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr "$string" : '\($substring\)'</term>
	  <indexterm>
	    <primary>substring extraction</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <listitem>

	  <para>从<replaceable>$string</replaceable>的开始位置提取<replaceable>$substring</replaceable>,
	    <replaceable>$substring</replaceable>是正则表达式. </para>

	    <para>
	    <programlisting>stringZ=abcABC123ABCabc
#       =======	    

echo `expr match "$stringZ" '\(.[b-c]*[A-Z]..[0-9]\)'`   # abcABC1
echo `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'`       # abcABC1
echo `expr "$stringZ" : '\(.......\)'`                   # abcABC1
# 上边的每个echo都打印出相同的结果. </programlisting>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr match "$string" '.*\($substring\)'</term>
	  <indexterm>
	    <primary>substring extraction</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <listitem>
	  <para>从<replaceable>$string</replaceable>的<emphasis>结尾</emphasis>提取<replaceable>$substring</replaceable>, 
	    <replaceable>$substring</replaceable>是正则表达式. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>expr "$string" : '.*\($substring\)'</term>
	  <indexterm>
	    <primary>substring extraction</primary>
	    <secondary>expr</secondary>
	  </indexterm>

	  <listitem>

	  <para>从<replaceable>$string</replaceable>的<emphasis>结尾</emphasis>提取<replaceable>$substring</replaceable>, 
	    <replaceable>$substring</replaceable>是正则表达式. </para>

	    <para>
	    <programlisting>stringZ=abcABC123ABCabc
#                ======

echo `expr match "$stringZ" '.*\([A-C][A-C][A-C][a-c]*\)'`    # ABCabc
echo `expr "$stringZ" : '.*\(......\)'`                       # ABCabc</programlisting>

	    </para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist id="substringremoval">
        <title>子串削除</title>
	
	<varlistentry>
	  <term>${string#substring}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>removal</secondary>
	  </indexterm>

	  <listitem>
	  <para>从<replaceable>$string</replaceable>的<emphasis>开头</emphasis>位置截掉最短匹配的<replaceable>$substring</replaceable>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string##substring}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>removal</secondary>
	  </indexterm>

	  <listitem>

	  <para>从<replaceable>$string</replaceable>的<emphasis>开头</emphasis>位置截掉最长匹配的<replaceable>$substring</replaceable>. </para>

	  <para>  
	  <programlisting>stringZ=abcABC123ABCabc
#       |----|
#       |----------|

echo ${stringZ#a*C}      # 123ABCabc
# 截掉'a'到'C'之间最短的匹配字符串.

echo ${stringZ##a*C}     # abc
# 截掉'a'到'C'之间最长的匹配字符串.</programlisting>
	  </para>  
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string%substring}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>removal</secondary>
	  </indexterm>

	  <listitem>
	  <para>从<replaceable>$string</replaceable>的<emphasis>结尾</emphasis>位置截掉最短匹配的<replaceable>$substring</replaceable>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string%%substring}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>removal</secondary>
	  </indexterm>

	  <listitem>

	  <para>从<replaceable>$string</replaceable>的<emphasis>结尾</emphasis>位置截掉最长匹配的<replaceable>$substring</replaceable>. </para>

	  <para>  
	  <programlisting>stringZ=abcABC123ABCabc
#                    ||
#        |------------|

echo ${stringZ%b*c}      # abcABC123ABCa
# 从$stringZ的结尾位置截掉'b'到'c'之间最短的匹配.

echo ${stringZ%%b*c}     # a
# 从$stringZ的结尾位置截掉'b'到'c'之间最长的匹配. </programlisting>
	  </para>  

	  <para>当你需要构造文件名的时候, 这个操作就显得特别有用. </para>

	    <example id="cvt">
	      <title>转换图片文件格式, 同时更改文件名</title>
	      <programlisting>&cvt;</programlisting>
	    </example>

	    <example id="ra2ogg">
	      <title>将音频流文件转换为<emphasis>ogg</emphasis>各式的文件</title>
	      <programlisting>&ra2ogg;</programlisting>
	    </example>

	  <para>一个简单的<link linkend="getopty">getopt</link>命令的模拟, 使用子串提取结构.</para>

	    <example id="getoptsimple">
	      <title>模拟<emphasis>getopt</emphasis></title>
	      <programlisting>&getoptsimple;</programlisting>
	    </example>



	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist id="substringreplacement">
        <title>子串替换</title>

	<varlistentry>
	  <term>${string/substring/replacement}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>replacement</secondary>
	  </indexterm>

	  <listitem>
	  <para>使用<replaceable>$replacement</replaceable>来替换第一个匹配的<replaceable>$substring</replaceable>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string//substring/replacement}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>replacement</secondary>
	  </indexterm>

	  <listitem>

		  <para>使用<replaceable>$replacement</replaceable>来替换所有匹配的<replaceable>$substring</replaceable>.</para>

	  <para>  
	  <programlisting>stringZ=abcABC123ABCabc

echo ${stringZ/abc/xyz}           # xyzABC123ABCabc
                                  # 使用'xyz'来替换第一个匹配的'abc'.

echo ${stringZ//abc/xyz}          # xyzABC123ABCxyz
                                  # 用'xyz'来替换所有匹配的'abc'.</programlisting>
	  </para>  

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string/#substring/replacement}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>replacement</secondary>
	  </indexterm>

	  <listitem>
		  <para>如果<replaceable>$substring</replaceable>匹配<replaceable>$string</replaceable>的<emphasis>开头部分</emphasis>, 
			 那么就用<replaceable>$replacement</replaceable>来替换<replaceable>$substring</replaceable>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>${string/%substring/replacement}</term>
	  <indexterm>
	    <primary>substring</primary>
	    <secondary>replacement</secondary>
	  </indexterm>

	  <listitem>

		  <para>如果<replaceable>$substring</replaceable>匹配<replaceable>$string</replaceable>的<emphasis>结尾部分</emphasis>, 
			 那么就用<replaceable>$replacement</replaceable>来替换<replaceable>$substring</replaceable>.</para>

	  <para>  
          <programlisting>stringZ=abcABC123ABCabc

echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
                                  # 用'XYZ'替换开头的'abc'.

echo ${stringZ/%abc/XYZ}          # abcABC123ABCXYZ
                                  # 用'XYZ'替换结尾的'abc'.</programlisting>
	  </para>  

	  </listitem>
	</varlistentry>

      </variablelist>

    <sect2 id="awkstringmanip">
      <title>使用awk来处理字符串</title>

          <para>Bash脚本也可以调用<link linkend="awkref">awk</link>的字符串操作功能来代替它自己内建的字符串操作. </para>

	    <example id="substringex">
	      <title>提取字符串的另一种方法</title>
	      <programlisting>&substringex;</programlisting>
	    </example>

    </sect2> <!-- Manipulating strings using awk -->



    <sect2 id="strfdisc">
      <title>更深入的讨论</title>
   
     <para>如果想了解关于在脚本中使用字符串的更多细节, 请参考<xref
			 linkend="Parameter-Substitution">和<link linkend="exprref">expr</link>命令列表的<link 
				 linkend="expextrsub">相关章节</link>. 
			 相关脚本的例子, 参见: <orderedlist>
         <listitem><para><xref linkend="ex45"></para></listitem>
	 <listitem><para><xref linkend="length"></para></listitem>
	 <listitem><para><xref linkend="pattmatching"></para></listitem>
         <listitem><para><xref linkend="rfe"></para></listitem>
         <listitem><para><xref linkend="varmatch"></para></listitem>
       </orderedlist>
      </para>	 

    </sect2> <!-- Further Discussion -->
    


    </sect1> <!-- Manipulating Strings -->



    <sect1 id="Parameter-Substitution">
      <title>参数替换</title>

            <para><anchor id="paramsubref"></para> 

            <variablelist id="pssub">
	      <title><anchor id="pssub1">处理和(或)扩展变量</title>
	      <varlistentry>
		<term>
		  <userinput>${parameter}</userinput></term>
		<listitem>

		<para>与<replaceable>$parameter</replaceable>相同, 
		  也就是变量<replaceable>parameter</replaceable>的值.
		  在某些上下文中, <replaceable>${parameter}</replaceable>很少会产生混淆. </para>

		<para>可以把变量和字符串组合起来使用. </para>

	        <para><programlisting>
your_id=${USER}-on-${HOSTNAME}
echo "$your_id"
#
echo "Old \$PATH = $PATH"
PATH=${PATH}:/opt/bin  #在脚本的生命周期中, /opt/bin会被添加到$PATH变量中.
echo "New \$PATH = $PATH"
</programlisting></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>${parameter-default}</userinput></term>
		<term><userinput>${parameter:-default}</userinput></term>
		<listitem>
		<para>${parameter-default} -- 如果变量parameter没被声明, 那么就使用默认值.</para>
		<para>${parameter:-default} -- 如果变量parameter没被设置, 那么就使用默认值.</para>
		<para><programlisting>
echo ${username-`whoami`}
# 如果变量$username还没有被声明, 那么就echoe出`whoami`的结果(译者注: 也就是把'whoami'的结果赋值给变量$username). </programlisting></para>

		<note><para><replaceable>${parameter-default}</replaceable>
				和<replaceable>${parameter:-default}</replaceable>在绝大多数的情况下都是相同的. 
				只有在<emphasis>parameter</emphasis>已经被声明, 但是被赋null值得时候, 
				这个额外的<token>:</token>才会产生不同的结果. </para></note>

		<para><programlisting>&paramsub;</programlisting></para>

		<para>如果脚本并没有接收到来自命令行的参数, 
			那么<emphasis>默认参数</emphasis>结构将会提供一个默认值给脚本. </para>

		<para>
		  <programlisting>DEFAULT_FILENAME=generic.data
filename=${1:-$DEFAULT_FILENAME}
#  如果没有指定值, 那么下面的代码块将会使用filename
#+ 变量的默认值"generic.data".
#
#  后续的命令. </programlisting>
		</para>

		<para>参考<xref linkend="ex58">, <xref
		  linkend="ex73">, 和<xref linkend="collatz">.</para>

                <para>与<link linkend="anddefault">使用一个<emphasis>与列表</emphasis>来提供一个默认的命令行参数</link>的方法相比较.</para>

		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>${parameter=default}</userinput></term>
		<term><userinput>${parameter:=default}</userinput></term>
		<listitem>
		<para><anchor id="defparam"></para>
			<para>${parameter=default} -- 如果变量parameter没声明, 那么就把它的值设为default. </para> 
			<para>${parameter:=default} -- 如果变量parameter没设置, 那么就把它的值设为default. </para> 

		<para>这两种形式基本上是一样的. 只有在变量<emphasis>$parameter</emphasis>被声明并且被设置为null值的时候, 
			<token>:</token>才会引起这两种形式的不同.
		    <footnote>
				<para>如果在一个非交互脚本中, $parameter被设置为null的话, 
					那么这个脚本将会返回<link 
						linkend="exitcodesref"><returnvalue>127</returnvalue>作为退出状态码</link>(127返回码对应的Bash错误码为命令未发现<quote>command not found</quote>).</para>
		      </footnote>
		  如上边所示.
		    </para>

		<para><programlisting>
echo ${username=`whoami`}
# 变量"username"现在被赋值为`whoami`.</programlisting></para>
	      </listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>${parameter+alt_value}</userinput></term>
		<term><userinput>${parameter:+alt_value}</userinput></term>
		<listitem>
			<para>${parameter+alt_value} -- 如果变量parameter被声明了, 
				那么就使用<userinput>alt_value</userinput>, 否则就使用null字符串.</para>
			<para>${parameter:+alt_value} -- 如果变量parameter被设置了, 
				那么就使用<userinput>alt_value</userinput>, 否则就使用null字符串.</para>

			<para>这两种形式绝大多数情况下都一样. 只有在<emphasis>parameter</emphasis>被声明并且设置为null值的时候, 
				多出来的这个<token>:</token>才会引起这两种形式的不同, 具体请看下边的例子. </para>

		  <para><programlisting>echo "###### \${parameter+alt_value} ########"
echo

a=${param1+xyz}
echo "a = $a"      # a =

param2=
a=${param2+xyz}
echo "a = $a"      # a = xyz

param3=123
a=${param3+xyz}
echo "a = $a"      # a = xyz

echo
echo "###### \${parameter:+alt_value} ########"
echo

a=${param4:+xyz}
echo "a = $a"      # a =

param5=
a=${param5:+xyz}
echo "a = $a"      # a =
# 产生与a=${param5+xyz}不同的结果.

param6=123
a=${param6:+xyz}
echo "a = $a"      # a = xyz</programlisting></para>

		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><anchor id="qerrmsg"><userinput>${parameter?err_msg}</userinput></term>
		<term><userinput>${parameter:?err_msg}</userinput></term>
		<listitem>
			<para>${parameter?err_msg} -- 如果parameter已经被声明, 那么就使用设置的值, 否则打印err_msg错误消息.</para>
			<para>${parameter:?err_msg} -- 如果parameter已经被设置, 那么就使用设置的值, 否则打印err_msg错误消息.</para>
			<para>这两种形式绝大多数情况都是一样的. 和上边所讲的情况一样, 
				只有在<emphasis>parameter</emphasis>被声明并设置为null值的时候, 
				多出来的<token>:</token>才会引起这两种形式的不同. </para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <example id="ex6">
	      <title>使用参数替换和错误消息</title>
	      <programlisting>&ex6;</programlisting>
	    </example>

	    <example id="usagemessage">
	      <title>参数替换和<quote>usage</quote>消息(译者注: 通常就是帮助信息)</title>
	      <programlisting>&usagemessage;</programlisting>
	    </example>

	    
	    
            <formalpara><title>参数替换与(或)扩展</title>
	      
	      <para><anchor id="psub2">下边这些表达式都是对如何<replaceable>在</replaceable><command>expr</command>字符串操作中进行<command>match</command>的补充.
		参考<xref linkend="ex45">).
		这些特定的使用方法一般都用来解析文件所在的目录名. </para></formalpara>

	    <variablelist id="psorex">
              <title><anchor id="psorex1">变量长度/子串删除</title>

	      <varlistentry>

		<term><userinput>${#var}</userinput></term>
		<listitem>
			<para><userinput>字符串长度</userinput>(变量<varname>$var</varname>得字符个数). 
				对于<link linkend="arrayref">array</link>来说,
		    <command>${#array}</command>表示的是数组中第一个元素的长度. </para>

		  <note><para>
		    例外情况:

		  <itemizedlist>
		    <listitem><para>
		      <command>${#*}</command>和<command>${#@}</command>表示<emphasis>位置参数的个数</emphasis>.
		    </para></listitem>
		  
		    <listitem><para>
				对于数组来说, 
				<command>${#array[*]}</command>和<command>${#array[@]}</command>表示数组中元素的个数.
		    </para></listitem>
		  </itemizedlist>
		  </para></note>

	      <example id="length">
	        <title>变量长度</title>
	        <programlisting>&length;</programlisting>
	      </example>	    

		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>${var#Pattern}</userinput></term>
		<term><userinput>${var##Pattern}</userinput></term>

		<listitem>
		<para>从变量<varname>$var</varname>的<replaceable>开头</replaceable>删除最短或最长匹配<varname>$Pattern</varname>的子串.
			(译者注: 这是一个很常见的用法, 请读者牢记, 一个<quote>#</quote>表示匹配最短, <quote>##</quote>表示匹配最长.)
		</para>
		  
		<para><xref linkend="daysbetween">中的一个用法示例:
<programlisting># 摘自例子"days-between.sh"的一个函数.
# 去掉传递进来参数开头的0.

strip_leading_zero () #  去掉从参数中传递进来的,
{                     #+ 可能存在的开头的0(也可能有多个0).
  return=${1#0}       #  "1"表示的是"$1" -- 传递进来的参数.
}                     #  "0"就是我们想从"$1"中删除的子串 -- 去掉零.</programlisting>
		</para>

		<para>下边是Manfred Schwarb给出的一个更加详细的例子:
			<programlisting>strip_leading_zero2 () # 去掉开头可能存在的0(也可能有多个0), 因为如果不取掉的话,
{                      # Bash就会把这个值当作8进制的值来解释. 
  shopt -s extglob     # 打开扩展的通配(globbing).
  local val=${1##+(0)} # 使用局部变量, 匹配最长连续的一个或多个0.
  shopt -u extglob     # 关闭扩展的通配(globbing).
  _strip_leading_zero2=${val:-0}
                       # 如果输入为0, 那么返回0来代替"".
}</programlisting>
		</para>


		<para>另一个用法示例: 
<programlisting>echo `basename $PWD`        # 当前工作目录的basename(就是去掉目录名).
echo "${PWD##*/}"           # 当前工作目录的basename(就是去掉目录名). 
echo
echo `basename $0`          # 脚本名字.
echo $0                     # 脚本名字.
echo "${0##*/}"             # 脚本名字.
echo
filename=test.data
echo "${filename##*.}"      # data
                            # 文件扩展名.</programlisting>
		</para>
		  
		  </listitem>

	      </varlistentry>
	      
	      <varlistentry>
		<term><anchor id="pctpatref"><userinput>${var%Pattern}</userinput></term>
		<term><userinput>${var%%Pattern}</userinput></term>

		<listitem><para>从变量<varname>$var</varname>的<replaceable>结尾</replaceable>删除最短或最长匹配<varname>$Pattern</varname>的子串.
			(译者注: 这是一个很常见的用法, 请读者牢记, 一个<quote>%</quote>表示匹配最短, <quote>%%</quote>表示匹配最长.)
		  </para></listitem>

	      </varlistentry>
	    </variablelist>
	    
	    <para>Bash的<link linkend="bash2ref">版本2</link>添加了一些额外选项. </para>

	    <example id="pattmatching">
	      <title>参数替换中的模式匹配</title>
	      <programlisting>&pattmatching;</programlisting>
	    </example>


	    <example id="rfe">
	      <title>修改文件扩展名<token>:</token></title>
	      <programlisting>&rfe;</programlisting>
	    </example>

	    
	    <variablelist id="exprepl">
	      <title><anchor id="exprepl1">变量扩展/子串替换</title>
	      
	      <varlistentry>
	      <term></term>
	      <listitem>
	        <para>这些结构都是从<emphasis>ksh</emphasis>中引入的.</para>
	      </listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>${var:pos}</userinput></term>
		<listitem>
		  <para>变量<replaceable>var</replaceable>从位置<replaceable>pos</replaceable>开始扩展(译者注: 也就是pos之前的字符都丢弃).
		  </para>
		  </listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var:pos:len}</userinput></term>
		<listitem>
			<para>变量<replaceable>var</replaceable>从位置<replaceable>pos</replaceable>开始, 
				并扩展<replaceable>len</replaceable>个字符.
		    参考<xref linkend="pw">, 这个例子展示了这种操作的一个创造性的用法. 
		  </para>
		  </listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var/Pattern/Replacement}</userinput></term>
		<listitem>
			<para>使用<replaceable>Replacement</replaceable>来替换变量<replaceable>var</replaceable>中第一个匹配<replaceable>Pattern</replaceable>的字符串. 
			</para>
			<para>如果省略<replaceable>Replacement</replaceable>, 
				那么第一个匹配<replaceable>Pattern</replaceable>的字符串将被替换为<emphasis>空</emphasis>, 也就是被删除了.</para>
		  </listitem>  
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var//Pattern/Replacement}</userinput></term>
		<listitem>

                  <formalpara><title>全局替换</title>
		  <para>所有在变量<replaceable>var</replaceable>匹配<replaceable>Pattern</replaceable>的字符串,
		    都会被替换为<replaceable>Replacement</replaceable>. </para>
		    </formalpara>

			<para>和上边一样, 如果省略<replaceable>Replacement</replaceable>, 
				那么所有匹配<replaceable>Pattern</replaceable>的字符串, 
			   都将被替换为<emphasis>空</emphasis>, 也就是被删除掉. </para>
	    
	    <example id="ex7">
	      <title>使用模式匹配来解析任意字符串</title>
	      <programlisting>&ex7;</programlisting>
	    </example>

		  </listitem>
	      </varlistentry>	

	      <varlistentry>
		<term><userinput>${var/#Pattern/Replacement}</userinput></term>
		<listitem>
			<para>如果变量<replaceable>var</replaceable>的<emphasis>前缀</emphasis>匹配<replaceable>Pattern</replaceable>, 
				那么就使用<replaceable>Replacement</replaceable>来替换匹配到<replaceable>Pattern</replaceable>的字符串.</para>
		</listitem>
	      </varlistentry>	

	      <varlistentry>
		<term><userinput>${var/%Pattern/Replacement}</userinput></term>
		<listitem>
			<para>如果变量<replaceable>var</replaceable>的<emphasis>后缀</emphasis>匹配<replaceable>Pattern</replaceable>, 
			那么就使用<replaceable>Replacement</replaceable>来替换匹配到<replaceable>Pattern</replaceable>的字符串.</para>

	    <example id="varmatch">
	      <title>对字符串的前缀和后缀使用匹配模式</title>
	      <programlisting>&varmatch;</programlisting>
	    </example>

		</listitem>
	      </varlistentry>	

	      <varlistentry>
		<term><userinput>${!varprefix*}</userinput></term>
		<term><userinput>${!varprefix@}</userinput></term>
		<listitem>
		  <para>匹配所有之前声明过的, 并且以<emphasis>varprefix</emphasis>开头的变量.
		      <programlisting>xyz23=whatever
xyz24=

a=${!xyz*}      # 展开所有以"xyz"开头的, 并且之前声明过的变量名.
echo "a = $a"   # a = xyz23 xyz24
a=${!xyz@}      # 同上.
echo "a = $a"   # a = xyz23 xyz24

# Bash, 版本2.04, 添加了这个功能.</programlisting>
                  </para>

		  </listitem>
	      </varlistentry>	

	    </variablelist>

    </sect1> <!-- Parameter Substitution -->  



      <sect1 id="declareref">

	<indexterm>
	  <primary>declare</primary>
	</indexterm>
	<indexterm>
	  <primary>typeset</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>declare</secondary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>typeset</secondary>
	</indexterm>
	<title>指定变量的类型: 使用<command>declare</command>或者<command>typeset</command></title>
	
	<para><firstterm>declare</firstterm>或者<firstterm>typeset</firstterm><link
		linkend="builtinref">内建</link>命令(这两个命令是完全一样的)允许指定变量的具体类型. 
	在某些编程语言中, 这是指定变量类型的一种很弱的形式. 
	<command>declare</command>命令是从Bash 2.0之后才被引入的命令.
	  <command>typeset</command>也可以用在ksh的脚本中. </para>

	<variablelist id="declareopsref">
	  <title><anchor id="declareopsref1">declare/typeset选项</title>

	  <varlistentry>
	    <term><token>-r</token> <replaceable>只读</replaceable></term>
	    <listitem><para><programlisting>declare -r var1</programlisting></para>
	      <para>(<userinput>declare -r var1</userinput>与<userinput>readonly var1</userinput>是完全一样的)</para>
		  <para>这和C语言中的<command>const</command>关键字一样, 都用来指定变量为只读. 
			  如果你尝试修改一个只读变量的值, 那么会产生错误信息. </para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-i</token> <replaceable>整型</replaceable></term>

	    <listitem>

	      <para><programlisting>declare -i number
# 脚本将会把变量"number"按照整型进行处理. 

number=3
echo "Number = $number"     # Number = 3

number=three
echo "Number = $number"     # Number = 0
# 脚本尝试把字符串"three"作为整数来求值(译者注: 当然会失败, 所以出现值为0). </programlisting></para>
		
			  <para>如果把一个变量指定为整型的话, 
				  那么即使没有<link linkend="exprref">expr</link>或者<link
		linkend="letref">let</link>命令, 也允许使用特定的算术运算.</para>

              <para><programlisting>n=6/3
echo "n = $n"       # n = 6/3

declare -i n
n=6/3
echo "n = $n"       # n = 2</programlisting></para>
		
		</listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-a</token> <replaceable>数组</replaceable></term>
	    <listitem><para><programlisting>declare -a indices</programlisting></para>
	      <para>变量<varname>indices</varname>将被视为数组.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-f</token> <replaceable>函数</replaceable></term>
	    <listitem>

	      <para><programlisting>declare -f</programlisting></para>
	      <para>如果在脚本中使用<userinput>declare -f</userinput>, 而不加任何参数的话, 
		那么将会列出这个脚本之前定义的所有函数. </para>

	      <para><programlisting>declare -f function_name</programlisting></para>
		  <para>如果在脚本中使用<userinput>declare -f function_name</userinput>这种形式的话, 
			  将只会列出这个函数的名字. </para>

            </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><token>-x</token> <link linkend="exportref">export</link></term>
	      <listitem><para><programlisting>declare -x var3</programlisting></para>
	      <para>这句将会声明一个变量, 并作为这个脚本的环境变量被导出. </para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-x var=$value</term>
	      <listitem>
	        <para><programlisting>declare -x var3=373</programlisting></para>
		<para><command>declare</command>命令允许在声明变量类型的同时给变量赋值. </para>
	      </listitem>
	  </varlistentry>
	      

	</variablelist>

	<example id="ex20">
	  <title>使用<command>declare</command>来指定变量的类型</title>
	  <programlisting>&ex20;</programlisting>
	</example>


        <caution>

	<para>使用<emphasis>declare</emphasis>内建命令可以限制变量的<firstterm>作用域</firstterm>.

	  <programlisting>foo ()
{
FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar   # 打印bar. </programlisting></para>

      <para>然而 . . .

	  <programlisting>foo (){
declare FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar  # 什么都不打印.


# 感谢, Michael Iatrou, 指出这点. </programlisting></para>

        </caution>

      </sect1> <!-- Typing variables: declare or typeset -->


      <sect1 id="ivr">
        <title>变量的间接引用</title>

	<para><anchor id="ivrref"></para>

		<para>假设一个变量的值是第二个变量的名字. 
			那么我们如何从第一个变量中取得第二个变量的值呢?
		比如, 如果<replaceable>a=letter_of_alphabet</replaceable>并且<replaceable>letter_of_alphabet=z</replaceable>,
		那么我们能够通过引用变量<replaceable>a</replaceable>来获得<replaceable>z</replaceable>么? 
		这确实是可以做到的, 它被称为<emphasis>间接引用</emphasis>. 
		它使用<replaceable>eval var1=\$$var2</replaceable>这种不平常的形式. </para>

      <example id="indref">
	<title>间接引用</title>
	<programlisting>&indref;</programlisting>
      </example>


	  <para>变量的间接引用到底有什么应用价值?
		  它给Bash添加了一种类似于<firstterm>C</firstterm>语言<firstterm>指针</firstterm>的功能,
	  比如, 在<link linkend="resistor">表格查找</link>中的用法.
	  另外, 还有一些其他非常有趣的应用. . . .</para>

        <para>
			Nils Radtke展示了如何建立<quote>动态</quote>变量名并取出它们的值. 
		当使用<link linkend="sourceref">source</link>命令加载配置文件的时候, 很有用.
           
	   <programlisting>#!/bin/bash


# --------------------------------------------------------
# 这部分内容可以用单独文件通过使用"source"命令来单独加载. 
isdnMyProviderRemoteNet=172.16.0.100
isdnYourProviderRemoteNet=10.0.0.10
isdnOnlineService="MyProvider"
# --------------------------------------------------------
      

remoteNet=$(eval "echo \$$(echo isdn${isdnOnlineService}RemoteNet)")
remoteNet=$(eval "echo \$$(echo isdnMyProviderRemoteNet)")
remoteNet=$(eval "echo \$isdnMyProviderRemoteNet")
remoteNet=$(eval "echo $isdnMyProviderRemoteNet")

echo "$remoteNet"    # 172.16.0.100

# ================================================================

#  能够做得更好.

#  注意下面的脚本, 给出了变量getSparc,
#+ 但是没有变量getIa64:

chkMirrorArchs () { 
  arch="$1";
  if [ "$(eval "echo \${$(echo get$(echo -ne $arch |
       sed 's/^\(.\).*/\1/g' | tr 'a-z' 'A-Z'; echo $arch |
       sed 's/^.\(.*\)/\1/g')):-false}")" = true ]
  then
     return 0;
  else
     return 1;
  fi;
}

getSparc="true"
unset getIa64
chkMirrorArchs sparc
echo $?        # 0
               # True

chkMirrorArchs Ia64
echo $?        # 1
               # False

# 注意:
# -----
# 变量名中由替换命令产生的部分被准确地生成了. 
# chkMirrorArchs函数的参数全都是小写字母. 
# 新产生的变量名由两部分组成: "get"和"Sparc" . . .
# (译者注: 此处是将chkMirrorArchs函数参数的第一个字母转为大写, 然后与"get"组合形成新的变量名. )</programlisting>
        </para>



      <example id="coltotaler2">
	<title>传递一个间接引用给<replaceable>awk</replaceable></title>
	<programlisting>&coltotaler2;</programlisting>
      </example>

      <caution><para>这种使用间接引用的方法是一个小技巧.
			  如果第二个变量更改了它的值, 那么第一个变量必须被适当的解除引用(就像上边的例子一样). 
			  <anchor id="ivr2">幸运的是, 
			  在Bash<link linkend="bash2ref">版本2</link>中引入的<replaceable>${!variable}</replaceable>形式使得使用间接引用更加直观了. 
			  (参考<xref linkend="ex78">和<xref linkend="hashex2">). 
	 </para></caution>

     
     <sidebar>
		 <para>Bash并不支持指针运算操作, 因此这极大的限制了间接引用的使用. 
			 事实上, 在脚本语言中, 间接引用是一个蹩脚的东西. </para>
     </sidebar>

      </sect1> <!-- 变量的间接引用 -->


      <sect1 id="randomvar">

	<indexterm>
	  <primary>$RANDOM</primary>
	</indexterm>
	<indexterm>
	  <primary>variable</primary>
	  <secondary>$RANDOM</secondary>
	</indexterm>
	<title>$RANDOM: 产生随机整数</title>
	<para><varname>$RANDOM</varname>是Bash的内部<link
			linkend="functionref">函数</link> (并不是常量), 
		这个函数将返回一个<firstterm>伪随机</firstterm>

		<footnote><para>真正的<quote>随机事件, 
				</quote>在它存在的范围内, 只发生在特定的几个未知的自然界现象中, 
	    比如放射性衰变. 计算机只能产生模拟的随机事件, 
		并且计算机产生的<quote>随机</quote>数只能称为<emphasis>伪随机数</emphasis>. 
	</para></footnote>

	整数, 范围在0 - 32767之间. 它<replaceable>不</replaceable>应该被用来产生密匙. 
	</para>

	<example id="ex21">
	  <title>产生随机整数</title>
	  <programlisting>&ex21;</programlisting>
	</example>

	<example id="pickcard">
	  <title>从一幅扑克牌中取出一张随机的牌</title>
	  <programlisting>&pickcard;</programlisting>
	</example>



	<para>
	<emphasis>Jipe</emphasis>展示了一套技巧来在一个指定范围内产生随机数. 

	<programlisting>#  在6 到 30之间产生随机数.
   rnumber=$((RANDOM%25+6))	

#  还是在6 - 30之间产生随机数,
#+ 但是这个数还必须能够被3整除.
   rnumber=$(((RANDOM%30/3+1)*3))

#  注意, 并不是在所有情况下都能正确运行.
#  如果$RANDOM返回0, 那么就会失败.

#  Frank Wang 建议用下边的方法:
   rnumber=$(( RANDOM%27/3*3+6 ))</programlisting>
	</para>


	<para>
	<emphasis>Bill Gradwohl</emphasis>给出了一个改良公式, 这个公式只适用于正书.
	<programlisting>rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))</programlisting>
	</para>

	<para>这里Bill展示了一个通用公式, 
	  这个函数返回两个指定值之间的随机数. </para>

	<example id="randombetween">
	  <title>两个指定值之间的随机数</title>
	  <programlisting>&randombetween;</programlisting>
	</example>



	<para><varname>$RANDOM</varname>到底有多随机? 
	  最好的方法就是编写脚本来测试一下, 跟踪<varname>$RANDOM</varname>所产生的<quote>随机</quote>数的分布情况.
	  让我们用<varname>$RANDOM</varname>来摇骰子. . .</para>

	<example id="randomtest">
	  <title>用随机数来摇单个骰子</title>
	  <programlisting>&randomtest;</programlisting>
	</example>

	<para>就像我们在上边的例子中所看到的, 最好在每次产生<varname>RANDOM</varname>的时候都使用新的种子.
	  因为如果使用同样种子的话, 那么<varname>RANDOM</varname>将会产生相同的序列.
	    <footnote>
	    <para>计算机用来产生伪随机数的<firstterm>种子</firstterm>可以被看成是一种标识标签. 
			比如, 使用种子<emphasis>23</emphasis>所产生的随机序列就被称为<emphasis>序列 #23</emphasis>.
		</para>
		<para>一个伪随机序列的特点就是在这个序列开始重复之前的所有元素个数的总和,
			也就是这个序列的长度. 一个好的伪随机产生算法可以产生一个非常长的不重复序列.
		</para>
	    </footnote>
		(<firstterm>C</firstterm>语言中的<replaceable>random()</replaceable>函数也会有这样的行为.)
	</para>

	<example id="seedingrandom">
	  <title>重新分配随机数种子</title>
	  <programlisting>&seedingrandom;</programlisting>
	</example>

	<para><anchor id="urandomref"></para>
	<note>
	<para><filename>/dev/urandom</filename>设备文件提供了一种比单独使用$RANDOM更好的, 能够产生更加<quote>随机</quote>的随机数的方法.
	  <userinput>dd if=/dev/urandom of=targetfile
	  bs=1 count=XX</userinput>能够产生一个很分散的伪随机数序列. 
	  然而, 如果想要将这个数赋值到一个脚本文件的变量中, 还需要可操作性, 
	  比如使用<link linkend="odref">od</link>命令 
	  (就像上边的例子, 还有<xref linkend="rnd">), 
		  或者使用<link linkend="ddref">dd</link>命令 
		  (参见<xref linkend="blotout">),
	  或者通过管道传递到<link linkend="md5sumref">md5sum</link>命令中
	  (参见<xref linkend="horserace">).</para>

        <para><anchor id="awkrandomref"></para>
	  
			<para>当然还有其他的产生伪随机数的方法. 
				<command>awk</command>就能提供一个方便的方法来做到这点. 
			</para>

	    <example id="random2">
	      <title>使用<link linkend="awkref">awk</link>来产生伪随机数</title>
	      <programlisting>&random2;</programlisting>
	    </example>

		<para><link linkend="dateref">date</link>命令也可以用来<link linkend="daterandref">产生伪随机整数序列</link>.
		</para>

	  </note>



      </sect1> <!-- RANDOM: generate random integer -->


      <sect1 id="dblparens">
        <title>双圆括号结构</title>

	<para>与<link linkend="letref">let</link>命令很相似,
	  <command>((...))</command>结构允许算术扩展和赋值. 
	  举个简单的例子, <userinput>a=$(( 5 + 3 ))</userinput>, 
	  将把变量<quote>a</quote>设为<quote>5 + 3</quote>, 或者8. 
	  然而, 双圆括号结构也被认为是在Bash中使用C语言风格变量操作的一种处理机制.
  </para>

      <example id="cvars">
	<title>C语言风格的变量操作</title>
	<programlisting>&cvars;</programlisting>
      </example>

        <para>参见<xref linkend="forloopc">.</para>


      </sect1> <!-- The Double Parentheses Construct  -->
      

  </chapter> <!-- Variables Revisited -->


  <chapter id="loops">
    <title>循环与分支</title>


      <para>对代码块的操作是构造和组织shell脚本的关键. 循环和分支结构为脚本编程提供了操作代码块的工具. </para>

      <sect1 id="loops1">
        <title>循环</title>

		<para><firstterm>循环</firstterm>就是<firstterm>迭代</firstterm>(重复)一些命令的代码块, 如果<firstterm>循环控制条件</firstterm>不满足的话, 就结束循环.
		</para>


      <variablelist id="forloopref">
        <title><anchor id="forloopref1">for循环</title>

	<varlistentry>
	  <term><command>for <varname>arg</varname> in <replaceable>[list]</replaceable></command></term>
	  <indexterm>
	    <primary>for</primary>
	  </indexterm>
	  <indexterm>
	    <primary>in</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>for</secondary>
	  </indexterm>
	  <listitem>
	    <para>这是一个基本的循环结构. 它与C语言中的for循环结构有很大的不同.
	      </para>

	    <para><cmdsynopsis>
		<command>for</command>
		<arg choice="plain"><replaceable>arg</replaceable></arg>
		<arg choice="plain">in</arg>
		<arg choice="opt"><replaceable>list</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg rep=repeat choice=plain><replaceable>&nbsp;command(s)</replaceable></arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>

		  <note><para>在循环的每次执行中, 
				  <replaceable>arg</replaceable>将顺序的访问<replaceable>list</replaceable>中列出的变量.
		  </para></note>

	    <para><programlisting>for arg in "$var1" "$var2" "$var3" ... "$varN"  
# 在第1次循环中, arg = $var1	    
# 在第2次循环中, arg = $var2	    
# 在第3次循环中, arg = $var3	    
# ...
# 在第N此循环中, arg = $varN

# 在[list]中的参数加上双引号是为了阻止单词分割.</programlisting></para>

	    
	    <para><replaceable>list</replaceable>中的参数允许包含通配符. </para>

	    <para><anchor id="needsemicolon"></para>
			<para>如果<firstterm>do</firstterm>和<firstterm>for</firstterm>想在同一行中出现,
				那么在它们之间需要添加一个分号. </para>

	    <para><cmdsynopsis>
		<command>for</command>
		<arg choice="plain"><replaceable>arg</replaceable></arg>
		<arg choice="plain">in</arg>
		<arg choice="opt"><replaceable>list</replaceable></arg>
		<arg choice="plain">;</arg>
		<arg choice="plain">do</arg><sbr>
	      </cmdsynopsis></para>

	    <example id="ex22">
	      <title>一个简单的<command>for</command>循环</title>
	      <programlisting>&ex22;</programlisting>
	    </example>

            
	    <note><para>每个<userinput>[list]</userinput>中的元素都可能包含多个参数. 
	      在处理参数组时, 这是非常有用的.
	      在这种情况下, 使用<link linkend="setref">set</link>命令(参见 <xref linkend="ex34">)来强制解析每个<userinput>[list]</userinput>中的元素, 并且将每个解析出来的部分都分配到一个位置参数中. </para></note>

	    <example id="ex22a">
	      <title>每个[list]元素中都带有两个参数的<command>for</command>循环</title>
	      <programlisting>&ex22a;</programlisting>
	    </example>


	    <para>可以将一个变量放在<firstterm>for循环</firstterm>的<userinput>[list]</userinput>位置上. </para>

	    <example id="fileinfo">
	      <title><emphasis>文件信息:</emphasis> 对包含在变量中的文件列表进行操作</title>
	      <programlisting>&fileinfo;</programlisting>
	    </example>

	    
	    <para>如果在<firstterm>for循环</firstterm>的<userinput>[list]</userinput>中有通配符
			(<token>*</token>和<token>?</token>), 那么将会发生<link linkend="globbingref">通配(globbing)</link>, 
		   也就是文件名扩展. </para>

	    <example id="listglob">
	      <title><command>在for循环中操作文件</command></title>
	      <programlisting>&listglob;</programlisting>
	    </example>


	    <para>在一个<firstterm>for循环</firstterm>中忽略<userinput>in [list]</userinput>部分的话, 
			将会使循环操作<token>$@</token> -- 从命令行传递给脚本的<link 
				linkend="posparamref">位置参数</link>. 
			一个非常好的例子, 参见<xref linkend="primes">. 参见<xref linkend="revposparams">.</para>

	    <example id="ex23">
	      <title>在<command>for</command>循环中省略<userinput>in [list]</userinput>部分</title>
	      <programlisting>&ex23;</programlisting>
	    </example>


	    <para>也可以使用<link
	      linkend="commandsubref">命令替换</link>
	      来产生<firstterm>for循环</firstterm>的<userinput>[list]</userinput>.
	      参见<xref linkend="ex53">,
	      <xref linkend="symlinks">和<xref linkend="base">.</para>

	    <example id="forloopcmd">
	      <title>使用命令替换来产生<command>for</command>循环的[list]</title>
	      <programlisting>&forloopcmd;</programlisting>
	    </example>


	    <para>下边是一个用命令替换来产生[list]的更复杂的例子. </para>

	    <example id="bingrep">
	      <title>对于二进制文件的<link linkend="grepref">grep</link>替换</title>
	      <programlisting>&bingrep;</programlisting>
	    </example>

	    <para>大部分相同. </para>

	    <example id="userlist">
	      <title>列出系统上的所有用户</title>
	      <programlisting>&userlist;</programlisting>
	    </example>

	    <para>关于用命令替换来产生[list]的最后一个例子. </para>

	    <example id="findstring">
	      <title>在目录的所有文件中查找源字串</title>
	      <programlisting>&findstring;</programlisting>
	    </example>


	    <para><firstterm>for循环</firstterm>的输出也可以通过管道传递到一个或多个命令中. </para>

	    <example id="symlinks">
	      <title>列出目录中所有的<link linkend="symlinkref">符号链接</link></title>
	      <programlisting>&symlinks;</programlisting>
	    </example>

	    <para>循环的<filename>stdout</filename>可以<link
				linkend="ioredirref">重定向</link>到文件中, 
			我们对上边的例子做了一点修改. </para>

	    <example id="symlinks2">
	      <title>将目录中所有符号链接文件的名字保存到一个文件中</title>
	      <programlisting>&symlinks2;</programlisting>
	    </example>

	    <para>有一种非常像C语言<firstterm>for循环</firstterm>的语法形式. 
	     需要使用(()).</para>

	    <example id="forloopc">
	      <title>一个C风格的<command>for</command>循环</title>
	      <programlisting>&forloopc;</programlisting>
	    </example>

	    <para>参考<xref linkend="qfunction">, <xref
	      linkend="twodim">, 和<xref linkend="collatz">.</para>

	    <para>---</para>

	    <para>现在, 让我们来看一个<quote>现实生活</quote>中使用<firstterm>for循环</firstterm>的例子. </para>

	    <example id="ex24">
	      <title>在batch mode中使用<command>efax</command></title>
	      <programlisting>&ex24;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="whileloopref"><command>while</command></term>
	  <indexterm>
	    <primary>while</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>while</secondary>
	  </indexterm>
	  <listitem>
	    <para>这种结构在循环的开头判断条件是否满足, 
	      如果条件一直满足, 那么就一直循环下去
	      (返回<returnvalue>0</returnvalue>作为<link
			  linkend="exitstatusref">退出状态码</link>). 
		  与<link linkend="forloopref1">for循环</link>的区别是,
		  <firstterm>while循环</firstterm>更适合在循环次数未知的情况下使用. 
	  </para>

	    <para><cmdsynopsis>
		<command>while</command>
		<arg choice="opt"><replaceable>condition</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg choice="plain" rep="repeat"><replaceable>&nbsp;command</replaceable></arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>


	    <para><link linkend="needsemicolon">与<firstterm>for循环</firstterm>一样</link>,
	      如果想把<firstterm>do</firstterm>和条件判断放到同一行上的话, 
	      还是需要一个分号.</para>

	    <para><cmdsynopsis>
		<command>while</command>
		<arg choice="opt"><replaceable>condition</replaceable></arg>
		<arg choice="plain">;</arg>
		<arg choice="plain">do</arg>
	      </cmdsynopsis></para>
	    
		  <para>需要注意一下某种特定的<firstterm>while循环</firstterm>, 
			  比如<link linkend="getoptsx">getopts结构</link>, 
			  好像和这里所介绍的模版有点脱节. </para>

	    <example id="ex25">
	      <title>简单的<command>while</command>循环</title>
	      <programlisting>&ex25;</programlisting>
	    </example>
	    
	    <example id="ex26">
	      <title>另一个<command>while</command>循环</title>
	      <programlisting>&ex26;</programlisting>
	    </example>	    


		<para>一个<firstterm>while循环</firstterm>可以有多个判断条件. 
			但是只有最后一个才能够决定是否能够退出循环.
	      然而这里需要一种有点特殊的循环语法.
	      </para>

	    <example id="ex26a">
	      <title>多条件的<command>while</command>循环</title>
	      <programlisting>&ex26a;</programlisting>
	    </example>	    

	    <para>与<firstterm>for循环</firstterm>一样,
			<firstterm>while循环</firstterm>也可以通过(())来使用C风格的语法. 
			(参考<xref linkend="cvars">).</para>

	    <example id="whloopc">
	      <title>C风格的<command>while</command>循环</title>
	      <programlisting>&whloopc;</programlisting>
	    </example>

	    <note>
	    <para><firstterm>while循环</firstterm>的<filename>stdin</filename>可以使用<token>&lt;</token>来<link
	      linkend="redirref">重定向到一个文件</link>. </para>

	    <para><firstterm>while循环</firstterm>的<filename>stdin</filename>支持<link linkend="readpiperef">管道</link>.</para>
	    </note>

	    </listitem>
	  </varlistentry>



	<varlistentry>
	  <term><anchor id="untilloopref"><command>until</command></term>
	  <indexterm>
	    <primary>until</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>until</secondary>
	  </indexterm>

	  <listitem>
	    <para>这个结构在循环的顶部判断条件, 并且如果条件一直为false, 那么就一直循环下去.
	      (与<firstterm>while循环</firstterm>相反).</para>

	    <para><cmdsynopsis>
		<command>until</command>
		<arg choice="opt"><replaceable>condition-is-true</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg choice="plain" rep="repeat"><replaceable>nbsp;command</replaceable></arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>

	    <para>注意, <firstterm>until循环</firstterm>的条件判断在循环的顶部, 
	      这与某些编程语言是不同的. </para>

	    <para>与<firstterm>for循环</firstterm>一样,
	      如果想把<firstterm>do</firstterm>和条件判断放在同一行里, 那么就需要使用分号. </para>

	    <para><cmdsynopsis>
		<command>until</command>
		<arg choice="opt"><replaceable>condition-is-true</replaceable></arg>
		<arg choice="plain">;</arg>
		<arg choice="plain">do</arg>
	      </cmdsynopsis></para>

	    <example id="ex27">
	      <title><command>until</command>循环</title>
	      <programlisting>&ex27;</programlisting>
	    </example>	    
	    </listitem>
	  </varlistentry>

	</variablelist>

    </sect1> <!-- Loops -->



      <sect1 id="nestedloops">
        <title>嵌套循环</title>

	<para><firstterm>嵌套循环</firstterm>就是在一个循环中还有一个循环, 
	  内部循环在外部循环体中. 在外部循环的每次执行过程中都会触发内部循环, 
	  直到内部循环执行结束. 外部循环执行了多少次, 内部循环就完成多少次.
	  当然, 无论是内部循环还是外部循环的<firstterm>break</firstterm>语句都会打断处理过程. 
	  </para>

	    <example id="nestedloop">
	      <title>嵌套循环</title>
	      <programlisting>&nestedloop;</programlisting>
	    </example>	    

		<para>关于嵌套的<link linkend="whileloopref">while循环</link>请参考<xref linkend="bubble">, 
			关于while循环中嵌套<link linkend="untilloopref">until循环</link>的例子请参考<xref linkend="ex68">. </para>

    </sect1> <!-- Nested Loops -->


      <sect1 id="loopcontrol">
        <title>循环控制</title>

	<variablelist id="brkcont">
	  <title><anchor id="brkcont1">影响循环行为的命令</title>

	<varlistentry>
	  <indexterm>
	    <primary>break</primary>
	  </indexterm>
	  <indexterm>
	    <primary>continue</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>break</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>continue</secondary>
	  </indexterm>
	  <term><command>break</command></term>
	  <term><command>continue</command></term>
	  <listitem>
	    <para><command>break</command>和<command>continue</command>这两个循环控制命令
		<footnote><para>这两个命令是shell的<link
		linkend="builtinref">内建</link>命令,
		而不象其他的循环命令那样, 比如<link
		linkend="whileloopref">while</link>和<link
		linkend="caseesac1">case</link>, 这两个是<link
		linkend="keywordref">关键字</link>.</para></footnote>
		  与其他语言的类似命令的行为是相同的. 
		  <command>break</command>命令用来跳出循环, 
		  而<command>continue</command>命令只会跳过本次循环, 
		  忽略本次循环剩余的代码, 
		  进入循环的下一次<firstterm>迭代</firstterm>. </para>

	    <example id="ex28">
	      <title><command>break</command>和<command>continue</command>命令在循环中的效果</title>
	      <programlisting>&ex28;</programlisting>
	    </example>	    

		<para><command>break</command>命令可以带一个参数. 
			一个不带参数的<command>break</command>命令只能退出最内层的循环, 
	      而<command>break N</command>可以退出<parameter>N</parameter>层循环. </para>

	    <example id="breaklevels">
	      <title>多层循环的退出</title>
	      <programlisting>&breaklevels;</programlisting>
	    </example>	    

		<para><command>continue</command>命令也可以象<command>break</command>命令一样带一个参数.
		一个不带参数的<command>continue</command>命令只会去掉本次循环的剩余代码. 
	      而<command>continue N</command>将会把<option>N</option>层循环的剩余代码都去掉, 但是循环的次数不变. </para>

	    <example id="continuelevels">
	      <title>多层循环的continue</title>
	      <programlisting>&continuelevels;</programlisting>
	    </example>	    

	    <example id="continuenex">
	      <title>在实际的任务中使用<quote>continue N</quote></title>
	      <programlisting>&continuenex;</programlisting>
	    </example>	    

	    <caution><para><command>continue N</command>结构如果用在有意义的场合中, 往往都很难理解, 并且技巧性很高. 所以最好的方法就是尽量避免使用它. 
	      </para></caution>

	  </listitem>
	</varlistentry>

	</variablelist>

    </sect1> <!-- Loop Control Commands -->



      <sect1 id="testbranch">
		  <title>测试与分支(case与select结构)</title>

	<para><command>case</command>和<command>select</command>结构在技术上说并不是循环, 因为它们并不对可执行代码块进行迭代. 
	  但是和循环相似的是, 它们也依靠在代码块顶部或底部的条件判断来决定程序的分支. </para>

	<variablelist id="caseesac">
	  <title><anchor id="caseesac1">在代码块中控制程序分支</title>

	<varlistentry>
	  <term><command>case (in) / esac</command></term>
	  <indexterm>
	    <primary>case</primary>
	  </indexterm>
	  <indexterm>
	    <primary>in</primary>
	  </indexterm>
	  <indexterm>
	    <primary>esac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>switch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>;;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>menus</primary>
	  </indexterm>

	  <listitem>
		  <para>在shell中的<command>case</command>结构与C/C++中的<command>switch</command>结构是相同的. 
	      它允许通过判断来选择代码块中多条路径中的一条. 
	      它的作用和多个<token>if/then/else</token>语句的作用相同, 
	      是它们的简化结构, 特别适用于创建菜单. </para>

	    <para><cmdsynopsis>
		<command>case</command>
		<arg choice="plain">"$<replaceable>variable</replaceable>"</arg>
		<arg choice="plain">in</arg><sbr><sbr>
		<arg choice="plain">&nbsp;"$<replaceable>condition1</replaceable>" )</arg><sbr>
		<arg choice="plain" rep="repeat">&nbsp;<replaceable>command</replaceable></arg><sbr>
		<arg choice="plain">&nbsp;;;</arg><sbr><sbr>
		<arg choice="plain">&nbsp;"$<replaceable>condition2</replaceable>" )</arg><sbr>
		<arg choice="plain" rep="repeat">&nbsp;<replaceable>command</replaceable></arg><sbr>
		<arg choice="plain">&nbsp;;;</arg><sbr><sbr>
		<arg choice="plain">esac</arg>
	      </cmdsynopsis></para>

	    <note><para>
	      <itemizedlist>
		<listitem><para>对变量使用""并不是强制的, 因为不会发生单词分割.
		</para>
		</listitem>
		<listitem><para>每句测试行, 都以右小括号<token>)</token>来结尾.</para>
		</listitem>
		<listitem><para>每个条件判断语句块都以<emphasis>一对</emphasis>分号结尾 <token>;;</token>.</para>
		</listitem>
		<listitem><para><command>case</command>块以<command>esac</command> (<wordasword>case</wordasword>的反向拼写)结尾.</para>
		  </listitem>
	      </itemizedlist>
	    </para></note>

	    <example id="ex29">
	      <title>使用<command>case</command></title>
	      <programlisting>&ex29;</programlisting>
	    </example>	    

	    <example id="ex30">
	      <title>使用<command>case</command>来创建菜单</title>
	      <programlisting>&ex30;</programlisting>
	    </example>	    

	    <para>一个<command>case</command>的非常聪明的用法, 
	      用来测试命令行参数.
	      <programlisting>#! /bin/bash

case "$1" in
"") echo "Usage: ${0##*/} &lt;filename&gt;"; exit $E_PARAM;;  # 没有命令行参数,
                                                        # 或者第一个参数为空.
# 注意: ${0##*/} 是 ${var##pattern} 的一种替换形式. 得到的结果为$0.

-*) FILENAME=./$1;;   #  如果传递进来的文件名参数($1)以一个破折号开头, 
                      #+ 那么用./$1来代替.
                      #+ 这样后边的命令将不会把它作为一个选项来解释.

* ) FILENAME=$1;;     # 否则, $1.
esac</programlisting></para>

	    <para>这是一个命令行参数处理的更容易理解的例子: 
	      <programlisting>#! /bin/bash


while [ $# -gt 0 ]; do    # 直到你用完所有的参数 . . .
  case "$1" in
    -d|--debug)
              # 是 "-d" 或 "--debug" 参数?
              DEBUG=1
              ;;
    -c|--conf)
              CONFFILE="$2"
              shift
              if [ ! -f $CONFFILE ]; then
                echo "Error: Supplied file doesn't exist!"
                exit $E_CONFFILE     # 错误: 文件未发现.
              fi
              ;;
  esac
  shift       # 检查剩余的参数.
done

#  来自Stefano Falsetto的 "Log2Rot" 脚本,
#+ 并且是他的"rottlog"包的一部分. 
#  已得到使用许可. </programlisting></para>


	    <example id="casecmd">
	      <title>使用命令替换来产生<command>case</command>变量</title>
	      <programlisting>&casecmd;</programlisting>
	    </example>	    

		<para><command>case</command>结构也可以过滤<link linkend="globbingref">通配(globbing)</link>模式的字符串.</para>

	    <example id="matchstring">
	      <title>简单的字符串匹配</title>
	      <programlisting>&matchstring;</programlisting>
	    </example>	    

	    <example id="isalpha">
	      <title>检查输入字符是否为字母</title>
	      <programlisting>&isalpha;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>



	<varlistentry>
	  <term><anchor id="selectref"><command>select</command></term>
	  <indexterm>
	    <primary>select</primary>
	  </indexterm>
	  <indexterm>
	    <primary>menus</primary>
	  </indexterm>
	  <listitem>
	    <para><command>select</command>结构是建立菜单的另一种工具, 
	      这种结构是从ksh中引入的. </para>

	    <para><cmdsynopsis>
		<command>select</command>
		<arg choice="plain"><replaceable>variable</replaceable></arg>
		<arg choice="opt">in <replaceable>list</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg choice="plain" rep="repeat">&nbsp;<replaceable>command</replaceable></arg><sbr>
		<arg choice="plain">&nbsp;break</arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>
	    
		  <para>提示用户输入选择的内容(比如放在变量列表中).  
			  注意: <command>select</command>命令使用<varname>PS3</varname>提示符, 
			  默认为(<prompt>#?</prompt>), 
		当然, 这可以修改.</para>
	    
	    <example id="ex31">
	      <title>使用<command>select</command>来创建菜单</title>
	      <programlisting>&ex31;</programlisting>
	    </example>	    

		<para>如果忽略了<userinput>in <replaceable>list</replaceable></userinput>列表, 
			那么<command>select</command>命令将会使用传递到脚本的命令行参数(<varname>$@</varname>), 
			或者是函数参数(当<command>select</command>是在函数中时). 
		</para>
	      
	    <para>与忽略<userinput>in <replaceable>list</replaceable></userinput>的
	      <cmdsynopsis>
		<command>for</command>
		<arg choice="plain"><replaceable>variable</replaceable></arg>
		<arg choice="opt">in <replaceable>list</replaceable></arg>
	      </cmdsynopsis>
	      结构比较一下. </para>

	    <example id="ex32">
	      <title>使用函数中的<command>select</command>结构来创建菜单</title>
	      <programlisting>&ex32;</programlisting>
	    </example>	    

	    <para>参考<xref linkend="resistor">.</para>

	    </listitem>
	  </varlistentry>

      </variablelist>

    </sect1> <!-- Testing and Branching -->


  </chapter> <!-- Loops -->



  <chapter id="internal">
    <title>内部命令与内建命令</title>


      <indexterm>
	<primary>builtin</primary>
      </indexterm>


		<para><anchor id="builtinref"><firstterm>内建命令</firstterm>指的就是包含在Bash工具包中的<command>命令</command>, 
			  从字面意思上看就是<emphasis>built in</emphasis>. 
			  这主要是考虑到执行效率的问题 -- 内建命令将比外部命令执行的更快, 
			  一部分原因是因为外部命令通常都需要fork出一个单独的进程来执行 --
			  另一部分原因是特定的内建命令需要直接访问shell的内核部分.
		</para>
      
      <para><anchor id="forkref"></para>

		 <sidebar>

		 <para>当一个命令或者是shell本身需要初始化(或者<firstterm>创建</firstterm>)一个新的子进程来执行一个任务的时候, 
			 这种行为被称为<firstterm>fork</firstterm>. 
			 这个新产生的进程被叫做<firstterm>子进程</firstterm>, 
			 并且这个进程是从<firstterm>父进程</firstterm>中<emphasis>fork</emphasis>出来的. 
			 当<firstterm>子进程</firstterm>执行它的任务时, 
		   <firstterm>父进程</firstterm>也在运行.</para>

		 <para>注意: 当<emphasis>父进程</emphasis>获得了<emphasis>子进程</emphasis>的<firstterm>进程ID</firstterm>时, 
		   父进程可以给子进程传递参数,
		   然而<emphasis>反过来却不行</emphasis>. 
		   <link linkend="parchildprobref">这将会产生不可思议的并且很难追踪的问题. </link>
	   </para>

	    <example id="spawnscr">
	      <title>一个fork出多个自身实例的脚本</title>
	      <programlisting>&spawnscr;</programlisting>
	    </example>


		 <para>通常情况下, 脚本中的Bash<emphasis>内建命令</emphasis>在运行的时候是不会fork出一个子进程的. 
		   但是脚本中的外部或者过滤命令通常<emphasis>会</emphasis>fork出一个子进程. </para>

		   </sidebar>


		   <para>一个内建命令通常会与一个系统命令同名, 
			   但是Bash在内部重新实现了这些命令. 
			   比如, Bash的<command>echo</command>命令与<filename>/bin/echo</filename>就不尽相同, 
			   虽然它们的行为在绝大多数情况下都是一样的.
	   <programlisting>#!/bin/bash

echo "This line uses the \"echo\" builtin."
/bin/echo "This line uses the /bin/echo system command."</programlisting>
	</para>

      <para><anchor id="keywordref"><firstterm>关键字</firstterm>的意思就是<emphasis>保留</emphasis>字, 
			  对于shell来说关键字具有特殊的含义, 并且用来构建shell语法结构.
	比如, <quote><token>for</token></quote>,
	<quote><token>while</token></quote>, <quote>do</quote>, 和
	<quote><token>!</token></quote> 都是关键字. 
	与<link linkend="builtinref">内建命令</link>相似的是, 关键字也是Bash的骨干部分, 
	但是与<emphasis>内建命令</emphasis>不同的是, 关键字本身并不是一个命令, 
	而是一个比较大的命令结构的一部分.

	   <footnote><para>其中有一个例外就是<link
				   linkend="timref">time</link>命令, 
			   Bash的官方文档说这个命令是一个关键字. </para></footnote>

	</para>


      <variablelist id="intio">
        <title><anchor id="intio1">I/O</title>

	<varlistentry>
	  <term><anchor id="echoref"><command>echo</command></term>
	  <indexterm>
	    <primary>echo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>echo</secondary>
	  </indexterm>
	  <listitem>
	    <para>打印(到 <filename>stdout</filename>)一个表达式或者变量(参考<xref linkend="ex9">). 
	      <programlisting>echo Hello
echo $a</programlisting></para>
	    
	    <para><command>echo</command>命令需要<option>-e</option>参数来打印转义字符. 
	      参考<xref linkend="escaped">.</para>

	    <para>通常情况下, 每个<command>echo</command>命令都会在终端上新起一行,  
	      但是<option>-n</option>参数会阻止新起一行. </para>

	    <note>
	    <para><command>echo</command>命令可以作为输入, 通过管道传递到一系列命令中去.
	      </para>
	    <para><programlisting>if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
then
  echo "$VAR contains the substring sequence \"txt\""
fi</programlisting></para>  
	    </note>  

	    <note><para><command>echo</command>命令可以与<link linkend="commandsubref">命令替换</link>组合起来, 
				这样可以用来设置一个变量.</para> 
			<para><userinput>a=`echo
	      "HELLO" | tr A-Z a-z`</userinput></para>
	      <para>参考<xref linkend="lowercase">, <xref
	      linkend="ex57">, <xref linkend="monthlypmt">, 和 <xref
	      linkend="base">.</para></note>


	    <para>小心<command>echo `command`</command>将会删除任何由<replaceable>command</replaceable>所产生的换行符. 
	      </para>
	      
		  <para><link linkend="ifsref">$IFS</link> (内部域分隔符) 
			  一搬都会将 <token>\n</token> (换行符) 包含在它的<link linkend="whitespaceref">空白</link>字符集合中. 
			  Bash因此会根据参数中的换行来分离<replaceable>command</replaceable>的输出, 
			  然后<command>echo</command>.
	      最后<command>echo</command>将以空格代替换行来输出这些参数. 
	     </para>
	      
	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>ls -l /usr/share/apps/kjezz/sounds</userinput>
<computeroutput>-rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
 -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au</computeroutput>




<prompt>bash$ </prompt><userinput>echo `ls -l /usr/share/apps/kjezz/sounds`</userinput>
<computeroutput>total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root 362 Nov 7 2000 seconds.au</computeroutput>
	      </screen>
	    </para>

            <para>
				所以, 我们怎么做才能够在一个需要<emphasis>echo</emphasis>出来的字符串中嵌入换行呢?

	     <programlisting># 嵌入一个换行?
echo "Why doesn't this string \n split on two lines?"
# 上边这句的\n将被打印出来. 达不到换行的目的.

# 让我们再试试其他方法.

echo
	     
echo $"A line of text containing
a linefeed."
# 打印出两个独立的行(嵌入换行成功了).
# 但是, 是否必须有"$"作为变量前缀? 

echo

echo "This string splits
on two lines."
# 不, 并不是非有"$"不可.

echo
echo "---------------"
echo

echo -n $"Another line of text containing
a linefeed."
# 打印出两个独立的行(嵌入换行成功了).
# 即使使用了-n选项, 也没能阻止换行. (译者注: -n 阻止了第2个换行)

echo
echo
echo "---------------"
echo
echo

# 然而, 下边的代码就没能像期望的那样运行.
# 为什么失败? 提示: 因为分配到了变量.
string1=$"Yet another line of text containing
a linefeed (maybe)."

echo $string1
# Yet another line of text containing a linefeed (maybe).
#                                    ^
# 换行变成了空格.

# 感谢, Steve Parker, 指出了这点.</programlisting>
            </para>

	    <note>
			<para>这个命令是shell的一个内建命令, 
				与<filename>/bin/echo</filename>不同, 虽然行为相似.</para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>type -a echo</userinput>
<computeroutput>echo is a shell builtin
 echo is /bin/echo</computeroutput>
	      </screen>
	  </para>
	    </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="printfref"><command>printf</command></term>
	  <indexterm>
	    <primary>printf</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>printf</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>printf</command>命令, 格式化输出, 是<command>echo</command>命令的增强版. 
			  它是C语言<function>printf()</function>库函数的一个有限的变形, 
			  并且在语法上有些不同.</para>
	    <cmdsynopsis>
	      <command>printf</command>
	      <arg choice=plain rep=repeat><replaceable>format-string</replaceable></arg>
	      <arg choice=plain rep=repeat><replaceable>parameter</replaceable></arg>
	    </cmdsynopsis>

	    <para>这是Bash的内建版本,  
			与<filename>/bin/printf</filename>或者<filename>/usr/bin/printf</filename>命令不同. 
			如果想更深入的了解, 请察看<command>printf</command>(系统命令)的man页. 
		</para>

	    <caution><para>老版本的Bash可能不支持<command>printf</command>.</para></caution>

	    <example id="ex47">
	      <title>使用<command>printf</command>的例子</title>
	      <programlisting>&ex47;</programlisting>
	    </example>

	    <para>使用<command>printf</command>的最主要的应用就是格式化错误消息. </para>

            <para>
	        <programlisting>E_BADDIR=65

var=nonexistent_directory

error()
{
  printf "$@" >&2
  # 格式化传递进来的位置参数, 并把它们送到stderr.
  echo
  exit $E_BADDIR
}

cd $var || error $"Can't cd to %s." "$var"

# 感谢, S.C.</programlisting>
            </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="readref"><command>read</command></term> <indexterm>
	    <primary>read</primary>
	  </indexterm> <indexterm>
	    <primary>command</primary> <secondary>read</secondary>
	  </indexterm> <listitem><para>从<filename>stdin</filename>中<quote>读取</quote>一个变量的值, 
	    也就是, 和键盘进行交互, 来取得变量的值.
	    使用<option>-a</option>参数可以<command>read</command>数组变量(参考<xref linkend="ex67">).</para>

	    <example id="ex36">
	      <title>使用<command>read</command>来进行变量分配</title>
	      <programlisting>&ex36;</programlisting>
	    </example>


	    <para>一个不带变量参数的<command>read</command>命令, 
	      将会把来自键盘的输入存入到专用变量<link
	      linkend="replyref">$REPLY</link>中. </para>

	    <example id="readnovar">
	      <title>当使用一个不带变量参数的<command>read</command>命令时, 将会发生什么? </title>
	      <programlisting>&readnovar;</programlisting>
	    </example>


		<para>一般的, 当输入给<command>read</command>时, 
			输入一个<userinput>\</userinput>, 然后回车, 将会阻止产生一个新行. 
	      <option>-r</option>选项将会让 <userinput>\</userinput> 转义. </para>

	    <example id="readr">
	      <title><command>read</command>命令的多行输入</title>
	      <programlisting>&readr;</programlisting>
	    </example>

	    
	    <para><command>read</command>命令有些有趣的选项, 这些选项允许打印出一个提示符, 
	      然后在不输入<keycap>ENTER</keycap>的情况下, 可以读入你所按下的字符的内容.
	      </para>

	    <para><programlisting># 不敲回车, 读取一个按键字符.

read -s -n1 -p "Hit a key " keypress
echo; echo "Keypress was "\"$keypress\""."

# -s 选项意味着不打印输入.
# -n N 选项意味着只接受N个字符的输入.
# -p 选项意味着在读取输入之前打印出后边的提示符.

# 使用这些选项是有技巧的, 因为你需要用正确的顺序来使用它们.
		</programlisting></para>

	    <para><command>read</command>命令的<option>-n</option>选项也可以检测<emphasis>方向键</emphasis>, 
	      和一些控制按键. </para>

	    <example id="arrowdetect">
	      <title>检测方向键</title>
	      <programlisting>&arrowdetect;</programlisting>
	    </example>

		<note><para>对于<command>read</command>命令来说, 
				<option>-n</option>选项不会检测<keycap>ENTER</keycap>(新行)键.
	      </para></note>


	    <para><command>read</command>命令的<option>-t</option>选项允许时间输入(参考<xref linkend="tout">).</para>

	    <para><command>read</command>命令也可以从<link linkend="ioredirref">重定向</link>的文件中<quote>读取</quote>变量的值. 
	      如果文件中的内容超过一行, 
	      那么只有第一行被分配到这个变量中.
	      如果<command>read</command>命令的参数个数超过一个, 
		  那么每个变量都会从文件中取得一个分配的字符串作为变量的值, 
		  这些字符串都是以<link linkend="whitespaceref">定义的空白字符</link>来进行分隔的.
	      小心使用!</para>

	    <example id="readredir">
	      <title>通过<link linkend="ioredirref">文件重定向</link>来使用<command>read</command>命令</title>
	      <programlisting>&readredir;</programlisting>
	    </example>

	    <note>

			<para><link linkend="piperef">管道</link>输出到<command>read</command>命令中, 
				使用管道<link linkend="echoref">echo</link>输出来设置变量<link
	      linkend="badread0">将会失败</link>.</para>

	    <para><anchor id="readpiperef">然而, 使用管道<link
	      linkend="catref">cat</link>输出<emphasis>看起来</emphasis>能够正常运行. </para>

	    <para><programlisting>cat file1 file2 |
while read line
do
echo $line
done</programlisting></para>


            <para>但是, 就像Bj&ouml;n Eriksson所指出的:</para>

    <example id="readpipe">
      <title>管道输出到read中的问题</title>
      <programlisting>&readpipe;</programlisting>
    </example>

	<para>在许多Linux发行版上, <command>gendiff</command>脚本通常都在<filename>/usr/bin</filename>下, 
		将<link linkend="findref">find</link>的输出通过管道传到<emphasis>while read</emphasis>结构中.

	      <programlisting>find $1 \( -name "*$2" -o -name ".*$2" \) -print |
while read f; do
. . .</programlisting>
            </para>

	      </note>
	      

	    </listitem>
	  </varlistentry>

      </variablelist>

      <variablelist id="intfilesystem">
        <title><anchor id="intfilesystem1">文件系统</title>

	<varlistentry>
	  <term><command>cd</command></term>
	  <indexterm>
	    <primary>cd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cd</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>cd</command>, 修改目录命令, 
			  在脚本中用的最多的时候就是当命令需要在指定目录下运行时, 
	      需要用它来修改当前工作目录. </para>

	    <para>  
	      <programlisting>(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)</programlisting>
	      [来自于<link linkend="coxex">之前引用过</link>的一个例子, 是由Alan Cox编写的]</para>

	    <para><option>-P</option> (physical)选项对于<command>cd</command>命令的意义是忽略符号链接. </para>

	    <para><command>cd -</command> 将会把工作目录修改至<link
	    linkend="oldpwd">$OLDPWD</link>, 也就是之前的工作目录. </para>

	    <para><anchor id="doubleslashref"></para>

			<caution><para>当我们使用两个"/"来作为<command>cd</command>命令的参数时, 
					结果却出乎我们的意料.
	      .

	      <screen>
<prompt>bash$ </prompt><userinput>cd //</userinput>
<prompt>bash$ </prompt><userinput>pwd</userinput>
<computeroutput>//</computeroutput>
	      </screen>
	      输出应该是, 并且当然应该是 <computeroutput>/</computeroutput>.
	      无论在命令下还是在脚本中, 这都是个问题. </para></caution>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><anchor id="pwd2ref"><command>pwd</command></term>
	  <indexterm>
	    <primary>pwd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pwd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <listitem><para>打印出当前的工作目录. 
			  这将给出用户(或脚本)的当前工作目录 (参考<xref linkend="ex37">). 
				  使用这个命令的结果和从内建变量<link
	      linkend="pwdref">$PWD</link>中所读取的值是相同的.</para>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><anchor id="dirsd"><command>pushd</command></term>
	<term><command>popd</command></term>
	<term><command>dirs</command></term>
	  <indexterm>
	    <primary>pushd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pushd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>popd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>popd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dirs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>bookmark</primary>
	  </indexterm>
	  <listitem><para>这几个命令可以使得工作目录书签化, 就是可以按顺序向前或向后移动工作目录.
	      压栈的动作可以保存工作目录列表. 选项可以允许对目录栈做不同的操作. </para>

	    <para><anchor id="pushdref"><userinput>pushd
	      dir-name</userinput>把路径<replaceable>dir-name</replaceable>压入目录栈, 
	      同时修改当前目录到<replaceable>dir-name</replaceable>. </para>

	    <para><anchor id="popdref"><command>popd</command>将目录栈最上边的目录弹出, 
	      同时将当前目录修改为刚弹出来的那个目录. </para>
	    
	  <para><command>dirs</command>列出所有目录栈的内容
		  (与<link linkend="dirstackref">$DIRSTACK</link>变量相比较).
	      一个成功的<command>pushd</command>或者<command>popd</command>将会自动调用<command>dirs</command>命令.</para>


	    <para>对于那些并没有对当前目录做硬编码, 并且需要对当前工作目录做灵活修改的脚本来说, 
	      使用这些命令是再好不过了. 
	      注意内建<varname>$DIRSTACK</varname>数组变量,
	      这个变量可以在脚本中进行访问, 并且它们保存了目录栈的内容.
	    </para>

	    <example id="ex37">
	      <title>修改当前工作目录</title>
	      <programlisting>&ex37;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="intvar">
        <title><anchor id="intvar1">变量</title>

	<varlistentry>
	  <term><anchor id="letref"><command>let</command></term>
	  <indexterm>
	    <primary>let</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>let</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>let</command>命令将执行变量的算术操作. 
			  在许多情况下, 它被看作是复杂的<link linkend="exprref">expr</link>命令的一个简化版本.</para>

	    <example id="ex46">
	      <title>使用<quote>let</quote>命令来做算术运算.</title>
	      <programlisting>&ex46;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="evalref"><command>eval</command></term>
	  <indexterm>
	    <primary>eval</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>eval</secondary>
	  </indexterm>
	  <listitem>
	    
	    <para><userinput>eval arg1 [arg2] ... [argN]</userinput></para>
	    
		<para>将表达式中的参数, 或者表达式列表, 组合起来, 
			然后<emphasis>评价</emphasis>它们(译者注: 通常用来执行). 
			任何被包含在表达示中的变量都将被扩展.
	      结果将会被转化到命令中. 如果你想从命令行中或者是从脚本中产生代码, 那么这个命令就非常有用了. </para>


	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>process=xterm</userinput>
<prompt>bash$ </prompt><userinput>show_process="eval ps ax | grep $process"</userinput>
<prompt>bash$ </prompt><userinput>$show_process</userinput>
<computeroutput>1867 tty1     S      0:02 xterm
 2779 tty1     S      0:00 xterm
 2886 pts/1    S      0:00 grep xterm</computeroutput>
	      </screen>
	      </para>

	    <example id="ex43">
	      <title>展示<command>eval</command>命令的效果</title>
	      <programlisting>&ex43;</programlisting>
	    </example>	    

	    <example id="ex44">
	      <title>强制登出(log-off)</title>
	      <programlisting>&ex44;</programlisting>
	    </example>	    

	    <example id="rot14">
	      <title>另一个<quote>rot13</quote>版本</title>
	      <programlisting>&rot14;</programlisting>
	    </example>	    

		<para>Rory Winston 捐献了下边的脚本, 
			关于使用<command>eval</command>命令. </para>

	    <example id="evalex">
	      <title>在Perl脚本中使用<command>eval</command>命令来强制变量替换</title>
	      <programlisting>&evalex;</programlisting>
	    </example>	    



	    <caution><para><command>eval</command>命令是有风险的,
				如果你有更合适的方法来实现功能的话, 
				尽量避免使用它.
				<userinput>eval $COMMANDS</userinput>将会执行命令<replaceable>COMMANDS</replaceable>的内容, 
				如果命令中包含有<command>rm -rf *</command>这样的东西, 可能就不是你想要的了. 
				当你运行一个包含有<command>eval</command>命令的陌生人所编写的代码片段的时候, 这是一件很危险的事情. 
		</para></caution>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="setref"><command>set</command></term>
	  <indexterm>
	    <primary>set</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>set</secondary>
	  </indexterm>
	  <listitem><para><command>set</command>命令用来修改内部脚本变量的值. 
	      它的一个作用就是触发<link linkend="optionsref">选项标志位</link>来帮助决定脚本的行为. 
	      另一个作用是以一个命令的结果(<userinput>set
	      `command`</userinput>)来重新设置脚本的<link linkend="posparamref">位置参数</link>. 
	  脚本将会从命令的输出中重新分析出位置参数. 
		  </para>

	    <example id="ex34">
	      <title>使用<command>set</command>命令来改变脚本的位置参数</title>
	      <programlisting>&ex34;</programlisting>
	    </example>

	    <para>关于位置参数更多有趣的事情.</para>

	    <example id="revposparams">
	      <title>反转位置参数</title>
	      <programlisting>&revposparams;</programlisting>
	    </example>

	    <para>不使用任何选项或参数来调用<command>set</command>命令的话, 
	      将会列出所有的<link linkend="envref">环境变量</link>和其他所有的已经初始化过的变量.
	      <screen>
<prompt>bash$ </prompt><userinput>set</userinput>
<computeroutput>AUTHORCOPY=/home/bozo/posts
 BASH=/bin/bash
 BASH_VERSION=$'2.05.8(1)-release'
 ...
 XAUTHORITY=/home/bozo/.Xauthority
 _=/etc/bashrc
 variable22=abc
 variable23=xzy</computeroutput>
	      </screen>
            </para>


	    <para>如果使用参数<option>--</option>来调用<command>set</command>命令的话, 
	      将会明确的分配位置参数.
		  如果<option>--</option>选项后边没有跟变量名的话, 
		  那么结果就使得所有位置参数都被<emphasis>unsets</emphasis>了.
	      </para>

	    <example id="setpos">
	      <title>重新分配位置参数</title>
	      <programlisting>&setpos;</programlisting>
	    </example>

	    <para>参考<xref linkend="ex22a">和<xref linkend="ex33a">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="unsetref"><command>unset</command></term>
	  <indexterm>
	    <primary>unset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unset</secondary>
	  </indexterm>
	  <listitem><para><command>unset</command>命令用来删除一个shell变量, 
			  这个命令的效果就是把这个变量设为<emphasis>null</emphasis>. 
			  注意: 这个命令对位置参数无效. </para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>unset PATH</userinput>

<prompt>bash$ </prompt><userinput>echo $PATH</userinput>
<computeroutput>


</computeroutput>
<prompt>bash$ </prompt></screen>
	    </para>

	    <example id="uns">
	      <title><quote>Unsett</quote>一个变量</title>
	      <programlisting>&uns;</programlisting>
	    </example>

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor id="exportref"><command>export</command></term>
	  <indexterm>
	    <primary>export</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>export</secondary>
	  </indexterm>
	  <listitem><para><command>export</command>命令将会使得被export的变量在所运行脚本(或shell)的所有子进程中都可用. 
			  <emphasis>不幸的是, 没有办法</emphasis>将<emphasis>变量</emphasis>export<emphasis>到父进程中, 
				  这里所指的父进程就是调用这个脚本的脚本或shell.</emphasis> 
	      关于<command>export</command>命令的一个重要的用法就是使用在<link
			  linkend="filesref1">启动文件</link>中, 
		  启动文件用来初始化和设置<link linkend="envref">环境变量</link>, 
		  这样, 用户进程才能够访问环境变量. </para>


	  <example id="coltotaler3">
	    <title>使用<command>export</command>命令来将一个变量传递到一个内嵌<link linkend="awkref">awk</link>的脚本中</title>
	    <programlisting>&coltotaler3;</programlisting>
	  </example>



	      <tip>

			  <para>可以在一个操作中同时进行赋值和export变量, 比如: 
				  <command>export var1=xxx</command>.</para>

			  <para>然而, 就像Greg Keraunen所指出的, 
				  在某些情况下, 如果使用上边这种形式的话, 
		  将与先设置变量, 然后export变量效果不同. </para>

	        <para>
	        <screen>
<prompt>bash$ </prompt><userinput>export var=(a b); echo ${var[0]}</userinput>
<computeroutput>(a b)</computeroutput>



<prompt>bash$ </prompt><userinput>var=(a b); export var; echo ${var[0]}</userinput>
<computeroutput>a</computeroutput>
	      </screen>
	    </para>

	       	
              </tip>

	    </listitem>
	  </varlistentry>
	
	<varlistentry>
	  <term><command>declare</command></term>
	  <term><command>typeset</command></term>
	  <indexterm>
	    <primary>declare</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>declare</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>typeset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>typeset</secondary>
	  </indexterm>
	  <listitem>
	    <para><link linkend="declareref">declare</link>和<link linkend="declareref">typeset</link>命令被用来指定或限制变量的属性. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>readonly</command></term>
	  <indexterm>
	    <primary>readonly</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>readonly</secondary>
	  </indexterm>
	  <listitem><para>与<link linkend="declareref">declare -r</link>作用相同,
	      设置变量的只读属性, 或者可以认为这个变量就是一个常量.
	      设置了这种属性之后, 如果你还要修改它, 那么将会得到一个错误信息.
	      这种情况与<emphasis>C</emphasis>语言中的<command>const</command>常量类型是相同的.
	      </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="getoptsx"><command>getopts</command></term>
	  <indexterm>
	    <primary>getopts</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>getopts</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTIND</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTIND</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTARG</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTARG</secondary>
	  </indexterm>
	  <listitem>
	    <para>可以说这个命令是分析传递到脚本中命令行参数的最强力的工具.
	      这个命令与外部命令<link
			  linkend="getopty">getopt</link>, 
		  还有<emphasis>C</emphasis>语言中的库函数<command>getopt</command>的作用是相同的. 
	       它允许传递和连接多个选项

		   <footnote><para>一个选项就是一个行为上比较象标志位的参数, 
				   可以用来打开或关闭脚本的某些行为.
		而和某个特定选项相关的参数就是用来控制这个选项(标志)功能是开启还是关闭.
		</para></footnote>

	      到脚本中, 并且能够分配多个参数到脚本中(比如: <userinput>scriptname -abc -e /usr/local</userinput>).</para>

	    <para><command>getopts</command>结构使用两个隐含变量. 
	      <varname>$OPTIND</varname>是参数指针(<wordasword>选项索引</wordasword>)
	      和<varname>$OPTARG</varname>(<wordasword>选项参数</wordasword>)(可选的)可以在选项后边附加一个参数. 
	      在声明标签中, 选项名后边的冒号用来提示这个选项名已经分配了一个参数.
	      </para>

	    <para><command>getopts</command>结构通常都组成一组放在一个<link linkend="whileloopref">while循环</link>中, 
			循环过程中每次处理一个选项和参数,
			然后增加隐含变量<varname>$OPTIND</varname>的值, 再进行下一次的处理. 
	      </para>

	    <note>
	      <para>
		<orderedlist>
		  <listitem>

			  <para>通过命令行传递到脚本中的参数前边必须加上一个减号(<option>-</option>). 
		      <option>-</option>是一个前缀, 
		      这样<command>getopts</command>命令把这个参数看作为一个<emphasis>选项</emphasis>.
		      事实上, <command>getopts</command>不会处理不带<option>-</option>前缀的参数,
			  如果第一个参数就没有<option>-</option>, 
			  那么将会结束选项的处理.
		      </para>

		  </listitem>
		  <listitem><para><command>getopts</command>的<command>while</command>循环模板与标准的<command>while</command>循环模板有些不同, 
		      没有标准循环中的中括号[]判断条件. </para>
		  </listitem>
		  <listitem>

		  <para><command>getopts</command>结构将会取代外部命令<link linkend="getopty">getopt</link>.
		     </para>

		   </listitem>
		</orderedlist>
	      </para>
	    </note>

	    <para><programlisting>
while getopts ":abcde:fg" Option
# 开始的声明.
# a, b, c, d, e, f, 和 g 被认为是选项(标志).
# 'e' 选项后边的 : 提示这个选项需要带一个参数.
# 译者注:	解释一下 'a' 前边的那个 : 的作用.
#			如果选项'e'不带参数进行调用的话, 会产生一个错误信息.
#			这个开头的 : 就是用来屏蔽掉这个错误信息的, 
#			因为我们一般都会有默认处理, 所以并不需要这个错误信息.
do
  case $Option in
    a ) # 对选项'a'作些操作.
    b ) # 对选项'b'作些操作.
    ...                                           
    e)  # 对选项'e'作些操作, 同时处理一下$OPTARG,
        # 这个变量里边将保存传递给选项"e"的参数.
    ...                                           
    g ) # 对选项'g'作些操作.
  esac
done
shift $(($OPTIND - 1))
# 将参数指针向下移动.

# 所有这些远没有它看起来的那么复杂.&lt;嘿嘿&gt;.
	      </programlisting></para>

	    <example id="ex33">
			<title>使用<command>getopts</command>命令来来读取传递给脚本的选项/参数</title>
	      <programlisting>&ex33;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="intscrbeh">
        <title><anchor id="intscrbeh1">脚本行为</title>

      <varlistentry>
	<term><anchor id="sourceref"><command>source</command></term>
	<term><token>.</token> (<link linkend="dotref">点</link> 命令)</term>
	  <indexterm>
	    <primary>source</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>source</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>.</secondary>
	  </indexterm>

	  <listitem>
	  
	  <para>当在命令行中调用的时候, 这个命令将会执行一个脚本.
	      当在脚本中调用的时候, 
		  <userinput>source file-name</userinput> 将会加载<filename>file-name</filename>文件. 
		  sourc一个文件(或点命令)将会在脚本中<emphasis>引入</emphasis>代码, 
	     并将这些代码附加到脚本中(与<emphasis>C</emphasis>语言中的<userinput>#include</userinput>指令效果相同). 
	     最终的结果就像是在使用<quote>source</quote>的行上插入了相应文件的内容. 
	     在多个脚本需要引用相同的数据, 或者需要使用函数库的情况下, 
	     这个命令非常有用. </para>

	    <example id="ex38">
	      <title><quote>includ</quote>一个数据文件</title>
	      <programlisting>&ex38;</programlisting>

		  <para>上边<xref linkend="ex38">所使用的数据文件<filename>data-file</filename>,  
				  必须和上边的脚本放在同一目录下. </para>

	      <programlisting>&ex38bis;</programlisting>
	    </example>	    

	     <para>如果<emphasis>source</emphasis>进来的文件本身就一个可执行脚本的话, 
	       那么它将运行起来, 
	       然后将控制权交还给调用它的脚本.
	       一个<emphasis>source</emphasis>进来的可执行脚本可以使用<link linkend="returnref">return</link>命令来达到这个目的. 
	      </para>

	    <para>
			(可选的)也可以向<emphasis>source</emphasis>文件中传递参数, 
			这些参数将被看作<link linkend="posparamref1">位置参数</link>.
	       <programlisting>source $filename $arg1 arg2</programlisting>
	    </para>



	  <para>你甚至可以在脚本文件中<emphasis>source</emphasis>它自身, 
	    虽然这么做看不出有什么实际的应用价值. </para>

	    <example id="selfsource">
	      <title>一个(没什么用的)source自身的脚本</title>
	      <programlisting>&selfsource;</programlisting>
	    </example>


	    </listitem>
	  </varlistentry>


	<varlistentry>
	  <term><command>exit</command></term>
	  <indexterm>
	    <primary>exit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exit</secondary>
	  </indexterm>
	  <listitem>
	    <para>无条件的停止一个脚本的运行. 
		<command>exit</command>命令可以随意的取得一个整数参数, 
		然后把这个参数作为这个脚本的<link linkend="exitstatusref">退出状态码</link>. 
		在退出一个简单脚本的时候, 使用<userinput>exit 0</userinput>的话, 
		是种好习惯, 因为这表明成功运行. </para>

	<note><para>如果不带参数调用<command>exit</command>命令退出的话, 
			那么退出状态码将会将会是脚本中最后一个命令的退出状态码. 
		  等价于<command>exit $?</command>.</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="execref"><command>exec</command></term>
	  <indexterm>
	    <primary>exec</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exec</secondary>
	  </indexterm>
	  <listitem>

	    <para>
			这个shell内建命令将使用一个特定的命令来取代当前进程. 
			一般的当shell遇到一个命令, 
			它会<link linkend="forkref">forks off</link>一个子进程来真正的运行命令. 
			使用<command>exec</command>内建命令, shell就不会fork了,
			并且命令的执行将会替换掉当前shell. 
			因此, 在脚本中使用时, 一旦<command>exec</command>所执行的命令执行完毕, 
	      那么它就会强制退出脚本. 
		  <footnote><para>除非<command>exec</command>命令被用来<link linkend="usingexecref">重新分配文件描述符</link>. 
		  </para></footnote>
	    </para>

	    <example id="ex54">
	      <title><command>exec</command>命令的效果</title>
	      <programlisting>&ex54;</programlisting>
	    </example>	    	   

	    <example id="selfexec">
	      <title>一个<command>exec</command>自身的脚本</title>
	      <programlisting>&selfexec;</programlisting>
	    </example>	    	   

	    <para><command>exec</command>命令还能够用来<link
				linkend="usingexecref">重新分配文件描述符</link>.
			比如, <userinput>exec &lt;zzz-file</userinput>将会用<filename>zzz-file</filename>来代替<filename>stdin</filename>. 
	      </para>

	    <note><para><link linkend="findref">find</link>命令的<option>-exec</option>选项与shell内建的<command>exec</command>命令是<replaceable>不同</replaceable>的.
	      </para></note>

	  </listitem>
	</varlistentry>
	

	<varlistentry>
	  <term><command>shopt</command><anchor id="shoptref"></term>
	  <indexterm>
	    <primary>shopt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shopt</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个命令允许shell在空闲时修改shell选项 (见<xref linkend="al">和<xref linkend="unal">). 
			它经常出现在<link linkend="filesref1">启动文件</link>中, 
			但在一般脚本中也常出现. 
			需要在<link linkend="bash2ref">版本2</link>之后的Bash中才支持. 

	      <programlisting>shopt -s cdspell
# 使用'cd'命令时,允许产生少量的拼写错误.
cd /hpme  # 噢! 应该是'/home'.
pwd       # /home
          # 拼写错误被纠正了.</programlisting></para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>caller</command><anchor id="callerref"></term>
	  <indexterm>
	    <primary>caller</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>caller</secondary>
	  </indexterm>
	  <listitem>
	    <para>将<command>caller</command>命令放到<link linkend="functionref">函数</link>中, 
	       将会在<filename>stdout</filename>上打印出函数的<emphasis>调用者</emphasis>信息. </para>


	<para><programlisting>#!/bin/bash

function1 ()
{
  # 在 function1 () 内部.
  caller 0   # 显示调用者信息.
}

function1    # 脚本的第9行.

# 9 main test.sh
# ^                 函数调用者所在的行号.
#   ^^^^            从脚本的"main"部分开始调用的.
#        ^^^^^^^    调用脚本的名字.

caller 0     # 没效果, 因为这个命令不在函数中. </programlisting></para>

	    <para><command>caller</command>命令也可以在一个被<link
	      linkend="sourceref">source</link>的脚本中返回<emphasis>调用者</emphasis>信息. 
	      当然这个调用者就是<link linkend="sourceref">source</link>这个脚本的脚本.
	      就像函数一样, 这是一个<quote>子例程调用</quote>. </para>

	    <para>你会发现这个命令在调试的时候特别有用. </para>

	  </listitem>
	</varlistentry>



      </variablelist>


      <variablelist id="intcommand">
        <title><anchor id="intcommand1">命令</title>

      <varlistentry>
	<term><anchor id="trueref"><command>true</command></term>
	  <indexterm>
	    <primary>true</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>true</secondary>
	  </indexterm>
	  <listitem><para>这是一个返回(<returnvalue>零</returnvalue>)成功<link
				  linkend="exitstatusref">退出状态码</link>的命令, 
			  但是除此之外不做任何事.
	  </para>

	  <para><programlisting># 死循环
while true   # 这里的true可以用":"来替换
do
   operation-1
   operation-2
   ...
   operation-n
   # 需要一种手段从循环中跳出来, 或者是让这个脚本挂起.
done</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>false</command></term>
	  <indexterm>
	    <primary>false</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>false</secondary>
	  </indexterm>
	  <listitem><para>这是一个返回失败<link
	  linkend="exitstatusref">退出状态码</link>的命令,
	    但是除此之外不做任何事. </para>

	  <para><programlisting># 测试 "false" 
if false
then
  echo "false evaluates \"true\""
else
  echo "false evaluates \"false\""
fi
# 失败会显示 "false"


# while "false" 循环 (空循环)
while false
do
   # 这里面的代码不会被执行. 
   operation-1
   operation-2
   ...
   operation-n
   # 什么事都没发生!
done   
</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>type [cmd]</command></term>
	  <indexterm>
	    <primary>type</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>type</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>which</secondary>
	  </indexterm>
	  <listitem><para>与外部命令<link
	    linkend="whichref">which</link>很相像,
	<command>type cmd</command>将会给出<quote>cmd</quote>的完整路径. 
	与<command>which</command>命令不同的是,
	<command>type</command>命令是Bash内建命令. 
	<option>-a</option>是<command>type</command>命令的一个非常有用的选项, 
	它用来鉴别参数是<replaceable>关键字</replaceable>还是<replaceable>内建命令</replaceable>, 
	也可以用来定位同名的系统命令. </para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>type '['</userinput>
<computeroutput>[ is a shell builtin</computeroutput>
<prompt>bash$ </prompt><userinput>type -a '['</userinput>
<computeroutput>[ is a shell builtin
 [ is /usr/bin/[</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>hash [cmds]</command></term>
	  <indexterm>
	    <primary>hash</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hash</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PATH</secondary>
	  </indexterm>
	  <listitem><para>在shell的hash表中, 

	        <footnote>
		<para><anchor id="hashref"></para>
			<para><emphasis>Hash</emphasis>是一种处理数据的方法, 
			   这种方法就是为表中的数据建立查找键.
			   <emphasis>而数据项本身</emphasis>是<quote>不规则</quote>的, 
		这样就需要通过一个简单的数学算法来产生一个数字, 这个数字被用来作为查找键. </para>

		<para>使用<emphasis>hash</emphasis>的一个最有利的优点就是提高了速度. 
		而缺点就是会产生<quote>冲撞</quote> --
		也就是说, 可能会有多个数据元素使用同一个主键.
		possible.</para>

		<para>关于hash的例子请参考<xref linkend="hashlib">和<xref linkend="hashexample">.</para>
	        </footnote>

			记录指定命令的路径名, 所以在shell或脚本中调用这个命令的话, 
			就不需要再在<varname>$PATH</varname>中重新搜索这个命令了. 
			如果不带参数的调用<command>hash</command>命令, 
	      它将列出所有已经被hash的命令. 
	      <option>-r</option>选项会重新设置hash表. </para>
	  </listitem>
	</varlistentry>


      <varlistentry>
	<term><command>bind</command></term>
	  <indexterm>
	    <primary>bind</primary>
	  </indexterm>
	  <indexterm>
	    <primary>bind</primary>
	    <secondary>key bindings </secondary>
	  </indexterm>
	  <listitem>

	  <para><command>bind</command>内建命令用来显示或修改<emphasis>readline</emphasis>
	    <footnote><para>在一个交互的shell中, <emphasis>readline</emphasis>库就是Bash用来读取输入的. 
				(译者注: 比如默认的Emacs风格的输入, 当然也可以改为vi风格的输入)
	      </para></footnote>
	  的键绑定.</para>

	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>help</command></term>
	  <indexterm>
	    <primary>help</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary></secondary>
	  </indexterm>
	  <listitem>
	  
	  <para>获得shell内建命令的一个小的使用总结.
	    与<link linkend="whatisref">whatis</link>命令比较象,
		但<command>help</command>命令是内建命令. </para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>help exit</userinput>
<computeroutput>exit: exit [n]
    Exit the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <sect1>
	<title>作业控制命令</title>


	<para>下边的作业控制命令需要一个<quote>作业标识符</quote>作为参数. 
		请参考本章结尾部分的<link
	  linkend="jobidtable">表格</link>. </para>

	<variablelist id="jccommandlist">

	  <varlistentry>
	    <term><command>jobs</command></term>
	  <indexterm>
	    <primary>jobs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>jobs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>ps</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ps</secondary>
	  </indexterm>
	    <listitem>

	      <para>在后台列出所有正在运行的作业, 给出作业号.
		并不象<command>ps</command>命令那么有用.</para>

              <note>
				  <para><emphasis>作业</emphasis>和<emphasis>进程</emphasis>的概念太容易混淆了. 
					 特定的<link linkend="builtinref">内建命令</link>, 
					 比如<command>kill</command>, <command>disown</command>, 
					 和<command>wait</command>命令即可以接受作业号为参数,
					也可以接受进程号为参数. 
					但是<command>fg</command>, 
					<command>bg</command>和<command>jobs</command>命令就只能接受作业号为参数. </para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>sleep 100 &</userinput>
<computeroutput>[1] 1384</computeroutput>

<prompt>bash $ </prompt><userinput>jobs</userinput>
<computeroutput>[1]+  Running                 sleep 100 &</computeroutput></screen>
	      </para>

	      <para><quote>1</quote>是作业号(作业是被当前shell所维护的), 
			  而<quote>1384</quote>是进程号(进程是被系统维护的). 
			  为了kill掉作业/进程, 或者使用<command>kill
		%1</command>或者使用<command>kill 1384</command>. 这两个命令都行.</para>

	      <para><emphasis>感谢, S.C.</emphasis></para>	
               </note>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>disown</command></term>
	  <indexterm>
	    <primary>disown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>disown</secondary>
	  </indexterm>
	    <listitem>
	      <para>从shell的激活作业表中删除作业. </para>
	    </listitem>
	  </varlistentry>


	<varlistentry>
	  <term><command>fg</command></term>
	  <term><command>bg</command></term>
	  <indexterm>
	    <primary>fg</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>foreground</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>background</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bg</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>fg</command>命令可以把一个在后台运行的作业放到前台来运行. 
			而<command>bg</command>命令将会重新启动一个挂起的作业, 
		   并且在后台运行它.
		   如果使用<command>fg</command>或者<command>bg</command>命令的时候没有指定作业号, 
	      那么默认将对当前正在运行的作业进行操作. </para>
	  </listitem>
	</varlistentry>

	  <varlistentry>
	    <term><anchor id="waitref"><command>wait</command></term>
	  <indexterm>
	    <primary>wait</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wait</secondary>
	  </indexterm>
	    <listitem>

			<para>停止脚本的运行, 
				直到后台运行的所有作业都结束为止, 或者如果传递了作业号或进程号为参数的话, 
				那么就直到指定作业结束为止. 
	        返回等待命令的<link linkend="exitstatusref">退出状态码</link>. </para>

	      <para>你可以使用<command>wait</command>命令来防止在后台作业没完成(这会产生一个孤儿进程)之前退出脚本. 
		</para>

	    <example id="ex39">
	      <title>在继续处理之前, 等待一个进程的结束</title>
	      <programlisting>&ex39;</programlisting>
	    </example>	    

	      <para>可选的, <command>wait</command>也可以接受一个作业标识符作为参数, 
			  比如, <command>wait%1</command>或者<command>wait $PPID</command>. 
			  请参考<link linkend="jobidtable">作业标识符表</link>.</para>

	      <para><anchor id="waithang"></para>
              <tip>
	      <para>在一个脚本中, 使用后台运行命令(&amp;)可能会使这个脚本挂起, 
			  直到敲<keycap>ENTER</keycap>, 挂起的脚本才会被恢复. 
			  看起来只有在这个命令的结果需要输出到<filename>stdout</filename>的时候, 
			  这种现象才会出现. 这是个很烦人的现象.
		  <programlisting>#!/bin/bash
# test.sh		  

ls -l &
echo "Done."</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>./test.sh</userinput>
<computeroutput>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
 _
</computeroutput>
               </screen>
	       </para>

              <para>看起来只要在后台运行命令的后边加上一个<command>wait</command>命令就会解决这个问题. 
		  <programlisting>#!/bin/bash
# test.sh		  

ls -l &
echo "Done."
wait</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>./test.sh</userinput>
<computeroutput>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh</computeroutput>
               </screen>
			   如果将后台运行命令的输出<link linkend="ioredirref">重定向</link>到文件中或<filename>/dev/null</filename>中, 
		也能解决这个问题.
              </para>
	      </tip>


	    </listitem>
	  </varlistentry>


	  <varlistentry>
	    <term><command>suspend</command></term>
	    <indexterm>
	      <primary>suspend</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>suspend</secondary>
	    </indexterm>
	    <listitem>
	      <para>这个命令的效果与<keycombo><keycap>Control</keycap><keycap>Z</keycap></keycombo>很相像, 
		但是它挂起的是这个shell(这个shell的父进程应该在合适的时候重新恢复它). </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>logout</command></term>
	  <indexterm>
	    <primary>logout</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>log out</secondary>
	  </indexterm>
	    <listitem>
	      <para>退出一个已经登陆上的shell, 也可以指定一个<link
	        linkend="exitstatusref">退出状态码</link>. </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="timesref"><command>times</command></term>
	  <indexterm>
	    <primary>times</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>times</secondary>
	  </indexterm>
	    <listitem>
	      <para>给出执行命令所占用的时间, 使用如下的形式进行输出:
		<screen><computeroutput>0m0.020s 0m0.020s</computeroutput></screen>
		这只能给出一个很有限的值, 因为它很少在shell脚本中出现.
		</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="killref"><command>kill</command></term>
	  <indexterm>
	    <primary>kill</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>kill</secondary>
	    </indexterm>
	    <listitem>
			<para>通过发送一个适当的<emphasis>结束</emphasis>信号, 
				来强制结束一个进程(请参考<xref
	      linkend="killprocess">).</para>

	    <example id="selfdestruct">
	      <title>一个结束自身的脚本程序</title>
	      <programlisting>&selfdestruct;</programlisting>
	    </example>
	      
		<note><para><userinput>kill -l</userinput>将会列出所有<link linkend="signald">信号</link>. 
				<userinput>kill -9</userinput>是<quote>必杀</quote>命令, 
				这个命令将会结束顽固的不想被<command>kill</command>掉的进程. 
				有时候<userinput>kill -15</userinput>也能干这个活. 
				一个<quote>僵尸进程</quote>, 僵尸进程就是子进程已经结束了, 
				但是<link linkend="forkref">父进程</link>还没kill掉这个子进程, 
				不能被登陆的用户kill掉 -- 
		因为你不能杀掉一些已经死了的东西 -- 
		但是<command>init</command>进程迟早会把它清除干净. 
		</para></note>

	    </listitem>
	  </varlistentry>


	<varlistentry>
	  <term><anchor id="killallref"><command>killall</command></term>
	  <indexterm>
	    <primary>killall</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>kill</secondary>
	  </indexterm>
	  <listitem><para><command>killall</command>命令将会通过<firstterm>名字</firstterm>来杀掉一个正在运行的进程, 
            而不是通过<link linkend="processidref">进程ID</link>.
	    如果某个特定的命令有多个实例正在运行, 
	    那么执行一次<emphasis>killall</emphasis>命令就会把这些实例<emphasis>全部</emphasis>杀掉.
	    </para>

	    <note><para>这里所指的<command>killall</command>命令是在<filename class="directory">/usr/bin</filename>中, 
	      而<emphasis>不是</emphasis><filename
	      class="directory">/etc/rc.d/init.d</filename>中的<link
	      linkend="killall2ref">killall脚本</link>.</para></note>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><command>command</command></term>
	  <indexterm>
	    <primary>command</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>command</secondary>
	  </indexterm>
	  <listitem><para>对于命令<quote>COMMAND</quote>, <command>command COMMAND</command>会直接禁用别名和函数的查找. 
	    </para>

		<para>译者注, 注意一下Bash执行命令的优先级:
				<programlisting>1	别名
2	关键字
3	函数
4	内建命令
5	脚本或可执行程序($PATH)</programlisting>
</para>


	    <note><para>这是shell用来影响脚本命令处理效果的三个命令之一.
	      另外两个分别是<link linkend="bltref">builtin</link>和<link
			  linkend="enableref">enable</link>.
		  (译者注: 当你想运行的命令或函数与内建命令同名时, 由于内建命令比外部命令的优先级高, 
		  而函数比内建命令的优先级高, 所以Bash将总会执行优先级比较高的命令. 
		  这样当你想执行优先级低的命令的时候, 就没有选择的余地了.
		  这三个命令就是用来为你提供这样的机会. )</para></note>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor id="bltref"><command>builtin</command></term>
	  <indexterm>
	    <primary>builtin</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>builtin</secondary>
	  </indexterm>
	  <listitem><para>当你使用<command>builtin
				  BUILTIN_COMMAND</command>的时候, 
			  只会调用shell<link
				  linkend="builtinref">内建命令</link><quote>BUILTIN_COMMAND</quote>, 
			  而暂时禁用同名的函数, 或者是同名的扩展命令.
	      </para>
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor id="enableref"><command>enable</command></term>
	  <indexterm>
	    <primary>enable</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>enable</secondary>
	  </indexterm>
	  <listitem>

	    <para>这个命令或者禁用内建命令或者恢复内建命令.
	      比如, <command>enable -n
	      kill</command>将禁用内建命令<link
		  linkend="killref">kill</link>, 
	  所以当我们调用<command>kill</command>命令时, 
	  使用的将是<filename>/bin/kill</filename>外部命令. </para>
	      
	    <para><anchor id="enableref1"><option>-a</option>选项会<command>enable</command>所有作为参数的shell内建命令, 
				不管它们之前是否被enable了. (译者注: 如果不带参数的调用<command>enable 
					-a</command>, 那么会恢复所有内建命令.)
	      <option>-f filename</option>选项将会从适当的编译过的目标文件
	        <footnote>
		  <para>一些可加载的内建命令的C源代码通常都放在<filename
		    class="directory">/usr/share/doc/bash-?.??/functions</filename>目录下.
		    </para>
		  <para>注意, <command>enable</command>的<option>-f</option>选项并不是所有系统都支持的. 
		    </para>
		</footnote>
	      中, 让<command>enable</command>命令以共享库的形式来加载<link linkend="builtinref">内建命令</link>. 
	     </para>	

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><command>autoload</command></term>
	  <indexterm>
	    <primary>autoload</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>autoloader</secondary>
	  </indexterm>
	  <listitem>

		  <para>这是从<emphasis>ksh</emphasis>中的autoloader命令移植过来的. 
			  一个带有<quote>autoload</quote>声明的函数, 在它第一次被调用的时候才会被加载. 
	      <footnote><para><command>autoload</command>命令与<link
	      linkend="declareref">typeset -fu</link>效果相同.</para></footnote>
	    这样做是为了节省系统资源. </para>

	  <para>注意, <command>autoload</command>命令并不是Bash核心安装时候的一部分. 
	    这个命令需要使用命令<command>enable -f</command>来加载(参考上边的enable命令).</para>

	    </listitem>
	  </varlistentry>

	</variablelist>

      <table id="jobidtable">
	<title>作业标识符</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>记法</entry>
	      <entry>含义</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>%N</option></entry>
	      <entry>作业号[N]</entry>
	    </row>
	    <row>
	      <entry><option>%S</option></entry>
		  <entry>以字符串<emphasis>S</emphasis>开头的被(命令行)调用的作业</entry>
	    </row>
	    <row>
	      <entry><option>%?S</option></entry>
	      <entry>包含字符串<emphasis>S</emphasis>的被(命令行)调用的作业</entry>
	    </row>
	    <row>
	      <entry><option>%%</option></entry>
	      <entry><quote>当前</quote>作业(前台最后结束的作业, 或后台最后启动的作业) </entry>
	    </row>
	    <row>
	      <entry><option>%+</option></entry>
	      <entry><quote>当前</quote>作业(前台最后结束的作业, 或后台最后启动的作业) </entry>
	    </row>
	    <row>
	      <entry><option>%-</option></entry>
	      <entry>最后的作业</entry>
	    </row>
	    <row>
	      <entry><option>$!</option></entry>
	      <entry>最后的后台进程</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      </sect1> <!-- Job Control Commands -->

  </chapter> <!-- Internal Commands and Builtins -->



  <chapter id="external">
      <title>外部过滤器, 程序和命令</title>

      <para><anchor id="externalref"></para>

      <para>标准的 UNIX 命令使得 shell 脚本更加灵活.通过简单的编程结构把shell指令和系统命令结
合起来,这才是脚本能力的所在. </para>

      <sect1 id="basic">
        <title>基本命令</title>

      <variablelist id="basiccommands">
        <title><anchor id="basiccommands1">新手必须要掌握的初级命令</title>

	<varlistentry>
	  <term><anchor id="lsref"><command>ls</command></term>
	  <indexterm>
	    <primary>ls</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ls</secondary>
	  </indexterm>
	  <listitem>
		  <para><quote>列出</quote>文件的基本命令. 
			  但是往往就是因为这个命令太简单, 所以我们总是低估它.
	      比如, 使用<option>-R</option>选项, 递归选项,
		  <command>ls</command>将会以目录树的形式列出所有文件. 
		  另一个很有用的选项<option>-S</option>, 将会按照文件尺寸列出所有文件,
	      <option>-t</option>, 将会按照修改时间来列出文件, 
	      <option>-i</option>选项会显示文件的inode(请参考<xref
	      linkend="idelete">).</para>

	    <example id="ex40">
	      <title>使用<command>ls</command>命令来创建一个烧录<abbrev>CDR</abbrev>的内容列表</title>
	      <programlisting>&ex40;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="catref"><command>cat</command></term>
	  <term><command>tac</command></term>
	  <indexterm>
	    <primary>cat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cat</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tac</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>cat</command>, 
			  是单词<wordasword>concatenate</wordasword>的缩写,
			  把文件的内容输出到<filename>stdout</filename>. 
			  当与重定向操作符(<token>></token>或<token>>></token>), 
			  一般都是用来将多个文件连接起来.

	        <programlisting># Uses of 'cat'
cat filename                          # 打印出文件内容.

cat file.1 file.2 file.3 &gt; file.123   # 把三个文件连接到一个文件中. </programlisting>

	      <command>cat</command>命令的<option>-n</option>选项是为了在目标文件中的所有行前边插入行号. 
		  <option>-b</option>也是用来加行号的, 
		  但是不对空行进行编号.
	      <option>-v</option>选项可以使用<token>^</token>标记法来echo出不可打印字符. 
		  <option>-s</option>选项可以把多个空行压缩成一个空行. </para>

            <para>请参考<xref linkend="lnum">和<xref linkend="rot13">.</para>

	    <note>
	    <para>
			在一个<link linkend="piperef">管道</link>中, 
			有一种把<filename>stdin</filename><link linkend="ioredirref">重定向</link>到一个文件中更有效的方法, 
            这种方法比使用<command>cat</command>文件的方法更高效. 
            </para>

            <para>
	    <programlisting>cat filename | tr a-z A-Z

tr a-z A-Z < filename   #  效果相同, 但是处理更少,
                        #+ 并且连管道都省掉了. </programlisting>
            </para>
	    </note>


		<para><command>tac</command>命令, 就是<wordasword>cat</wordasword>命令的反转, 
			这个命令将会从文件结尾部分列出文件的内容. </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>rev</command></term>
	  <indexterm>
	    <primary>rev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rev</secondary>
	  </indexterm>
	  <listitem>
		  <para>把每一行中的内容反转, 
			  并且输出到<filename>stdout</filename>上. 
			  这个命令与<command>tac</command>命令的效果是不同的, 
			  因为它并不反转行序, 而是把每行的内容反转.
	      </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>cat file1.txt</userinput>
<computeroutput>This is line 1.
 This is line 2.</computeroutput>


<prompt>bash$ </prompt><userinput>tac file1.txt</userinput>
<computeroutput>This is line 2.
 This is line 1.</computeroutput>


<prompt>bash$ </prompt><userinput>rev file1.txt</userinput>
<computeroutput>.1 enil si sihT
 .2 enil si sihT</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cp</command></term>
	  <indexterm>
	    <primary>cp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cp</secondary>
	  </indexterm>
	  <listitem>

	    <para><anchor id="cpref"></para>

	    <para>这是文件拷贝命令. <userinput>cp file1
				file2</userinput>把文件<filename>file1</filename>拷贝到<filename>file2</filename>, 
			如果<filename>file2</filename>存在的话, 那么<filename>file2</filename>将被覆盖(请参考<xref
	      linkend="ex42">).</para>

	     <tip>
	     <para>特别有用的选项就是<option>-a</option>选项, 
	       这是归档标志(目的是为了copy一个完整的目录树), 
	       <option>-u</option>是更新选项, 
	       <option>-r</option>和<option>-R</option>选项是递归标志. </para>
	       <para><programlisting>cp -u source_dir/* dest_dir
#  把源目录"同步"到目标目录上,
#+  也就是拷贝所有更新的文件和之前不存在的文件. </programlisting></para>
	       </tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mv</command></term>
	  <listitem>
		  <para>这是文件<emphasis>移动</emphasis>命令. 
			  它等价于<command>cp</command>和<command>rm</command>命令的组合. 
			  它可以把多个文件移动到目录中,甚
			至将目录重命名.
	      想察看<command>mv</command>在脚本中使用的例子, 
	      请参考<xref linkend="rfe">和<xref linkend="rn">. </para>

	    <note>
	    <para>当使用非交互脚本时, 
	      可以使用<command>mv</command>的<option>-f</option>(<emphasis>强制</emphasis>)选项来避免用户的输入. 
	      </para>

	    <para>当一个目录被移动到一个已存在的目录时, 那么它将成为目标目录的子目录.
	      </para>
	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>mv source_directory target_directory</userinput>

<prompt>bash$ </prompt><userinput>ls -lF target_directory</userinput>
<computeroutput>total 1
 drwxrwxr-x    2 bozo  bozo      1024 May 28 19:20 source_directory/</computeroutput>
	      </screen>
	    </para>
	    </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rm</command></term>
	  <indexterm>
	    <primary>rm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rm</secondary>
	  </indexterm>
	  <listitem>
		  <para>删除(清除)一个或多个文件. 
			  <option>-f</option>选项将强制删除文件, 
			  即使这个文件是只读的. 
			  并且可以用来避免用户输入(在非交互脚本中使用).
		  </para>

	    <note>
	      <para><command>rm</command>将无法删除以破折号开头的文件. 
		</para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>rm -badname</userinput>
<computeroutput>rm: invalid option -- b
 Try `rm --help' for more information.</computeroutput></screen>
	      </para>

		  <para>解决这个问题的一个方法就是在要删除的文件的前边加上<emphasis>./</emphasis> .

	      <screen><prompt>bash$ </prompt><userinput>rm ./-badname</userinput></screen>
	        
		另一种解决的方法是在文件名前边加上<quote> -- </quote>.

	      <screen><prompt>bash$ </prompt><userinput>rm -- -badname</userinput></screen>

	      </para>
	    </note>


		<warning><para>当使用递归参数<option>-r</option>时, 
				这个命令将会删除整个目录树. 
	      如果不慎的使用<command>rm -rf *</command>的话, 
	      那整个目录树就真的完了. </para></warning>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rmdir</command></term>
	  <indexterm>
	    <primary>rmdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rmdir</secondary>
	  </indexterm>
	  <listitem>
	    <para>删除目录. 但是只有这个目录中没有文件的时候
	      -- 当然会包含<quote>不可见的</quote><emphasis>点文件</emphasis>

		<footnote>
		  <para><anchor id="dotfilesref"></para>
			  <para><emphasis>点文件</emphasis>就是文件名以<emphasis>点</emphasis>开头的文件, 
				  比如<filename>~/.Xdefaults</filename>. 
				  当使用一般的<command>ls</command>命令时, 
				 这样的文件是不会被显示出来的. 
				 (当然<command>ls -a</command>会显示它们), 
				 所以它们也不会被意外的<command>rm -rf *</command>命令所删除. 
				 在用户的home目录中, 点文件一般被用作安装和配置文件.
		    </para>
		  </footnote>

	      -- 这个命令才会成功. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mkdir</command></term>
	  <indexterm>
	    <primary>mkdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkdir</secondary>
	  </indexterm>
	  <listitem>
	    <para>生成目录, 创建一个空目录. 比如,
			<userinput>mkdir -p project/programs/December</userinput>将会创建指定的目录, 
			即使project目录和programs目录都不存在.
			<replaceable>-p</replaceable>选项将会自动产生必要的父目录, 
			这样也就同时创建了多个目录. 
		</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="chmodref"><command>chmod</command></term>
	  <indexterm>
	    <primary>chmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chmod</secondary>
	  </indexterm>
	  <listitem>

	    <para>修改一个现存文件的属性(请参考<xref
	      linkend="ex44">).</para>

	    <para><programlisting>chmod +x filename
# 使得文件"filename"对所有用户都可执行.

chmod u+s filename
# 设置"filename"文件的"suid"位.
# 这样一般用户就可以在执行"filename"的时候, 拥有和文件宿主相同的权限.
# (这并不适用于shell脚本.)</programlisting></para>

	    <para><programlisting>chmod 644 filename
# 对文件"filename"的宿主设置r/w权限, 
# 对一般用户设置读权限
# (8进制模式). </programlisting></para>

	    <para><programlisting>chmod 1777 directory-name
# 对这个目录设置r/w和可执行权限, 并开放给所有人.
# 同时设置 "粘贴位".
# 这意味着,　只有目录宿主,
# 文件宿主, 当然, 
# 还有root可以删除这个目录中的任何特定的文件.</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chattr</command></term>
	  <indexterm>
	    <primary>chattr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chattr</secondary>
	  </indexterm>
	  <listitem>

		  <para>修改文件属性. 
			  这个命令与上边的<command>chmod</command>命令项类似, 
			  但是有不同的选项和不同的调用语法, 
			  并且这个命令只能工作在<emphasis>ext2</emphasis>文件系统中. </para>

		  <para><command>chattr</command>命令的一个特别有趣的选项是<option>i</option>. 
			 <command>chattr +i <filename>filename</filename></command>将使得这个文件被标记为永远不变. 
	      这个文件将不能被修改, 连接, 或删除,
		  <emphasis>即使是root也不行</emphasis>. 
		  这个文件属性只能被root设置和删除. 
		  类似的, <option>a</option>选项将会把文件标记为只能追加数据
	      </para>

	    <para>
	      <screen>
<prompt>root# </prompt><userinput>chattr +i file1.txt</userinput>


<prompt>root# </prompt><userinput>rm file1.txt</userinput>

<computeroutput>rm: remove write-protected regular file `file1.txt'? y
 rm: cannot remove `file1.txt': Operation not permitted</computeroutput>
	      </screen>
	    </para>

		<para>如果文件设置了<option>s</option>(安全)属性, 
			那么当这个文件被删除时, 这个文件所在磁盘的块将全部被0填充. </para>

		<para>如果文件设置了<option>u</option>(不可删除)属性, 那么当这个文件被删除后, 
			这个文件的内容还可以被恢复(不可删除). </para>

		<para>如果文件设置了<option>c</option>(压缩)属性, 
			那么当这个文件在进行写操作时, 它将自动被压缩, 
			并且在读的时候, 自动解压.
	      </para>

		  <note><para>使用<command>chattr</command>命令设置过属性的文件将不会显示在文件列表中(<command>ls 
					  -l</command>).</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="linkref"><command>ln</command></term>
	  <listitem>

		  <para>创建文件链接, 前提是这个文件是存在的. 
			  <quote>链接</quote>就是一个文件的引用, 
			  也就是这个文件的另一个名字. 
			  <command>ln</command>命令允许对同一个文件引用多个链接, 
			  并且是避免混淆的一个很好的方法(请参考<xref linkend="ex18">).</para>

			  <para><command>ln</command>对于文件来说只不过是创建了一个引用, 
				  一个指针而已, 因为创建出来的连接文件只有几个字节. 
			  </para>
	    
	    <para><anchor id="symlinkref"></para>

			<para>绝大多数使用<command>ln</command>命令时, 
				使用的是<option>-s</option>选项, 
				可以称为符号链接, 或<quote>软</quote>链接. 
				使用<option>-s</option>标志的一个优点是它可以穿越文件系统来链接目录. 
	      </para>

		  <para>关于使用这个命令的语法还是有点小技巧的. 
			  比如: <userinput>ln -s oldfile newfile</userinput>将对之前存在的<filename>oldfile</filename>产生一个新的连接, 
	      <filename>newfile</filename>. </para>

	    <caution><para>如果之前<filename>newfile</filename>已经存在的话, 
	      将会产生一个错误信息. </para></caution>


	    <sidebar><title>使用链接中的哪种类型?</title>

	      <para>就像John Macdonald解释的那样: </para>

		  <para>不论是那种类型的链接, 都提供了一种双向引用的手段 -- 也就是说, 
			  不管你用文件的哪个名字对文件内容进行修改, 
			  你修改的效果都即会影响到原始名字的文件, 
			  也会影响到链接名字的文件. 当你工作在更高层次的时候, 
			  才会发生软硬链接的不同. 硬链接的优点是, 原始文件与链接文件之间是相互独立的 
			  -- 如果你删除或者重命名旧文件, 那么这种操作将不会影响硬链接的文件, 
			  硬链接的文件讲还是原来文件的内容. 然而如果你使用软链接的话, 
			  当你把旧文件删除或重命名后, 软链接将再也找不到原来文件的内容了. 
			  而软链接的优点是它可以跨越文件系统(因为它只不过是文件名的一个引用, 
			  而并不是真正的数据). 与硬链接的另一个不同是, 
			  一个符号链接可以指向一个目录.</para>

		</sidebar>

            <para>链接给出了一种可以用多个名字来调用脚本的能力(当然这也适用于任何其他可执行的类型), 
	并且脚本的行为将依赖于脚本是如何被调用的. </para>

	    <example id="hellol">
	      <title>到底是Hello还是Good-bye</title>
	      <programlisting>&hellol;</programlisting>
	    </example>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>man</command></term>
	  <term><command>info</command></term>
	  <indexterm>
	    <primary>man</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>man</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>info</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>info</secondary>
	  </indexterm>
	  <listitem>

		  <para>这两个命令用来查看系统命令或安装工具的手册和信息. 
			  当两者都可用时, 
	      <emphasis>info</emphasis>页一般会比<emphasis>man</emphasis>页包含更多的细节描述. </para>

	  </listitem>
	</varlistentry>


      </variablelist>


        </sect1> <!-- End Basic Commands -->


      <sect1 id="moreadv">
        <title>复杂命令</title>

      <variablelist id="cclisting">
        <title><anchor id="cclisting1">更高级的用户命令</title>

	<varlistentry>
	  <term><anchor id="findref"><command>find</command></term>
	  <indexterm>
	    <primary>find</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>find</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>{}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>\;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\;</secondary>
	  </indexterm>

	  <listitem>
	    <para>-exec <replaceable>COMMAND</replaceable> \;</para>
	    <para>在每一个<command>find</command>匹配到的文件执行<replaceable>COMMAND</replaceable>命令. 
			命令序列以<token>;</token>结束(<quote>;</quote>是<link 
				linkend="escp">转义符</link>以保证shll传递到<command>find</command>命令中的字符不会被解释为其他的特殊字符). </para>


	  <para>
	      <screen><prompt>bash$ </prompt><userinput>find ~/ -name '*.txt'</userinput>
<computeroutput>/home/bozo/.kde/share/apps/karm/karmdata.txt
 /home/bozo/misc/irmeyc.txt
 /home/bozo/test-scripts/1.txt</computeroutput>
	      </screen>
	  </para>

	    <para><anchor id="curlybracketsref"></para>

			<para>如果<replaceable>COMMAND</replaceable>中包含<token>{}</token>, 
				那么<command>find</command>命令将会用所有匹配文件的路径名来替换<quote>{}</quote>. </para>

	  <para>
          <programlisting>find ~/ -name 'core*' -exec rm {} \;
# 从用户的 home 目录中删除所有的 core dump文件. </programlisting>
	  </para>


	  <para>
	  <programlisting>find /home/bozo/projects -mtime 1
#  列出最后一天被修改的
#+ 在/home/bozo/projects目录树下的所有文件.
#
#  mtime = 目标文件最后修改的时间
#  ctime = 修改后的最后状态(通过'chmod'或其他方法)
#  atime = 最后访问时间

DIR=/home/bozo/junk_files
find "$DIR" -type f -atime +5 -exec rm {} \;
#                                      ^^
#  大括号就是"find"命令用来替换目录的地方.
#
#  删除至少5天内没被访问过的
#+ "/home/bozo/junk_files" 中的所有文件.
#
#  "-type filetype", where
#  f = regular file
#  d = directory, etc.
#  ('find' 命令的man页包含有完整的选项列表.) </programlisting>
          </para>



	    <para><programlisting>find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

# 在 /etc 目录中的文件找到所所有包含 IP 地址(xxx.xxx.xxx.xxx) 的文件.
# 可能会查找到一些多余的匹配. 我们如何去掉它们呢?

# 或许可以使用如下方法:

find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \
| grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
#
#  [:digit:] 是一种字符类.
#+ 关于字符类的介绍请参考 POSIX 1003.2 标准化文档. 

# 感谢, Stephane Chazelas. 
</programlisting></para>


            <note><para><command>find</command>命令的<option>-exec</option>选项不应该与shell中的内建命令<link
	      linkend="execref">exec</link>相混淆. </para></note>

	    <example id="ex57">
	      <title><command>糟糕的文件名</command>, 删除当前目录下文件名中包含一些糟糕字符(包括<link
		linkend="whitespaceref">空白</link>的文件.</title>
	      <programlisting>&ex57;</programlisting>
	    </example>

	    <example id="idelete">
	      <title>通过文件的<emphasis>inode</emphasis>号来删除文件</title>
	      <programlisting>&idelete;</programlisting>
	    </example>

	    <para>请参考<xref linkend="ex48">, <xref linkend="ex58">,
		和<xref linkend="findstring"> 这些例子展示了如何使用<command>find</command>命令. 
		对于这个强大而又复杂的命令来说, 查看man页可以获得更多的细节. 
	      </para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="xargsref"><command>xargs</command></term>
	  <indexterm>
	    <primary>xargs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>xargs</secondary>
	  </indexterm>
	  <listitem>
		  <para>这是给命令传递参数的一个过滤器, 也是组合多个命令的一个工具. 
			  它把一个数据流分割为一些足够小的块, 
			  以方便过滤器和命令进行处理. 
			  由此这个命令也是<link linkend="backquotesref">后置引用</link>的一个强有力的替换. 
			  当在一般情况下使用<errorname>过多参数</errorname>的<link 
				  linkend="commandsubref">命令替换</link>都会产生失败的现象, 
			  这时候使用<command>xargs</command>命令来替换, 一般都能成功. 
			  <footnote><para>即使在某些不必非得强制使用<firstterm>xargs</firstterm>的情况下, 
		使用这个命令也会明显的提高多文件批处理执行命令的速度. </para></footnote>
	      一般的, <command>xargs</command>从<filename>stdin</filename>或者管道中读取数据, 
	      但是它也能够从文件的输出中读取数据. </para>

	  <para><command>xargs</command>的默认命令是<link linkend="echoref">echo</link>. 
		  这意味着通过管道传递给<command>xargs</command>的输入将会包含换行和空白, 
		  不过通过<command>xargs</command>的处理, 
		  换行和空白将被空格取代.
	      
	      <screen>
<prompt>bash$ </prompt><userinput>ls -l</userinput>
<computeroutput>total 0
 -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file1
 -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file2</computeroutput>



<prompt>bash$ </prompt><userinput>ls -l | xargs</userinput>
<computeroutput>total 0 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file1 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file2</computeroutput>



<prompt>bash$ </prompt><userinput>find ~/mail -type f | xargs grep "Linux"</userinput>
<computeroutput>./misc:User-Agent: slrn/0.9.8.1 (Linux)
 ./sent-mail-jul-2005: hosted by the Linux Documentation Project.
 ./sent-mail-jul-2005: (Linux Documentation Project Site, rtf version)
 ./sent-mail-jul-2005: Subject: Criticism of Bozo's Windows/Linux article
 ./sent-mail-jul-2005: while mentioning that the Linux ext2/ext3 filesystem
 . . .</computeroutput>
	      </screen>
	      
	      </para>

	    <para><userinput>ls | xargs -p -l gzip</userinput> 使用<link
				linkend="gzipref">gzips</link>压缩当前目录下的每个文件, 
		   每次压缩一个, 并且在每次压缩前都提示用户. </para>

	    <tip>
	    <para>一个有趣的<command>xargs</command>选项是<option>-n <replaceable>NN</replaceable></option>,
	      <replaceable>NN</replaceable>用来限制每次传递进来参数的个数. </para>
	    <para><userinput>ls | xargs -n 8 echo</userinput>以每行<literal>8</literal>列的形式列出当前目录下的所有文件. </para>
	    </tip>  
	      
	      
	    <tip>
			<para>另一个有用的选项是<option>-0</option>, 
			使用<command>find -print0</command><command>grep -lZ</command>这两种组合方式. 这允许处理包含空白或引号的参数. </para>
	      
	    <para>
	    <userinput>find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f</userinput>
	    </para>
	    
	    <para>
	    <userinput>grep -rliwZ GUI / | xargs -0 rm -f</userinput>
	    </para>

	    <para>上边两行都可用来删除任何包含<quote>GUI</quote>的文件.
	      <emphasis>(感谢, S.C.)</emphasis></para>
	    </tip>



	    <example id="ex41">
	      <title>Logfile: 使用<command>xargs</command>来监控系统log</title>
	      <programlisting>&ex41;</programlisting>
	    </example>	    

	    <para><link linkend="curlybracketsref">As in
	      <command>find</command></link>, a curly bracket
	      pair serves as a placeholder for replacement text.</para>

	    <example id="ex42">
	      <title>把当前目录下的文件拷贝到另一个文件中</title>
	      <programlisting>&ex42;</programlisting>
	    </example>	    

	    <example id="killbyname">
	      <title>通过名字kill进程</title>
	      <programlisting>&killbyname;</programlisting>
	    </example>

	    <example id="wf2">
	      <title>使用<command>xargs</command><command>分析单词出现的频率</command>
</title>
	      <programlisting>&wf2;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="exprref"><userinput>expr</userinput></term>
	  <indexterm>
	    <primary>expr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expr</secondary>
	  </indexterm>
	  <listitem>
		  <para>通用求值表达式: 
			  通过给定的操作(参数必须以空格分开)连接参数, 
			  并对参数求值. 可以使算术操作, 比较操作, 
			  字符串操作或者是逻辑操作. 
	      </para>

	    <variablelist>
	      <varlistentry>
		<term><userinput>expr 3 + 5</userinput></term>
		<listitem>
		  <para>返回<literal>8</literal></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>expr 5 % 3</userinput></term>
		<listitem>
		  <para>返回2</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>expr 1 / 0</userinput></term>
		<listitem>
		  <para>返回错误消息, <emphasis>expr: division by
		    zero</emphasis></para>
                  <para>不允许非法的算术操作. </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>expr 5 \* 3</userinput></term>
		<listitem>
		<para>返回15</para>
		<para>在算术表达式<command>expr</command>中使用乘法操作时, 
			乘法符号必须被转义.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>y=`expr $y + 1`</userinput></term>
		<listitem>
			<para>增加变量的值, 
				与<userinput>let y=y+1</userinput>和<userinput>y=$(($y+1))</userinput>的效果相同. 
				这是使用<link linkend="arithexpref">算术表达式</link>的一个例子. </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><anchor id="expextrsub"><userinput>z=`expr substr
		$string $position $length`</userinput></term>
		<listitem>
		  <para>在位置$position上提取$length长度的子串. </para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <example id="ex45">
	      <title>使用<command>expr</command></title>
	      <programlisting>&ex45;</programlisting>
	    </example>	    
	    
	    <important>
			<para><link linkend="nullref">:</link>操作可以替换<command>match</command>命令. 
			比如, <userinput>b=`expr $a : [0-9]*`</userinput>与上边所使用的<userinput>b=`expr match $a
	      [0-9]*`</userinput>完全等价. </para>

	    <para><programlisting>&ex45a;</programlisting></para>
	      </important>

	  </listitem>
	</varlistentry>

       </variablelist>

	   <para>上边的脚本展示了<command>expr</command>如何使用<emphasis>转义括号对-- \( ... \) --</emphasis> 
		   和<link linkend="regexref">正则表达式</link>一起来分析和匹配子串. 
	      下边是另外一个例子, 这次的例子是真正的<quote>应用用例</quote>. 

	        <programlisting># 去掉字符串开头和结尾的空白. 
LRFDATE=`expr "$LRFDATE" : '[[:space:]]*\(.*\)[[:space:]]*$'`

#  来自于Peter Knowle的"booklistgen.sh"脚本
#+ 用来将文件转换为Sony Librie格式.
#  (http://booklistgensh.peterknowles.com)</programlisting>

	      </para>


            <para><link linkend="perlref">Perl</link>,
	      <link linkend="sedref">sed</link>, 和<link
	      linkend="awkref">awk</link>是更强大的字符串分析工具. 
	  在脚本中加入一段比较短的<command>sed</command>或者<command>awk</command><quote>子程序</quote>(参考<xref linkend="wrapper">), 
		  比使用<command>expr</command>更有吸引力. 
	      </para>


            <para>参考<xref linkend="String-Manipulation">可以了解到更多使用<command>expr</command>进行字符串操作的例子. </para>


	</sect1> <!-- End Complex Commands -->



      <sect1 id="timedate">
        <title>时间/日期 命令</title>

       <variablelist id="tdlisting">
         <title><anchor id="tdlisting1">时间/日期和计时</title>

	<varlistentry>
	  <term><anchor id="dateref"><command>date</command></term>
	  <indexterm>
	    <primary>date</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>date</secondary>
	  </indexterm>
	  <listitem>
		  <para>直接调用<command>date</command>命令就会把日期和时间输出到 <filename>stdout</filename>上. 
			  这个命令有趣的地方在于它的格式化和分析选项上.
	      </para>

	    <example id="ex51">
	      <title>使用<command>date</command>命令</title>
	      <programlisting>&ex51;</programlisting>
	    </example>	    	   

	    <para><option>-u</option>选项将给出UTC时间(Universal
	      Coordinated Time).</para>


	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>date</userinput>
<computeroutput>Fri Mar 29 21:07:39 MST 2002</computeroutput>



<prompt>bash$ </prompt><userinput>date -u</userinput>
<computeroutput>Sat Mar 30 04:07:42 UTC 2002</computeroutput>
	      </screen>
	      </para>


	      <para><anchor id="daterandref"></para>
			  <para><command>date</command>命令有许多的输出选项. 
	       比如<option>%N</option>将以十亿分之一为单位表示当前时间. 
	       这个选项的一个有趣的用法就是用来产生一个6位的随机数.
	       <programlisting>date +%N | sed -e 's/000$//' -e 's/^0//'
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# 去掉开头和结尾的0. </programlisting>
	      </para>

	      <para>当然, 还有许多其他的选项(请察看<command>man date</command>).
	        <programlisting>date +%j
# 显示今天是本年度的第几天(从1月1日开始计算).

date +%k%M
# 使用24小时的格式来显示当前小时数和分钟数.



# 'TZ'参数允许改变当前的默认时区.
date                 # Mon Mar 28 21:42:16 MST 2005
TZ=EST date          # Mon Mar 28 23:42:16 EST 2005
# 感谢, Frank Kannemann 和 Pete Sjoberg 提供了这个技巧. 


SixDaysAgo=$(date --date='6 days ago')
OneMonthAgo=$(date --date='1 month ago')  # 四周前(不是一个月).
OneYearAgo=$(date --date='1 year ago')</programlisting></para>

              <para>请参考<xref linkend="ex58">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>zdump</command></term>
	  <indexterm>
	    <primary>zdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>time zone dump</secondary>
	  </indexterm>
	  <listitem>
	    <para>时区dump: 查看特定时区的当前时间. </para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>zdump EST</userinput>
<computeroutput>EST  Tue Sep 18 22:09:22 2001 EST</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="timref"><command>time</command></term>
	  <indexterm>
	    <primary>time</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>time</secondary>
	  </indexterm>
	  <listitem>

	    <para>输出统计出来的命令执行的时间. </para>

	    <para><userinput>time ls -l /</userinput> 给出的输出大概是如下格式: 
<screen><computeroutput>0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k
 0inputs+0outputs (149major+27minor)pagefaults 0swaps</computeroutput></screen>
	  </para>

	  <para>请参考前边章节所讲的一个类似的命令<link
	    linkend="timesref">times</link>. </para>

	  <note><para>在Bash的<link linkend="bash2ref">2.0版本</link>中, 
			  <command>time</command>成为了shell的一个保留字, 
			  并且在一个带有管道的命令行中, 这个命令的行为有些小的变化. 
	    </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="touchref"><command>touch</command></term>
	  <indexterm>
	    <primary>touch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>touch</secondary>
	  </indexterm>
	  <listitem>

		  <para>这是一个用来更新文件被访问或修改的时间的工具, 
			  这个时间可以是当前系统的时间,也可以是指定的时间, 
			  这个命令也用来产生一个新文件. 
			  命令<userinput>touch zzz</userinput>将产生一个<filename>zzz</filename>为名字的0字节长度文件, 
			  当然前提是<filename>zzz</filename>文件不存在. 
			  为了存储时间信息, 就需要一个时间戳为空的文件, 
			  比如当你想跟踪一个工程的修改时间的时候, 这就非常有用了.
	      </para>

		  <note><para><command>touch</command>命令等价于<userinput>: 
					  &gt;&gt; newfile</userinput>或<userinput>&gt;&gt; 
					  newfile</userinput>(对于一个普通文件). </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="atref"><command>at</command></term>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cron</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cron</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>at</command>命令是一个作业控制命令, 
			  用来在指定时间点上执行指定的命令集合. 
			  它有点像<link linkend="cronref">cron</link>命令, 
			  然而, <command>at</command>命令主要还是用来执行那种一次性执行的命令集合. </para>
	  
	    <para><userinput>at 2pm January 15</userinput>将会产生提示, 
	      提示你输入需要在这个时间上需要执行的命令序列. 
		  这些命令应该是可以和shll脚本兼容的, 
		  因为实际上在一个可执行的脚本中, 
	      用户每次只能输入一行. 
	      输入将以<link linkend="ctldref">Ctl-D</link>结束. </para>

	  <para>你可以使用<option>-f</option>选项或者使用(<token><</token>)重定向操作符, 
		  来让<command>at</command>命令从一个文件中读取命令集合. 
	      这个文件其实就一个可执行的的脚本, 虽然它是一个不可交互的脚本. 
	      在文件中包含一个<link linkend="runpartsref">run-parts</link>命令, 
	      对于执行一套不同的脚本来说是非常聪明的做法. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>at 2:30 am Friday < at-jobs.list</userinput>
<computeroutput>job 2 at 2000-10-27 02:30</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>batch</command></term>
	  <indexterm>
	    <primary>batch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>batch</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>batch</command>作业控制命令与<command>at</command>令的行为很相像, 
			  但是<command>batch</command>命令被用来在系统平均负载量降到<literal>.8</literal>以下时执行一次性的任务. 
			  与<command>at</command>命令相似的是, 
			  它也可以使用<option>-f</option>选项来从文件中读取命令. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cal</command></term>
	  <indexterm>
	    <primary>cal</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cal</secondary>
	  </indexterm>
	  <listitem>
		  <para>从<filename>stdout</filename>中输出一个格式比较整齐的日历. 
			  既可以指定当前年度, 也可以指定过去或将来的某个年度. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="sleepref"><command>sleep</command></term>
	  <indexterm>
	    <primary>sleep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sleep</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个命令与一个等待循环的效果一样. 
			  你可以指定需要暂停的秒数, 这段时间将什么都不干. 
			  当一个后台运行的进程需要偶尔检测一个事件时, 这个功能很有用. 
			  也可用于计时. 
	      请参考<xref linkend="online">.
	      <programlisting>sleep 3     # 暂停3秒. </programlisting>
	    </para>

	    <note><para><command>sleep</command>默认是以秒为单位, 
	      但是你也可以指定分钟, 小时, 或者天数为单位.
	      <programlisting>sleep 3 h   # 暂停3小时!</programlisting>
            </para></note>

			<note><para>如果你想每隔一段时间来运行一个命令的话, 
				那么<link linkend="watchref">watch</link>命令将比<command>sleep</command>命令好得多. 
	      </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>usleep</command></term>
	  <indexterm>
	    <primary>usleep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>usleep</secondary>
	  </indexterm>
	  <listitem>
		  <para><emphasis>指定需要sleep的微秒数</emphasis> 
			  (<quote>u</quote>会被希腊人读成<quote>mu</quote>, 
			  或者是 micro- 前缀). 
			  与上边的<command>sleep</command>命令相同, 
	      但这个命令以微秒为单位. 
		  当需要精确计时, 
		  或者需要非常频繁的监控一个正在运行进程的时候, 
		  这个命令非常有用. </para>

	    <para>  
	      <programlisting>usleep 30     # 暂停30微秒. </programlisting>
	    </para>

	    <para>这个命令是Red Hat的<emphasis>initscripts /
	      rc-scripts</emphasis>包的一部分. </para>

  <caution><para>事实上<command>usleep</command>命令并不能提供非常精确的计时, 
		  所以如果你需要运行一个实时的任务的话, 这个命令并不适合.
	      </para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>hwclock</command></term>
	  <term><command>clock</command></term>
	  <indexterm>
	    <primary>hwclock</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hwclock</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>clock</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>clock</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>hwclock</command>命令可以访问或调整硬件时钟. 
			  这个命令的一些选项需要具有root权限. 
	      在系统启动的时候, <filename>/etc/rc.d/rc.sysinit</filename>, 
	      会使用<command>hwclock</command>来从硬件时钟中读取并设置系统时间. </para>

	    <para><command>clock</command>命令与<command>hwclock</command>命令完全相同. </para>
	  </listitem>
	</varlistentry>


       </variablelist>
       
        </sect1> <!-- End Time / Date Commands -->




      <sect1 id="textproc">
        <title>文本处理命令</title>

       <variablelist id="tpcommandlisting">
         <title><anchor id="tpcommandlisting1">处理文本和文本文件的命令</title>

	<varlistentry>
	  <term><anchor id="sortref"><command>sort</command></term>
	  <indexterm>
	    <primary>sort</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sort</secondary>
	  </indexterm>
	  <listitem>
		  <para>文件排序, 通常用在管道中当过滤器来使用. 
			  这个命令可以依据指定的关键字或指定的字符位置, 
			  对文件行进行排序. 使用<option>-m</option>选项, 
			  它将会合并预排序的输入文件. 
	      想了解这个命令的全部参数请参考这个命令的<emphasis>info页</emphasis>. 
		  请参考<xref linkend="findstring">, 
			  <xref linkend="symlinks">, 和<xref linkend="makedict">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tsort</command></term>
	  <indexterm>
	    <primary>tsort</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>topological sort</secondary>
	  </indexterm>
	  <listitem>
		  <para>拓扑排序, 
			  读取以空格分隔的有序对, 
			  并且依靠输入模式进行排序. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="uniqref"><command>uniq</command></term>
	  <indexterm>
	    <primary>uniq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uniq</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个过滤器将会删除一个已排序文件中的重复行.
	      这个命令经常出现在<link linkend="sortref">sort</link>命令的管道后边. 
	      <programlisting>cat list-1 list-2 list-3 | sort | uniq > final.list
# 将3个文件连接起来,
# 将它们排序,
# 删除其中重复的行,
# 最后将结果重定向到一个文件中. </programlisting></para>
 
             <para><option>-c</option>用来统计每行出现的次数, 并把次数作为前缀放到输出行的前面. </para>
	     <para>
	      <screen>
<prompt>bash$ </prompt><userinput>cat testfile</userinput>
<computeroutput>This line occurs only once.
 This line occurs twice.
 This line occurs twice.
 This line occurs three times.
 This line occurs three times.
 This line occurs three times.</computeroutput>


<prompt>bash$ </prompt><userinput>uniq -c testfile</userinput>
<computeroutput>      1 This line occurs only once.
       2 This line occurs twice.
       3 This line occurs three times.</computeroutput>


<prompt>bash$ </prompt><userinput>sort testfile | uniq -c | sort -nr</userinput>
<computeroutput>      3 This line occurs three times.
       2 This line occurs twice.
       1 This line occurs only once.</computeroutput>
	      </screen>
	     </para>

	     <para><userinput>sort INPUTFILE | uniq -c | sort -nr</userinput>
			 命令先对<filename>INPUTFILE</filename>文件进行排序, 
			 然后统计<emphasis>每行出现的次数</emphasis>
			 (<command>sort</command>命令的<option>-nr</option>选项会产生一个数字的反转排序). 
			 这种命令模板一般都用来分析log文件或者用来分析字典列表, 
	       或者用在那些需要检查文本词汇结构的地方. 
	       </para>

	    <example id="wf">
	      <title>分析单词出现的频率</title>
	      <programlisting>&wf;</programlisting>
	    </example>	    

	     <para>
	       <screen>
<prompt>bash$ </prompt><userinput>cat testfile</userinput>
<computeroutput>This line occurs only once.
 This line occurs twice.
 This line occurs twice.
 This line occurs three times.
 This line occurs three times.
 This line occurs three times.</computeroutput>


<prompt>bash$ </prompt><userinput>./wf.sh testfile</userinput>
<computeroutput>      6 this
       6 occurs
       6 line
       3 times
       3 three
       2 twice
       1 only
       1 once</computeroutput>
	       </screen>
	     </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="expandref"><command>expand</command></term>
	  <term><command>unexpand</command></term>
	  <indexterm>
	    <primary>expand</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expand</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unexpand</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unexpand</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>expand</command>命令将会把每个tab转化为一个空格. 
			  这个命令经常用在管道中. 
	      </para>
		  <para><command>unexpand</command>命令将会把每个空格转化为一个tab. 
			  效果与<command>expand</command>命令相反. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="cutref"><command>cut</command></term>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  <listitem>
		  <para>一个从文件中提取特定域的工具. 
			  这个命令与<link linkend="awkref">awk</link>中使用的<userinput>print 
				  $N</userinput>命令很相似, 
			 但是更受限. 
			 在脚本中使用<command>cut</command>命令会比使用<command>awk</command>命令来得容易一些. 
			 最重要的选项就是<option>-d</option>(字段定界符)和<option>-f</option>(域分隔符)选项. </para>

	    <para>使用<command>cut</command>来获得所有mount上的文件系统的列表: 
	      <programlisting>cut -d ' ' -f1,2 /etc/mtab</programlisting></para>

	    <para>使用<command>cut</command>命令列出OS和内核版本:
	      <programlisting>uname -a | cut -d" " -f1,3,11,12</programlisting></para>

	    <para>使用<command>cut</command>命令从e-mail中提取消息头: 

	      <screen><prompt>bash$ </prompt><userinput>grep '^Subject:' read-messages | cut -c10-80</userinput>
<computeroutput>Re: Linux suitable for mission-critical apps?
 MAKE MILLIONS WORKING AT HOME!!!
 Spam complaint
 Re: Spam complaint</computeroutput></screen>
	    </para>

	    <para>使用<command>cut</command>命令来分析一个文件: 
	      <programlisting># 列出所有在/etc/passwd中的用户. 

FILENAME=/etc/passwd

for user in $(cut -d: -f1 $FILENAME)
do
  echo $user
done

# 感谢Oleg Philon对此的建议. </programlisting></para>

	    <para><userinput>cut -d ' ' -f2,3 filename</userinput>等价于<userinput>awk -F'[ ]' '{ print $2, $3 }' filename</userinput></para>

            <note>
	    <para>你甚至可以指定换行符作为字段定界符. 这个小伎俩实际上就是在命令行上插入一个换行(<keycap>RETURN</keycap>). (译者: linux使用lf作为换行符). </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>cut -d'
 ' -f3,7,19 testfile</userinput>
<computeroutput>This is line 3 of testfile.
 This is line 7 of testfile.
 This is line 19 of testfile.</computeroutput>
	      </screen>
	  </para>

	  <para>感谢, Jaka Kranjc指出这点. </para>
            </note>

	    <para>请参考<xref linkend="base">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>paste</command></term>
	  <indexterm>
	    <primary>paste</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>paste</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	  <listitem>
		  <para>将多个文件, 以每个文件一列的形式合并到一个文件中, 
			  合并后文件中的每一列就是原来的一个文件. 
	      与<command>cut</command>结合使用, 经常用于创建系统log文件. 
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>join</command></term>
	  <indexterm>
	    <primary>join</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>join</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个命令与<command>paste</command>命令属于同类命令. 
			  但是它能够完成某些特殊的目地. 
			  这个强力工具能够以一种特殊的形式来合并两个文件, 
			  这种特殊的形式本质上就是一个关联数据库的简单版本. 
	      </para>

	    <para><command>join</command>命令只能够操作两个文件. 
	      它可以将那些具有特定标记域(通常是一个数字标签)的行合并起来,
	      并且将结果输出到<filename>stdout</filename>. 
	      被加入的文件应该事先根据标记域进行排序以便于能够正确的匹配. 
	      </para>

	      <para><programlisting>File: 1.data

100 Shoes
200 Laces
300 Socks</programlisting></para>
      
              <para><programlisting>File: 2.data

100 $40.00
200 $1.00
300 $2.00</programlisting></para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>join 1.data 2.data</userinput>
<computeroutput>File: 1.data 2.data

 100 Shoes $40.00
 200 Laces $1.00
 300 Socks $2.00</computeroutput>
	      </screen>
	    </para>

	    <note><para>在输出中标记域将只会出现一次. 
	      </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>head</command></term>
	  <indexterm>
	    <primary>head</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>head</secondary>
	  </indexterm>
	  <listitem>
		  <para>把文件的头部内容打印到<filename>stdout</filename>上(默认为<literal>10</literal>行, 
			  可以自己修改). 这个命令有一些比较有趣的选项. 

	    <example id="scriptdetector">
	      <title>哪个文件是脚本?</title>
	      <programlisting>&scriptdetector;</programlisting>
	    </example>	    

	    <example id="rnd">
	      <title>产生10-进制随机数</title>
	      <programlisting>&rnd;</programlisting>
	    </example>	    

	      请参考<xref linkend="ex52">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tail</command></term>
	  <indexterm>
	    <primary>tail</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tail</secondary>
	  </indexterm>
	  <listitem>
		  <para>将一个文件结尾部分的内容输出到<filename>stdout</filename>中(默认为<literal>10</literal>行). 
			通常用来跟踪一个系统logfile的修改情况, 
			如果使用<option>-f</option>选项的话, 
			这个命令将会继续显示添加到文件中的行. 
	      </para>

	   <example id="ex12">
	     <title>使用<command>tail</command>命令来监控系统log</title>
	     <programlisting>&ex12;</programlisting>
	   </example>

	      <tip>
			  <para>为了列出一个文本文件中的指定行的内容, 
			可以将<command>head</command>命令的输出通过<link linkend="piperef">管道</link>传递到<command>tail -1</command>中. 
		比如<userinput>head -8 database.txt | tail
		-1</userinput>将会列出<filename>database.txt</filename>文件第8行的内容. </para>
	      <para>下边是将一个文本文件中指定范围的所有行都保存到一个变量中:
	        <programlisting>var=$(head -$m $filename | tail -$n)

# filename = 文件名
# m = 从文件开头到块结尾的行数
# n = 想保存到变量中的指定行数(从块结尾开始截断)</programlisting></para>
	      </tip>

		  <para>请参考<xref linkend="ex41">, 
		  <xref linkend="ex52">和<xref linkend="online">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="grepref"><command>grep</command></term>
	  <indexterm>
	    <primary>grep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>grep</secondary>
	  </indexterm>
	  <listitem>
	    <para>使用<link linkend="regexref">正则表达式</link>的一个多用途文本搜索工具. 
	      这个命令本来是<command>ed</command>行编辑器中的一个命令/过滤器: 
	      <userinput>g/re/p</userinput> -- <emphasis>global -
	      regular expression - print</emphasis>.</para>

	    <para><cmdsynopsis>
		<command>grep</command> <arg
		choice="plain"><replaceable>pattern</replaceable></arg>
		<arg choice="opt"
		rep="repeat"><replaceable>file</replaceable></arg>
	      </cmdsynopsis>在文件中搜索所有<replaceable>pattern</replaceable>出现的位置, 
		  <replaceable>pattern</replaceable>既可以是要搜索的字符串, 
		  也可以是一个正则表达式. 
	      </para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>grep '[rst]ystem.$' osinfo.txt</userinput>
<computeroutput>The GPL governs the distribution of the Linux operating system.</computeroutput>
	      </screen>
	      </para>

		  <para>如果没有指定文件参数, 
			  <command>grep</command>通常用在<link linkend="piperef">管道</link>中对<filename>stdout</filename>进行过滤. 
	      </para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>ps ax | grep clock</userinput>
<computeroutput>765 tty1     S      0:00 xclock
 901 pts/1    S      0:00 grep clock</computeroutput>
	      </screen>
	      </para>

	    <para><option>-i</option> 选项在搜索时忽略大小写. </para>

	    <para><option>-w</option> 选项用来匹配整个单词. </para>

		<para><option>-l</option> 选项仅列出符合匹配的文件, 
			而不列出匹配行. </para>

		<para><option>-r</option> (递归) 选项不仅在当前工作目录下搜索匹配, 
			而且搜索子目录. </para>

	    <para><option>-n</option> 选项列出所有匹配行, 并显示行号. </para>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>grep -n Linux osinfo.txt</userinput>
<computeroutput>2:This is a file containing information about Linux.
 6:The GPL governs the distribution of the Linux operating system.</computeroutput>
	      </screen>
	      </para>

	    <para><option>-v</option> (或者<option>--invert-match</option>)选项将会显示所有<emphasis>不匹配的行</emphasis>.
	      <programlisting>grep pattern1 *.txt | grep -v pattern2

# 匹配在"*.txt"中所有包含 "pattern1"的行, 
# 而***不显示***匹配包含"pattern2"的行.	      
</programlisting></para>

	    <para><option>-c</option> (<option>--count</option>)
	      选项将只会显示匹配到的行数的总数,而不会列出具体的匹配.

	        <programlisting>grep -c txt *.sgml   # (在 "*.sgml" 文件中, 匹配"txt"的行数的总数.)


#   grep -cz .
#            ^ 点
# 意思是计数 (-c) 所有以空字符分割(-z) 的匹配 "."的项
# "."是正则表达式的一个符号, 表达匹配任意一个非空字符(至少要包含一个字符).
# 
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz .     # 3
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '$'   # 5
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '^'   # 5
#
printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -c '$'    # 9
# 默认情况下, 是使用换行符(\n)来分隔匹配项.

# 注意  -z 选项是 GNU "grep" 特定的选项.


# 感谢, S.C.</programlisting>
            </para>

	    <para>当有多个文件参数的时候, 
	      <command>grep</command>将会指出哪个文件中包含具体的匹配. 
	      </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>grep Linux osinfo.txt misc.txt</userinput>
<computeroutput>osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.
 misc.txt:The Linux operating system is steadily gaining in popularity.</computeroutput>
	      </screen>
	    </para>


	    <tip>
			<para>如果在<command>grep</command>命令只搜索一个文件的时候, 
				那么可以简单的把<filename>/dev/null</filename>作为第二个文件参数传递给<command>grep</command>. </para>
	    <para>
	      <screen><prompt>bash$ </prompt><userinput>grep Linux osinfo.txt /dev/null</userinput>
<computeroutput>osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.</computeroutput>
	      </screen>
	    </para>
	    </tip>


		<para>如果存在一个成功的匹配, 
			那么<command>grep</command>命令将会返回0作为<link linkend="exitstatusref">退出状态码</link>, 
			这样就可以将<command>grep</command>命令的结果放在脚本的条件测试中来使用, 
			尤其和<option>-q</option>(禁止输出)选项组合时特别有用. 
	        <programlisting>SUCCESS=0                      # 如果grep匹配成功
word=Linux
filename=data.file

grep -q "$word" "$filename"    # "-q"选项将使得什么都不输出到stdout上.

if [ $? -eq $SUCCESS ]
# if grep -q "$word" "$filename"   这句话可以代替行 5 - 7.
then
  echo "$word found in $filename"
else
  echo "$word not found in $filename"
fi</programlisting>
            </para>


	    <para><xref linkend="online">展示了如何使用<command>grep</command>命令在一个系统logfile中进行一个单词的模式匹配. 
	      </para>


	    <example id="grp">
	      <title>在脚本中模拟<quote>grep</quote>的行为</title>
	      <programlisting>&grp;</programlisting>
	    </example>	    	   

		<para>如何使用<command>grep</command>命令来搜索两个(或两个以上)独立的模式? 
			如果你想在一个或多个文件中显示既匹配<quote>pattern1</quote><emphasis>又匹配</emphasis><quote>pattern2</quote>的所有匹配的话, 那又该如何做呢? (译者: 这是取交集的情况, 如果取并集该怎么办呢?) </para>

	    <para>一个方法是通过<link
	      linkend="piperef">管道</link>来将<command>grep
	      pattern1</command>的结果传递到<command>grep pattern2</command>中. </para>

            <para>比如, 给定如下文件: </para>

            <para>
	    <programlisting># 文件名: tstfile

This is a sample file.
This is an ordinary text file.
This file does not contain any unusual text.
This file is not unusual.
Here is some text.</programlisting>
            </para>

            <para>现在, 让我们在这个文件中搜索<emphasis>既</emphasis>包含
				<quote>file</quote><emphasis>又</emphasis>包含<quote>text</quote>的所有行. </para>

	      <screen><prompt>bash$ </prompt><userinput>grep file tstfile</userinput>
<computeroutput># 文件名: tstfile
 This is a sample file.
 This is an ordinary text file.
 This file does not contain any unusual text.
 This file is not unusual.</computeroutput>

<prompt>bash$ </prompt><userinput>grep file tstfile | grep text</userinput>
<computeroutput>This is an ordinary text file.
 This file does not contain any unusual text.</computeroutput></screen>

            <para>--</para>

	    <para><anchor id="egrepref"><command>egrep</command>
				- <emphasis>扩展的grep</emphasis> - 这个命令与<command>grep -E</command>等价. 
				这个命令用起来有些不同, 
				由于使用<link linkend="regexref">正则表达式</link>的扩展集合, 
				将会使得搜索更具灵活性.
	      它也允许逻辑|(<firstterm>或</firstterm>)操作. 
	      <screen><prompt>bash $ </prompt><userinput>egrep 'matches|Matches' file.txt</userinput>
<computeroutput>Line 1 matches.
 Line 3 Matches.
 Line 4 contains matches, but also Matches</computeroutput>
              </screen>
	      </para>

	    <para><command>fgrep</command> - <emphasis>快速的grep</emphasis>
			- 这个命令与<command>grep -F</command>等价. 
			这是一种按照字符串字面意思进行的搜索(即不允许使用正则表达式), 
			这样有时候会使搜索变得容易一些. 
	      </para>

		  <note><para>在某些Linux发行版中, 
				  <command>egrep</command>和<command>fgrep</command>都是<command>grep</command>命令的符号链接或者别名, 
				  只不过在调用的时候分别使用了<option>-E</option>和<option>-F</option>选项罢了. </para></note>

	    <example id="dictlookup">
	      <title>在<citetitle
	      pubwork="book">1913年的韦氏词典</citetitle>中查找定义</title>
	      <programlisting>&dictlookup;</programlisting>
	    </example>	    

		<para><command>agrep</command> (<emphasis>近似grep</emphasis>)扩展了<command>grep</command>近似匹配的能力. 
			搜索的字符串可能会与最终匹配结果所找到字符串有些不同. 
			这个工具并不是核心Linux发行版的一部分. 
	      </para>


		  <tip> <para>为了搜索压缩文件, 
				  应使用<command>zgrep</command>, 
				  <command>zegrep</command>, 
				  或<command>zfgrep</command>. 
				  这些命令也可以对未压缩的文件进行搜索, 
				  只不过会比一般的<command>grep</command>, 
				  <command>egrep</command>, 
				  和<command>fgrep</command>慢上一些. 
	      当然, 在你要搜索的文件中如果混合了压缩和未压缩的文件的话, 
	      那么使用这些命令是非常方便的. </para>
	    <para>如果要搜索<link linkend="bzipref">bzipped</link>类型的文件, 
	      使用<command>bzgrep</command>. </para> </tip>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>look</command></term>
	  <indexterm>
	    <primary>look</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>look</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>look</command>命令与<command>grep</command>命令很相似, 
			  但是这个命令只能做<quote>字典查询</quote>, 
			  也就是它所搜索的文件必须是已经排过序的单词列表. 
			  默认情况下, 如果没有指定搜索哪个文件, 
			  <command>look</command>命令就默认搜索<filename>/usr/dict/words</filename>(译者: 
			  感觉好像应该是<filename>/usr/share/dict/words</filename>), 
			  当然也可以指定其他目录下的文件进行搜索. </para>

	    <example id="lookup">
	      <title>检查列表中单词的正确性</title>
	      <programlisting>&lookup;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>sed</command></term>
	  <term><command>awk</command></term>
	  <indexterm>
	    <primary>sed</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sed</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个两个命令都是独立的脚本语言, 
			  尤其适合分析文本文件和命令输出. 
			  既可以单独使用, 也可以结合管道和在shell脚本中使用. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command><link linkend="sedref">sed</link></command></term>
	  <listitem>
		  <para>非交互式的<quote>流编辑器</quote>, 
			  在批处理模式下, 允许使用多个<command>ex</command>命令. 
	      你会发现它在shell脚本中非常有用. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command><link linkend="awkref">awk</link></command></term>
	  <listitem>
		  <para>可编程的文件提取器和文件格式化工具, 
			  在结构化的文本文件中, 
			  处理或提取特定域(特定列)具有非常好的表现. 
			  它的语法与C语言很类似. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>wc</command></term>
	  <indexterm>
	    <primary>wc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wc</secondary>
	  </indexterm>
	  <listitem>
	    <para><emphasis>wc</emphasis>可以统计文件或I/O流中的<quote>单词数量</quote>: 
	      <screen><prompt>bash $ </prompt><userinput>wc /usr/share/doc/sed-4.1.2/README</userinput>
<computeroutput>13  70  447 README</computeroutput>
[13 lines  70 words  447 characters]</screen></para>

	    <para><userinput>wc -w</userinput> 统计单词数量. </para>
	    <para><userinput>wc -l</userinput> 统计行数量. </para>
	    <para><userinput>wc -c</userinput> 统计字节数量. </para>
	    <para><userinput>wc -m</userinput> 统计字符数量. </para>
	    <para><userinput>wc -L</userinput> 给出文件中最长行的长度. </para>

            <para>使用<command>wc</command>命令来统计当前工作目录下有多少个<emphasis>.txt</emphasis>文件: 
	      <programlisting>$ ls *.txt | wc -l
# 因为列出的文件名都是以换行符区分的, 所以使用-l来统计.


# 另一种方法:
#      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
#      (shopt -s nullglob; set -- *.txt; echo $#)

# 感谢, S.C.</programlisting>
	    </para>

	    <para><command>wc</command>命令来统计所有以 d - h 开头的文件的大小. 
	      <screen><prompt>bash$ </prompt><userinput>wc [d-h]* | grep total | awk '{print $3}'</userinput>
<computeroutput>71832</computeroutput>
	      </screen>
	    </para>

	    <para>使用<command>wc</command>命令来查看指定文件中包含<quote>Linux</quote>的行一共有多少. 
	      <screen><prompt>bash$ </prompt><userinput>grep Linux abs-book.sgml | wc -l</userinput>
<computeroutput>50</computeroutput>
	      </screen>
	    </para>

	    <para>请参考<xref linkend="ex52">和<xref
	    linkend="redir4">. </para>

	    <para>某些命令的某些选项其实已经包含了<command>wc</command>命令的部分功能.
	      
	    <programlisting>... | grep foo | wc -l
# 这个命令使用的非常频繁, 但事实上它有更简便的写法.

... | grep -c foo
# 只要使用grep命令的"-c"(或"--count")选项就能达到同样的目的.

# 感谢, S.C.</programlisting></para>

	  </listitem>
	</varlistentry>

	
	<varlistentry>
	  <term><anchor id="trref"><command>tr</command></term>
	  <indexterm>
	    <primary>tr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tr</secondary>
	  </indexterm>
	  <listitem>
	    <para>字符转换过滤器. </para>
	    
		<caution><para><link linkend="ucref">必须使用引用或中括号</link>, 
				这样做才是合理的. 
				引用可以阻止shell重新解释出现在<command>tr</command>命令序列中的特殊字符. 
	      中括号应该被引用起来防止被shell扩展. </para></caution>

  <para>无论<userinput>tr "A-Z" "*" &lt;filename</userinput>还是<userinput>tr A-Z \* 
		  &lt;filename</userinput>都可以将<filename>filename</filename>中的大写字符修改为星号(写到<filename>stdout</filename>). 
	      但是在某些系统上可能就不能正常工作了, 而<userinput>tr A-Z
	      '[**]'</userinput>在任何系统上都可以正常工作. </para>

	    <para><option>-d</option>选项删除指定范围的字符. 
	    <programlisting>echo "abcdef"                 # abcdef
echo "abcdef" | tr -d b-d     # aef


tr -d 0-9 &lt;filename
# 删除"filename"中所有的数字. </programlisting></para>

			<para><option>--squeeze-repeats</option> 
			(或<option>-s</option>)选项用来在重复字符序列中除去除第一个字符以外的所有字符. 
				这个选项在删除多余<link
              linkend="whitespaceref">空白</link>的时候非常有用. 



	      <screen><prompt>bash$ </prompt><userinput>echo "XXXXX" | tr --squeeze-repeats 'X'</userinput>
<computeroutput>X</computeroutput></screen></para>

		<para><option>-c</option><quote>complement</quote>选项将会<emphasis>反转</emphasis>匹配的字符集. 
			通过这个选项, 
			<command>tr</command>将只会对那些<emphasis>不</emphasis>匹配的字符起作用. </para>

            <para>
	      <screen><prompt>bash$ </prompt><userinput>echo "acfdeb123" | tr -c b-d +</userinput>
<computeroutput>+c+d+b++++</computeroutput></screen>
            </para>



            <para>注意<command>tr</command>命令支持<link
	      linkend="posixref">POSIX字符类</link>.
	  <footnote><para>对于GNU版本的<command>tr</command>命令来说, 
			  这是唯一一处比那些商业UNIX系统上的一般版本更好的地方. </para></footnote>
	      </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo "abcd2ef1" | tr '[:alpha:]' -</userinput>
<computeroutput>----2--1</computeroutput>
	      </screen>
	    </para>

	    <example id="ex49">
	      <title><command>转换大写</command>: 把一个文件的内容全部转换为大写. </title>
	      <programlisting>&ex49;</programlisting>
	    </example>	    


	    <example id="lowercase">
	      <title><command>转换小写</command>: 将当前目录下的所有文全部转换为小写. </title>
	      <programlisting>&lowercase;</programlisting>
	    </example>	    

	    <example id="du">
	      <title><command>Du</command>: DOS到UNIX文本文件的转换. </title>
	      <programlisting>&du;</programlisting>
	    </example>	    

	    <example id="rot13">
	      <title><command>rot13</command>: rot13, 弱智加密. </title>
	      <programlisting>&rot13;</programlisting>
	    </example>	    

	    <example id="cryptoquote">
	      <title>产生<quote>Crypto-Quote</quote>游戏(译者: 一种文字游戏)</title>
	      <programlisting>&cryptoquote;</programlisting>
	    </example>


	    <sidebar><title><command>tr</command>的不同版本</title>
	    <para>
			<command>tr</command>工具在历史上有2个重要版本. 
			BSD版本不需要使用中括号(<userinput>tr a-z A-Z</userinput>), 
			但是SysV版本则需要中括号(<userinput>tr '[a-z]' '[A-Z]'</userinput>). 
			GNU版本的<command>tr</command>命令与BSD版本比较象, 
			所以最好使用中括号来引用字符范围. 
	    </para>
	    </sidebar>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="foldref"><command>fold</command></term>
	  <indexterm>
	    <primary>fold</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fold</secondary>
	  </indexterm>
	  <listitem>
		  <para>将输入按照指定宽度进行折行. 
			  这里有一个非常有用的选项<option>-s</option>, 
			  这个选项可以使用空格进行断行(译者: 
			  事实上只有外文才需要使用空格断行, 
			  中文是不需要的)(请参考<xref
	      linkend="ex50">和<xref linkend="mailformat">). </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fmt</command></term>
	  <indexterm>
	    <primary>fmt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fmt</secondary>
	  </indexterm>
	  <listitem>
		  <para>一个简单的文件格式器, 通常用在管道中, 
			  将一个比较长的文本行输出进行<quote>折行</quote>. 
	      </para>

	    <example id="ex50">
	      <title>格式化文件列表.</title>
	      <programlisting>&ex50;</programlisting>
	    </example>	    

		<para>请参考<xref linkend="ex41">. </para>

			<tip><para>如果想找到一个更强力的<command>fmt</command>工具可以选择Kamil 
			Toman的工具<command>par</command>, 
	      这个工具可以从后边的这个网址取得<ulink
	      url="http://www.cs.berkeley.edu/~amc/Par/">http://www.cs.berkeley.edu/~amc/Par/</ulink>.
	      </para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>col</command></term>
	  <indexterm>
	    <primary>col</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>reverse line feed</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个命令用来滤除标准输入的反向换行符号. 
			  这个工具还可以将空白用等价的tab来替换. 
	      <command>col</command>工具最主要的应用还是从特定的文本处理工具中过滤输出, 
		  比如<command>groff</command>和<command>tbl</command>. 
		  (译者: 主要用来将man页转化为文本.) </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>column</command></term>
	  <indexterm>
	    <primary>column</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>column</secondary>
	  </indexterm>
	  <listitem>
		  <para>列格式化工具. 
			  通过在合适的位置插入tab, 
			  这个过滤工具会将列类型的文本转化为<quote>易于打印</quote>的表格式进行输出. </para>

	    <example id="col">
	      <title>使用<command>column</command>来格式化目录列表</title>
	      <programlisting>&colm;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>colrm</command></term>
	  <indexterm>
	    <primary>colrm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>colrm</secondary>
	  </indexterm>
	  <listitem>
		  <para>列删除过滤器. 
			  这个工具将会从文件中删除指定的列(列中的字符串)并且写到文件中, 
			  如果指定的列不存在, 
			  那么就回到<filename>stdout</filename>. 
	      <userinput>colrm 2 4 &lt;filename</userinput>将会删除<filename>filename</filename>文件中每行的第2到第4列之间的所有字符. 
	      </para>
		  <caution><para>如果这个文件包含tab和不可打印字符, 
				  那将会引起不可预期的行为. 在这种情况下, 
				  应该通过管道的手段使用<link linkend="expandref">expand</link>和<command>unexpand</command>来预处理<command>colrm</command>. </para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>nl</command></term>
	  <indexterm>
	    <primary>nl</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fmt</secondary>
	  </indexterm>
	  <listitem>
		  <para>计算行号过滤器. 
			  <userinput>nl filename</userinput>将会把<filename>filename</filename>文件的所有内容都输出到<filename>stdout</filename>上, 
			  但是会在每个非空行的前面加上连续的行号. 
			  如果没有<filename>filename</filename>参数, 
			  那么就操作<filename>stdin. </filename></para>

		  <para><command>nl</command>命令的输出与<userinput>cat -n</userinput>非常相似, 
			  然而, 默认情况下<command>nl</command>不会列出空行. </para>

	    <example id="lnum">
	      <title><command>nl</command>: 一个自己计算行号的脚本. </title>
	      <programlisting>&lnum;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>pr</command></term>
	  <indexterm>
	    <primary>pr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pr</secondary>
	  </indexterm>
	  <listitem>
		  <para>格式化打印过滤器. 
			  这个命令会将文件(或<filename>stdout</filename>)分页, 
			  将它们分成合适的小块以便于硬拷贝打印或者在屏幕上浏览. 
			  使用这个命令的不同的参数可以完成好多任务, 
			  比如对行和列的操作, 加入行, 设置页边, 计算行号, 
			  添加页眉, 合并文件等等. 
	      <command>pr</command>命令集合了许多命令的功能, 
	      比如<command>nl</command>, <command>paste</command>,
		  <command>fold</command>, <command>column</command>, 
		  和<command>expand</command>. </para>

	   <para><userinput>pr -o 5 --width=65 fileZZZ | more</userinput>
		   这个命令对<filename>fileZZZ</filename>进行了比较好的分页, 
		   并且打印到屏幕上. 文件的缩进被设置为5, 
		   总宽度设置为65. </para>

	    <para>一个非常有用的选项<option>-d</option>, 
	      强制隔行打印(与<command>sed -G</command>效果相同). </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="gettextref"><command>gettext</command></term>
	  <indexterm>
	    <primary>gettext</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>localization</secondary>
	  </indexterm>
	  <listitem>

	    <para>GNU <command>gettext</command>包是专门用来将程序的输出翻译或者<link linkend="localization">本地化</link>为不同国家语言的工具集. 
			在最开始的时候仅仅支持C语言, 
			现在已经支持了相当数量的其它程序语言和脚本语言. 
	      </para>

		  <para>想要查看<command>gettext</command><emphasis>程序</emphasis>如何在shell脚本中使用. 
			  请参考<replaceable>info页</replaceable>. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="msgfmtref"><command>msgfmt</command></term>
	  <indexterm>
	    <primary>msgfmt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>localization</secondary>
	  </indexterm>
	  <listitem>
		  <para>一个产生二进制消息目录的程序. 
			  这个命令主要用来<link
	      linkend="localization">本地化</link>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>iconv</command></term>
	  <indexterm>
	    <primary>iconv</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>encoding</secondary>
	  </indexterm>
	  <listitem>

		  <para>一个可以将文件转化为不同编码格式(字符集)的工具. 
			  这个命令主要用来<link
	      linkend="localization">本地化</link>. </para>

	    <para>
	    <programlisting># 将字符符串由UTF-8格式转换为UTF-16并且打印到BookList中
function write_utf8_string {
    STRING=$1
    BOOKLIST=$2
    echo -n "$STRING" | iconv -f UTF8 -t UTF16 | cut -b 3- | tr -d \\n >> "$BOOKLIST"
}

#  来自于Peter Knowles的"booklistgen.sh"脚本
#+ 目的是把文件转换为Sony Librie格式.
#  (http://booklistgensh.peterknowles.com)</programlisting>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>recode</command></term>
	  <indexterm>
	    <primary>recode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>encoding</secondary>
	  </indexterm>
	  <listitem>
		  <para>可以认为这个命令是上边<command>iconv</command>命令的专业版本. 
		这个非常灵活的并可以把整个文件都转换为不同编码格式的工具并不是Linux标准安装的一部分. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>TeX</command></term>
	  <term><command>gs</command></term>
	  <indexterm>
	    <primary>TeX</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>TeX</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>gs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>Postscript</secondary>
	  </indexterm>
	  <listitem>

		  <para><command>TeX</command>和<command>Postscript</command>都是文本标记语言, 
			 用来对打印和格式化的视频显示进行预拷贝. </para>
		
	      <para><command>TeX</command>是Donald Knuth精心制作的排版系统. 
			  通常情况下, 
			  通过编写脚本的手段来把所有的选项和参数封装起来一起传到标记语言中是一件很方便的事情. 
		</para>

	      <para><emphasis>Ghostscript</emphasis>
		(<command>gs</command>) 是一个 遵循GPL的Postscript解释器. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>enscript</command></term>
	  <indexterm>
	    <primary>enscript</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>PostScript</secondary>
	  </indexterm>
	  <listitem>
	    <para>将纯文本文件转换为PostScript的工具</para>
	    <para>比如, <command>enscript filename.txt -p filename.ps</command>
	      产生一个 PostScript 输出文件<filename>filename.ps</filename>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="groffref"><command>groff</command></term>
	  <term><command>tbl</command></term>
	  <term><command>eqn</command></term>
	  <indexterm>
	    <primary>groff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>groff</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tbl</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>table</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>eqn</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>equation</secondary>
	  </indexterm>
	  <listitem>

		  <para>另一种文本标记和显示格式化语言是<command>groff</command>. 
			  这是一个对传统UNIX <command>roff/troff</command>显示和排版包的GNU增强版本. 
			  <emphasis>Man页</emphasis>使用的就是<command>groff</command>.</para>

		  <para><command>tbl</command>表处理工具可以认为是<command>groff</command>的一部分, 
			  它的功能就是将表标记转化到<command>groff</command>命令中. </para>

		  <para><command>eqn</command>等式处理工具也是<command>groff</command>的一部分, 
			  它的功能是将等式标记转化到<command>groff</command>命令中. </para>

    <example id="manview">
      <title><command>manview</command>: 查看格式化的man页</title>
      <programlisting>&manview;</programlisting>
    </example>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>lex</command></term>
	  <term><command>yacc</command></term>
	  <indexterm>
	    <primary>lex</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>flex</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>yacc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bison</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>lex</command>是用于模式匹配的词汇分析产生程序. 
			  在Linux系统上这个命令已经被<command>flex</command>取代了. </para>
		  <para><command>yacc</command>工具基于一系列的语法规范, 产生一个语法分析器. 
			  在Linux系统上这个命令已经被<command>bison</command>取代了. </para>
	  </listitem>
	</varlistentry>

       </variablelist>

        </sect1> <!-- End Text Processing Commands -->


      <sect1 id="filearchiv">
        <title>文件与归档命令</title>

       <variablelist id="faarchiving">
         <title><anchor id="faarchiving1">归档命令</title>

	<varlistentry>
	  <term><anchor id="tarref"><command>tar</command></term>
	  <indexterm>
	    <primary>tar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tar</secondary>
	  </indexterm>
	  <listitem>

	    <para>标准的UNIX归档工具.
	        <footnote><para>在这里所讨论的<firstterm>归档文件</firstterm>, 
	        只不过是存储在一个单一位置上的一些相关文件的集合. 
	        </para></footnote>
			起初这只是一个<wordasword>磁带归档</wordasword>程序, 
			而现在这个工具已经被开发为通用打包程序, 
			它能够处理所有设备的所有类型的归档文件, 
			包括磁带设备, 正常文件, 甚至是<filename>stdout</filename>(请参考<xref linkend="ex58">). 
				GNU的tar工具现在可以接受不同种类的压缩过滤器, 
				比如<command>tar czvf archive_name.tar.gz *</command>, 
				并且可以递归的处理归档文件, 
				还可以用<link linkend="gzipref">gzips</link>压缩目录下的所有文件, 
				除了当前目录下(<command>$PWD</command>)的<link linkend="dotfilesref">点文件</link>. 

		<footnote>
		  <para>
		    <command>tar czvf archive_name.tar.gz *</command><emphasis>可以</emphasis>包含当前目录<emphasis>下</emphasis>的点文件. 
		    这是一个未文档化的GNU<command>tar</command>的<quote>特性</quote>. 
		  </para>
		</footnote>
            </para>		
		

	    <para>一些有用的<command>tar</command>命令选项:   
	      <orderedlist>

		<listitem><para><option>-c</option> 创建(一个新的归档文件)</para></listitem>

		<listitem><para><option>-x</option> 解压文件(从存在的归档文件中)</para></listitem>

		<listitem>
		<para><option>--delete</option> 删除文件(从存在的归档文件中)</para>
		<caution><para>这个选项不能用于磁带类型设备. </para></caution>  
		  </listitem>

		<listitem><para><option>-r</option> 将文件添加到现存的归档文件的尾部</para></listitem>

		<listitem><para><option>-A</option> 将<emphasis>tar</emphasis>文件添加到现存的归档文件的尾部</para></listitem>

		<listitem><para><option>-t</option> 列出现存的归档文件中包含的内容</para></listitem>

	        <listitem><para><option>-u</option> 更新归档文件</para></listitem>

			<listitem><para><option>-d</option> 使用指定的文件系统, 
					比较归档文件</para></listitem>

		<listitem>
		<para><option>-z</option> 用<link
		  linkend="gzipref">gzip</link>压缩归档文件</para>
  <para>(压缩还是解压, 
	  依赖于是否组合了<option>-c</option>或<option>-x</option>)选项</para>
		</listitem>

		<listitem><para><option>-j</option>
		  用<link linkend="bzipref">bzip2</link>压缩归档文件</para></listitem>

	      </orderedlist>
	      </para>

		  <caution><para>如果想从损坏的用<emphasis>gzipped</emphasis>压缩过的tar文件中取得数据, 
				  那将是非常困难的. 所以当我们归档重要的文件的时候, 
				  一定要保留多个备份.
	      </para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>shar</command></term>
	  <indexterm>
	    <primary>shar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>archive</secondary>
	  </indexterm>
	  <listitem>

		  <para>Shell归档工具. 
			  存在于shell归档文件中的所有文件都是未经压缩的, 
			  并且本质上是一个shell脚本, 
			  以<token>#!/bin/sh</token>开头, 并且包含所有必要的解档命令. 
	      <firstterm>Shar 归档文件</firstterm>至今还在Internet新闻组中使用, 
		  否则的话, <command>shar</command>早就被<command>tar</command>/<command>gzip</command>所取代了. 
	      <command>unshar</command>命令用来解档<firstterm>shar</firstterm>归档文件. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ar</command></term>
	  <indexterm>
	    <primary>ar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>archive</secondary>
	  </indexterm>
	  <listitem>
		  <para>创建和操作归档文件的工具, 
			  主要在对二进制目标文件打包成库时才会用到. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="rpmref"><command>rpm</command></term>
	  <indexterm>
	    <primary>rpm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>package manager</secondary>
	  </indexterm>
	  <listitem>

		  <para><emphasis>Red Hat包管理器</emphasis>, 
			  或者说<command>rpm</command>工具提供了一种对源文件或二进制文件进行打包的方法. 
			  除此之外, 它还包括安装命令, 并且还检查包的完整性. 
	      </para>

		  <para>一个简单的<command>rpm -i package_name.rpm</command>命令对于安装一个包来说就足够了, 
			  虽然这个命令还有好多其它的选项. 
	      </para>


	    <tip>
	    <para><userinput>rpm -qf</userinput> 列出一个文件属于那个包. 
	      </para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>rpm -qf /bin/ls</userinput>
<computeroutput>coreutils-5.2.1-31</computeroutput>
	      </screen>
	    </para>
	    </tip>

	    <tip>
	    <para><userinput>rpm -qa</userinput>将会列出给定系统上所有安装了的
	      <emphasis>rpm</emphasis>包. 
	      <userinput>rpm -qa package_name</userinput>命令将会列出与给定名字<filename>package_name</filename>相匹配的包. 
	      </para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>rpm -qa</userinput>
<computeroutput>redhat-logos-1.1.3-1
 glibc-2.2.4-13
 cracklib-2.7-12
 dosfstools-2.7-1
 gdbm-1.8.0-10
 ksymoops-2.4.1-1
 mktemp-1.5-11
 perl-5.6.0-17
 reiserfs-utils-3.x.0j-2
 ...</computeroutput>


<prompt>bash$ </prompt><userinput>rpm -qa docbook-utils</userinput>
<computeroutput>docbook-utils-0.6.9-2</computeroutput>


<prompt>bash$ </prompt><userinput>rpm -qa docbook | grep docbook</userinput>
<computeroutput>docbook-dtd31-sgml-1.0-10
 docbook-style-dsssl-1.64-3
 docbook-dtd30-sgml-1.0-10
 docbook-dtd40-sgml-1.0-11
 docbook-utils-pdf-0.6.9-2
 docbook-dtd41-sgml-1.0-10
 docbook-utils-0.6.9-2</computeroutput>
	      </screen>
	    </para>
	    </tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cpio</command></term>
	  <indexterm>
	    <primary>cpio</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cpio</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个特殊的归档拷贝命令(拷贝输入和输出, 
			  <command>c</command>o<command>p</command>y
			  <command>i</command>nput and <command>o</command>utput)现在已经很少能见到了, 
			  因为它已经被<command>tar</command>/<command>gzip</command>所替代了. 
			  现在这个命令只在一些比较特殊的地方还在使用, 
			  比如拷贝一个目录树. 如果指定一个合适尺寸的块(用于拷贝), 
			  那么这个命令会比<command>tar</command>命令快一些. </para>

	    <example id="ex48">
	      <title>使用<command>cpio</command>来拷贝一个目录树</title>
	      <programlisting>&ex48;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rpm2cpio</command></term>
	  <indexterm>
	    <primary>rpm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cpio</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个命令可以从<link
	      linkend="rpmref">rpm</link>归档文件中解出一个<command>cpio</command>归档文件. </para>

	    <example id="derpm">
	      <title>解包一个<emphasis>rpm</emphasis>归档文件</title>
	      <programlisting>&derpm;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="facompression">
        <title><anchor id="facompression1">压缩命令</title>

	<varlistentry>
	  <term><anchor id="gzipref"><command>gzip</command></term>
	  <indexterm>
	    <primary>gzip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>gzip</secondary>
	  </indexterm>
	  <listitem>

		  <para>标准的GNU/UNIX压缩工具, 
			  取代了比较差的<command>compress</command>命令. 
			  相应的解压命令是<command>gunzip</command>, 
			  与<command>gzip -d</command>是等价的. </para>

		  <note><para><option>-c</option>选项将会把<command>gzip</command>的输出打印到<filename>stdout</filename>上. 
		当你想通过<link linkend="piperef">管道</link>传递到其他命令的时候, 
		这就非常有用了. </para></note>

<para><command>zcat</command>过滤器可以将一个<emphasis>gzip</emphasis>文件解压到<filename>stdout</filename>, 
	所以尽可能的使用管道和重定向. 
	这个命令事实上就是一个可以工作于压缩文件(包括一些的使用老的<command>compress</command>工具压缩的文件)的<command>cat</command>命令. 
	      <command>zcat</command>命令等价于<command>gzip -dc</command>. </para>


	  <caution><para>在某些商业的UNIX系统上, 
			  <command>zcat</command>与<command>uncompress -c</command>等价, 
	      并且不能工作于<emphasis>gzip</emphasis>文件. 
	      </para></caution>

	      <para>请参考<xref linkend="ex14">. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="bzipref"><command>bzip2</command></term>
	  <indexterm>
	    <primary>bzip2</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bzip2</secondary>
	  </indexterm>
	  <listitem>

		  <para>用来压缩的一个可选的工具, 
			  通常比<command>gzip</command>命令压缩率更高(所以更慢), 
			  适用于比较大的文件. 相应的解压命令是<command>bunzip2</command>. </para>

	    <note><para>新版本的<link
	      linkend="tarref">tar</link>命令已经直接支持<command>bzip2</command>了. </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>compress</command></term>
	  <term><command>uncompress</command></term>
	  <indexterm>
	    <primary>compress</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>compress</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>uncompress</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uncompress</secondary>
	  </indexterm>
	  <listitem>
		  <para>这是一个老的, 私有的压缩工具, 
			  一般的商业UNIX发行版都会有这个工具. 
			  更有效率的<command>gzip</command>工具早就把这个工具替换掉了. 
	      Linux发行版一般也会包含一个兼容的<command>compress</command>命令, 
	      虽然<command>gunzip</command>也可以解压用<command>compress</command>工具压缩的文件. </para>

	    <tip><para><command>znew</command>命令可以将<emphasis>compress</emphasis>压缩的文件转换为<emphasis>gzip</emphasis>压缩的文件. </para></tip>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sq</command></term>
	  <indexterm>
	    <primary>sq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sq</secondary>
	  </indexterm>
	  <listitem>

		  <para>另一种压缩工具, 一个只能工作于排过序的ASCII单词列表的过滤器. 
			  这个命令使用过滤器标准的调用语法, 
	      <command>sq < input-file >
			  output-file</command>. 速度很快, 
		  但是效率远不及<link linkend="gzipref">gzip</link>. 
		  相应的解压命令为<command>unsq</command>, 
		  调用方法与<command>sq</command>相同. </para>

	  <tip><para><command>sq</command>的输出可以通过管道传递给<command>gzip</command>, 
			 以便于进一步的压缩. </para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>zip</command></term>
	  <term><command>unzip</command></term>
	  <indexterm>
	    <primary>zip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pkzip.exe</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unzip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unzip</secondary>
	  </indexterm>
	  <listitem>
		  <para>跨平台的文件归档和压缩工具, 
			  与DOS下的<emphasis>pkzip.exe</emphasis>兼容. 
	      <quote>Zip</quote>归档文件看起来在互联网上比<quote>tar包</quote>更流行. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>unarc</command></term>
	  <term><command>unarj</command></term>
	  <term><command>unrar</command></term>
	  <indexterm>
	    <primary>unarc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>arc.exe</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unarj</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>arj.exe</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unrar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rar.exe</secondary>
	  </indexterm>
	  <listitem>
	    <para>这些Linux工具可以用来解档那些用DOS下的<emphasis>arc.exe</emphasis>, 
			<emphasis>arj.exe</emphasis>, 
			和<emphasis>rar.exe</emphasis> 程序进行归档的文件. </para>

	  </listitem>
	</varlistentry>



      </variablelist>


      <variablelist id="fainformation">
        <title><anchor id="fainformation1">文件信息</title>

	<varlistentry>
	  <term><anchor id="fileref"><command>file</command></term>
	  <indexterm>
	    <primary>file</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file</secondary>
	  </indexterm>
	  <listitem>

		  <para>确定文件类型的工具. 
			  命令<userinput>file file-name</userinput>将会用<computeroutput>ascii文本</computeroutput>或<computeroutput>数据</computeroutput>的形式返回<filename>file-name</filename>文件的详细描述. 
	      这个命令会使用<filename>/usr/share/magic</filename>, 
	      <filename>/etc/magic</filename>, 
		  或<filename>/usr/lib/magic</filename>中定义的<link linkend="magnumref">魔法数字</link>来标识包含某种魔法数字的文件, 
		  上边所举出的这3个文件需要依赖于具体的 Linux/UNIX 发行版. 
	      </para>

		  <para><option>-f</option>选项将会让<command>file</command>命令运行于批处理模式, 
			  也就是说它会分析<option>-f</option>后边所指定的文件, 
			  从中读取需要处理的文件列表, 
			  然后依次执行<command>file</command>命令. 
			  <option>-z</option>选项, 
			  当对压缩过的目标文件使用时, 
			  将会强制分析压缩的文件类型. 
	      </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>file test.tar.gz</userinput>
<computeroutput>test.tar.gz: gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix</computeroutput>

<prompt>bash </prompt><userinput>file -z test.tar.gz</userinput>
<computeroutput>test.tar.gz: GNU tar archive (gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix)</computeroutput>
	      </screen>
	    </para>

	    <para>
	      <programlisting># 在给定的目录中找出sh和Bash脚本文件:

DIRECTORY=/usr/local/bin
KEYWORD=Bourne
# Bourne和Bourne-Again shell脚本

file $DIRECTORY/* | fgrep $KEYWORD

# 输出:

# /usr/local/bin/burn-cd:          Bourne-Again shell script text executable
# /usr/local/bin/burnit:           Bourne-Again shell script text executable
# /usr/local/bin/cassette.sh:      Bourne shell script text executable
# /usr/local/bin/copy-cd:          Bourne-Again shell script text executable
# . . .</programlisting>
	    </para>

	    <example id="stripc">
	      <title>从C文件中去掉注释</title>
	      <programlisting>&stripc;</programlisting>
	    </example>	    	   

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="whichref"><command>which</command></term>
	  <indexterm>
	    <primary>which</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>which</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>which command-xxx</command>将会给出<quote>command-xxx</quote>的完整路径. 
			  当你想在系统中准确定位一个特定的命令或工具的时候, 
			  这个命令就非常有用了. 
	      </para>
	    <para><userinput>$bash which rm</userinput>
<screen><computeroutput>/usr/bin/rm</computeroutput></screen>
	  </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>whereis</command></term>
	  <indexterm>
	    <primary>whereis</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>whereis</secondary>
	  </indexterm>
	  <listitem>
	    <para>与上边的<command>which</command>很相似, 
			<command>whereis command-xxx</command>不只会给出<quote>command-xxx</quote>的完整路径, 
			而且还会给出这个命令的<emphasis>man页</emphasis>的完整路径. </para>
	    <para><userinput>$bash whereis rm</userinput>
<screen><computeroutput>rm: /bin/rm /usr/share/man/man1/rm.1.bz2</computeroutput></screen>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="whatisref"><command>whatis</command></term>
	  <indexterm>
	    <primary>whatis</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>whatis</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>whatis filexxx</command>将会在<replaceable>whatis</replaceable>数据库中查询<quote>filexxx</quote>. 
			当你想确认系统命令和重要的配置文件的时候, 
			这个命令就非常重要了. 
			可以把这个命令认为是一个简单的<command>man</command>命令. 
	      </para>
	    <para><userinput>$bash whatis whatis</userinput>
<screen><computeroutput>whatis               (1)  - search the whatis database for complete words</computeroutput></screen>
	  </para>
	  
      <example id="what">
	<title><command>浏览<filename
	class="directory">/usr/X11R6/bin</filename></command></title>
	<programlisting>&what;</programlisting>
      </example>

            <para>请参考<xref linkend="fileinfo">. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>vdir</command></term>
	  <indexterm>
	    <primary>vdir</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ls</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示详细的目录列表. 
	      与<link linkend="lsref">ls -l</link>的效果相似. </para>
	    <para>这是一个GNU <emphasis>fileutils</emphasis>.</para>  
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>vdir</userinput>
<computeroutput>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</computeroutput>

<prompt>bash </prompt><userinput>ls -l</userinput>
<computeroutput>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>locate</command></term>
	  <term><command>slocate</command></term>
	  <indexterm>
	    <primary>locate</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>locate</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>slocate</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>slocate</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>locate</command>命令将会在预先建立好的档案数据库中查询文件. 
	      <command>slocate</command>命令是<command>locate</command>的安全版本(<command>locate</command>命令很有可能已经被关联到<command>slocate</command>命令上了). </para>
	    <para><userinput>$bash locate hickson</userinput>
<screen><computeroutput>/usr/lib/xephem/catalogs/hickson.edb</computeroutput></screen></para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>readlink</command></term>
	  <indexterm>
	    <primary>readlink</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>link</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示符号链接所指向的文件. </para>
	    <para>
	      <screen><prompt>bash$ </prompt><userinput>readlink /usr/bin/awk</userinput>
<computeroutput>../../bin/gawk</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>strings</command></term>
	  <indexterm>
	    <primary>strings</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>strings</secondary>
	  </indexterm>
	  <listitem>
		  <para>使用<command>strings</command>命令在二进制或数据文件中找出可打印字符. 
			  它将在目标文件中列出所有找到的可打印字符的序列. 
			  这个命令对于想进行快速查找n个字符的打印检查来说是很方便的, 
			  也可以用来检查一个未知格式的图片文件(<userinput>strings image-file | 
				  more</userinput>可能会搜索出像<computeroutput>JFIF</computeroutput>这样的字符串, 
			  那么这就意味着这个文件是一个<emphasis>jpeg</emphasis>格式的图片文件). 
			  在脚本中, 你可能会使用<link linkend="grepref">grep</link>或者<link
	      linkend="sedref">sed</link>命令来分析<command>strings</command>命令的输出. 
	      请参考<xref linkend="bingrep">和<xref linkend="findstring">. </para>

	    <example id="wstrings">
	      <title>一个<quote>改进过</quote>的<emphasis>strings</emphasis>命令</title>
	      <programlisting>&wstrings;</programlisting>
	    </example>
	  </listitem>

	</varlistentry>

      </variablelist>

      <variablelist id="comparisonn">
        <title><anchor id="comparisonn1">Comparison</title>

	<varlistentry>
	  <term><anchor id="diffref"><command>diff</command></term>
	  <term><command>patch</command></term>
	  <indexterm>
	    <primary>diff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>diff</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>patch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>patch</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>diff</command>: 一个非常灵活的文件比较工具. 
			  这个工具将会以一行接一行的形式来比较目标文件. 
			  在某些应用中, 比如说比较单词词典, 
			  在通过管道将结果传递给<command>diff</command>命令之前, 
	      使用诸如<link linkend="sortref">sort</link>和<command>uniq</command>命令来对文件进行过滤将是非常有用的. 
		  <userinput>diff file-1 file-2</userinput> 
		  将会输出两个文件中不同的行, 并会通过符号标识出每个不同行所属的文件. 
	      </para>

		  <para><command>diff</command>命令的<option>--side-by-side</option>选项将会按照左右分隔的形式, 
			  把两个比较中的文件全部输出, 并且会把不同的行标记出来. 
	    <option>-c</option>和<option>-u</option>选项也会使得<command>diff</command>命令的输出变得容易解释一些. 
	    </para>

		<para>还有一些<command>diff</command>命令的变种, 
			比如<command>sdiff</command>,
			<command>wdiff</command>, <command>xdiff</command>, 
			和<command>mgdiff</command>. </para>

		<tip><para>如果比较的两个文件是完全一样的话, 
				那么<command>diff</command>命令会返回0作为退出状态码, 
				如果不同的话就返回1作为退出码. 
	    这样<command>diff</command>命令就可以用在shell脚本的测试结构中了. (见下边). </para></tip>


<para><command>diff</command>命令的一个重要用法就是产生区别文件, 
	这个文件将用作<command>patch</command>命令的<option>-e</option>选项的参数, 
	      <option>-e</option>选项接受<command>ed</command>或<command>ex</command>脚本. 
	      </para>


		  <para><command>patch</command>: 灵活的版本工具. 
			  给出一个用<command>diff</command>命令产生的区别文件, 
			  <command>patch</command>命令可以将一个老版本的包更新为一个新版本的包. 
			  因为你发布一个小的<quote>区别</quote>文件远比重新发布一个大的软件包来的容易得多. 
	      对于频繁更新的Linux内核来说, 使用内核<quote>补丁包</quote>的形式来发布是一种非常好的办法. 
	      </para>

	    <para><programlisting>patch -p1 &lt;patch-file
# 在'patch-file'中取得所有的修改列表, 
# 然后把它们更新到相应的文件中. 
# 那么这个包就被更新为新版本了. </programlisting></para>

	    <para>更新内核: </para>
            <para><programlisting>cd /usr/src
gzip -cd patchXX.gz | patch -p0
# 使用'patch'来更新内核源文件.
# 来自于linux内核文档"README",
# 这份文档由匿名作者(Alan Cox?)所编写. </programlisting></para>

            <note>
	    <para><command>diff</command>也可以递归的比较目录下的所有文件(包含子目录). </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>diff -r ~/notes1 ~/notes2</userinput>
<computeroutput>Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</computeroutput>
	      </screen>
	    </para>
            </note>

	    <tip><para>使用<command>zdiff</command>来比较<emphasis>gzip</emphasis>文件. </para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>diff3</command></term>
	  <indexterm>
	    <primary>diff3</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>diff3</secondary>
	  </indexterm>
	  <listitem>
	    <para>这是<command>diff</command>命令的扩展版本, 
			可以同时比较三个文件. 
			如果成功执行那么这个命令就返回0, 
			但不幸的是这个命令不给出比较结果的信息. 
	      </para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>diff3 file-1 file-2 file-3</userinput>
<computeroutput>====
 1:1c
   This is line 1 of "file-1".
 2:1c
   This is line 1 of "file-2".
 3:1c
   This is line 1 of "file-3"</computeroutput>
	      </screen>
	      </para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sdiff</command></term>
	  <indexterm>
	    <primary>sdiff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sdiff</secondary>
	  </indexterm>
	  <listitem>
		  <para>比较和(或)编辑两个文件, 
			  将它们合并到一个输出文件中. 
			  由于这个命令的交互特性, 
			  所以在脚本中很少使用这个命令.
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cmp</command></term>
	  <indexterm>
	    <primary>cmp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cmp</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>cmp</command>命令是上边<command>diff</command>命令的一个简单版本. 
			  <command>diff</command>命令会报告两个文件的不同之处, 
			  而<command>cmp</command>命令仅仅指出哪些位置有所不同, 
	      不会显示不同之处的具体细节. </para>

	  <note><para>就像<command>diff</command>命令那样, 
			  如果两个文件相同的话, 
			  <command>cmp</command>将返回0作为退出状态码, 
			  如果不同就返回1. 这样能用在shell脚本的测试结构中了. </para></note>

	    <example id="filecomp">
	      <title>在一个脚本中使用<command>cmp</command>命令来比较两个文件. </title>
	      <programlisting>&filecomp;</programlisting>
	    </example>	    	   

	    <tip><para>使用<command>zcmp</command>处理<emphasis>gzip</emphasis>文件. </para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>comm</command></term>
	  <indexterm>
	    <primary>comm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>comm</secondary>
	  </indexterm>
	  <listitem>
	    <para>多功能的文件比较工具. 使用这个命令之前必须先排序. 
	      </para>

	    <para><command>comm
		<replaceable>-options</replaceable>
		<replaceable>first-file</replaceable>
		<replaceable>second-file</replaceable></command></para>

	    <para><userinput>comm file-1 file-2</userinput> 将会输出3列: 
	      <itemizedlist>
		<listitem><para>第1列 = 只在<filename>file-1</filename>中存在的行</para>
		</listitem>
		
		<listitem><para>第2列 = 只在<filename>file-2</filename>中存在的行</para>
		</listitem>
		
		<listitem><para>第3列 = 两边相同的行. </para>
		</listitem>
	      </itemizedlist></para>
	      
	    <para>下列选项可以禁止一列或多列的输出.
	      <itemizedlist>
		<listitem><para><option>-1</option> 禁止显示第<literal>1</literal>列 (译者: 在File1中的行)</para>
		</listitem>
		<listitem><para><option>-2</option> 禁止显示第<literal>2</literal>列 (译者: 在File2中的行)</para>
		</listitem>
		<listitem><para><option>-3</option> 禁止显示第<literal>3</literal>列 (译者: 在File3中的行)</para>
		</listitem>
		<listitem><para><option>-12</option> 禁止第<literal>1</literal>列和第<literal>2</literal>列, 等等. (译者: 就是说选项可以组合)</para>
		</listitem>
		</itemizedlist>
	    </para>
	      
	  </listitem>
	</varlistentry>


      </variablelist>

      <variablelist id="fautils">
        <title><anchor id="fautils1">Utilities</title>

	<varlistentry>
	  <term><command>basename</command></term>
	  <indexterm>
	    <primary>basename</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>basename</secondary>
	  </indexterm>
	  <listitem><para>从文件名中去掉路径信息, 只打印出文件名. 
			  结构<userinput>basename
		$0</userinput>可以让脚本获得它自己的名字, 也就是, 它被调用的名字. 
	可以用来显示<quote>用法</quote>信息, 
	      比如如果你调用脚本的时候缺少参数, 可以使用如下语句: 
              <programlisting>echo "Usage: `basename $0` arg1 arg2 ... argn"</programlisting>
	    </para>

	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>dirname</command></term>
	  <indexterm>
	    <primary>dirname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirname</secondary>
	  </indexterm>
	  <listitem><para>从带路径的文件名字符串中去掉文件名(<command>basename</command>), 只打印出路径信息. </para>
	    <note>
			<para><command>basename</command>和<command>dirname</command>可以操作任意字符串. 
				它们的参数不一定是一个真正存在的文件, 甚至可以不是一个文件名. 
		(请参考<xref linkend="daysbetween">). </para>
	    </note>
	    
	    <example id="ex35">
	      <title><command>basename</command>和<command>dirname</command></title>
	      <programlisting>&ex35;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>split</command></term>
	  <term><command>csplit</command></term>
	  <indexterm>
	    <primary>split</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>split</secondary>
	  </indexterm>
	  <indexterm>
	  <primary>csplit</primary>
	  </indexterm>
	  <indexterm>
	  <primary>command</primary>
	  <secondary>csplit</secondary>
	  </indexterm>

	  <listitem>
		  <para>将一个文件分割为几个小段的工具. 
			  这些命令通常会将大的文件分割, 然后备份到软盘上, 
			  或者是为了将大文件切成合适的尺寸, 然后用email上传. 
	      </para>

		  <para><command>csplit</command>命令会根据<emphasis>上下文</emphasis>来切割文件, 
			  切割的位置将会发生在模式匹配的地方. 
	      </para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sum</command></term>
	  <term><command>cksum</command></term>
	  <term><anchor id="md5sumref"><command>md5sum</command></term>
	  <term><command>sha1sum</command></term>
	  <indexterm>
	    <primary>sum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cksum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cksum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>md5sum</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>md5sum</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sha1sum</secondary>
	  </indexterm>
	  <listitem>
	    <para>这些都是用来产生checksum的工具. 
			<emphasis>checksum</emphasis>是对文件的内容进行数学计算而得到的, 
			它的目的是用来检验文件的完整性, 
			出于安全目的一个脚本可能会有一个checksum列表, 
			这样可以确保关键系统文件的内容不会被修改或损坏. 
			对于需要安全性的应用来说, 应该使用<command>md5sum</command> (<command>m</command>essage
	      <command>d</command>igest <command>5</command>
		  check<command>sum</command>)命令, 
		  或者使用更好更新的<command>sha1sum</command>命令(安全Hash算法). 
	  </para>


	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>cksum /boot/vmlinuz</userinput>
<computeroutput>1670054224 804083 /boot/vmlinuz</computeroutput>

<prompt>bash$ </prompt><userinput>echo -n "Top Secret" | cksum</userinput>
<computeroutput>3391003827 10</computeroutput>



<prompt>bash$ </prompt><userinput>md5sum /boot/vmlinuz</userinput>
<computeroutput>0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</computeroutput>

<prompt>bash$ </prompt><userinput>echo -n "Top Secret" | md5sum</userinput>
<computeroutput>8babc97a6f62a4649716f4df8d61728f  -</computeroutput>
	      </screen>
	  </para>


	  <note>
	  <para><command>cksum</command>将会显示目标尺寸(以字节为单位), 
	    目标可以是<filename>stdout</filename>, 也可以是文件. </para>
	  <para><command>md5sum</command>和<command>sha1sum</command>命令在它们收到来自于<filename>stdout</filename>的输入的时候, 
	    显示一个<link linkend="dashref2">dash</link>. 
	    </para>
	    </note>

	    <example id="fileintegrity">
	      <title>检查文件完整性</title>
	      <programlisting>&fileintegrity;</programlisting>
	    </example>

	  <para>请参考<xref linkend="directoryinfo">和<xref
			linkend="horserace">, 
			这两个例子展示了<command>md5sum</command>命令的用法. </para> 

          <note>

	  <para>
	    到目前为止, 已经有128-bit的<command>md5sum</command>被破解的报告了, 
		所以现在更安全的160-bit的<command>sha1sum</command>非常受欢迎, 
		这个命令已经被加入到checksum工具包中了.
          </para>

		  <para>一些安全顾问认为即使是<command>sha1sum</command>也是一种折衷的做法. 
			  所以, 下一个工具是什么呢?
	      -- 512-bit的checksum工具? </para>

	      <screen><prompt>bash$ </prompt><userinput>md5sum testfile</userinput>
<computeroutput>e181e2c8720c60522c4c4c981108e367  testfile</computeroutput>


<prompt>bash$ </prompt><userinput>sha1sum testfile</userinput>
<computeroutput>5d7425a9c08a66c3177f1e31286fa40986ffc996  testfile</computeroutput>
	      </screen></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="shredref"><command>shred</command></term>
	  <indexterm>
	    <primary>shred</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>secure delete</secondary>
	  </indexterm>
	  <listitem>

		  <para>用随机字符填充文件, 使得文件无法恢复, 
			  这样就可以保证文件安全的被删除. 
			  这个命令的效果与<xref linkend="blotout">一样, 
			但是使用这个命令是一种更优雅更彻底的方法. </para>

	    <para>这是GNU的<emphasis>文件工具</emphasis>之一. </para>  

		<caution><para>即使使用了<command>shred</command>命令, 
				高级的辨别技术也还是能够恢复文件的内容. </para></caution>
	    
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="faencencr">
        <title><anchor id="faencencr1">编码和解码</title>

	<varlistentry>
	  <term><command>uuencode</command></term>
	  <indexterm>
	    <primary>uuencode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uuencode</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个工具用来把二进制文件编码成ASCII字符串, 
			  这个工具适用于编码e-mail消息体, 或者新闻组消息. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uudecode</command></term>
	  <indexterm>
	    <primary>uudecode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uudecode</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个工具用来把uuencode后的ASCII字符串恢复为二进制文件. 
	      </para>

	    <example id="ex52">
	      <title>Uudecode编码后的文件</title>
	      <programlisting>&ex52;</programlisting>
	    </example>	    	   

	  <tip><para><link linkend="foldref">fold -s</link>命令在处理从Usenet新闻组下载下来的长的uudecode文本消息的时候可能会有用(可能在管道中).
	    </para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mimencode</command></term>
	  <term><command>mmencode</command></term>
	  <indexterm>
	    <primary>mimencode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mime</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>mmencode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>encode</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>mimencode</command>和<command>mmencode</command>命令用来处理多媒体编码的email附件. 
			虽然<emphasis>mail用户代理</emphasis>(比如<command>pine</command>或<command>kmail</command>)通常情况下都会自动处理, 
			但是这些特定的工具允许从命令行或shell脚本中来手动操作这些附件. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>crypt</command></term>
	  <indexterm>
	    <primary>crypt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>crypt</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个工具曾经是标准的UNIX文件加密工具.

			<footnote><para>这是一个对称的块密码, 
					过去曾在单系统或本地网络中用来加密文件, 
					用来对抗<quote>public key</quote>密码类, 
		<command>pgp</command>就是一个众所周知的例子. 
		</para></footnote>

		政府由于政策上的动机规定禁止加密软件的输出, 
		这样导致了<command>crypt</command>命令从UNIX世界消失, 
		并且在大多数的Linux发行版中也没有这个命令. 
		幸运的是, 程序员们想出了一些替代它的方法, 
		在这些方法中有作者自己的<ulink
	      url="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz">cruft</ulink>
	      (请参考<xref linkend="encryptedpw">). </para>

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="famisc">
        <title><anchor id="famisc1">Miscellaneous</title>

	<varlistentry>
	  <term><anchor id="mktempref"><command>mktemp</command></term>
	  <indexterm>
	    <primary>temporary</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>filename</secondary>
	  </indexterm>
	  <listitem>
	    <para>使用一个<quote>唯一</quote>的文件名来创建一个<firstterm>临时文件</firstterm>. 

	       <footnote><para>使用<option>-d</option>选项可以创建一个临时的<emphasis>目录</emphasis>. </para></footnote>

		   如果不带参数的在命令行下调用这个命令时, 
		   将会在<filename
	      class="directory">/tmp</filename>目录下产生一个零长度的文件. </para>


	  <para>
	      <screen><prompt>bash$ </prompt><userinput>mktemp</userinput>
<computeroutput>/tmp/tmp.zzsvql3154</computeroutput>
	      </screen>
	    </para>

	    <para><programlisting>PREFIX=filename
tempfile=`mktemp $PREFIX.XXXXXX`
#                        ^^^^^^ 在这个临时的文件名中
#+                              至少需要6个占位符. 
#   如果没有指定临时文件的文件名, 
#+  那么默认就是"tmp.XXXXXXXXXX". 

echo "tempfile name = $tempfile"
# tempfile name = filename.QA2ZpY
#                 或者一些其他的相似的名字...

#  使用600为文件权限
#+ 来在当前工作目录下创建一个这样的文件.
#  这样就不需要"umask 177"了.
#  但不管怎么说, 这也是一个好的编程风格. </programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>make</command></term>
	  <indexterm>
	    <primary>make</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>Makefile</secondary>
	  </indexterm>
	  <listitem>
	    <para>build(建立)和compile(编译)二进制包的工具.  
			当源文件被增加或修改时就会触发一些操作, 
			这个工具用来控制这些操作. </para>
	    <para><anchor id="makefileref"></para>
	    <para><command>make</command>命令会检查<filename>Makefile</filename>, makefile是文件的依赖和操作列表. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>install</command></term>
	  <indexterm>
	    <primary>install</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>install</secondary>
	  </indexterm>
	  <listitem>
		  <para>特殊目的的文件拷贝命令, 
			  与<command>cp</command>命令相似, 
			  但是具有设置拷贝文件的权限和属性的能力. 
			  这个命令看起来是为了安装软件包所定制的, 
			  而且就其本身而言, 这个命令经常出现在<filename>Makefiles</filename>中(在<replaceable>make install :</replaceable> 区域中). 
			  在安装脚本中也会看到这个命令的使用. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>dos2unix</command></term>
	  <indexterm>
	    <primary>dos2unix</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file converter</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个工具是由Benjamin Lin及其同事共同编写的, 
	      目的是将DOS格式的文本文件(以CR-LF为行结束符)转换为UNIX格式(以LF为行结束符), 
	      反过来也一样. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ptx</command></term>
	  <indexterm>
	    <primary>ptx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>index</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>ptx [targetfile]</command>命令将输出目标文件的序列改变索引(交叉引用列表). 
	      如果必要的话, 这个命令可以在管道中进行更深层次的过滤和格式化. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>more</command></term>
	  <term><command>less</command></term>
	  <indexterm>
	    <primary>more</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>more</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>less</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>less</secondary>
	  </indexterm>
	  <listitem>

		  <para>分页显示文本文件或<filename>stdout</filename>, 
			  一次一屏. 可以用来过滤<filename>stdout</filename>的输出 . . . 或过滤一个脚本的输出. </para>

            <para>
				<command>more</command>命令的一个有趣的应用就是测试一个命令序列的执行, 
				这样做的目的是避免可能发生的糟糕的结果.
                 <programlisting>ls /home/bozo | awk '{print "rm -rf " $1}' | more
#                                            ^^^^
		 
# 检查下边(灾难性的)命令行的效果: 
#      ls /home/bozo | awk '{print "rm -rf " $1}' | sh
#      推入shell中执行 . . .       ^^</programlisting>
            </para>

	  </listitem>
	</varlistentry>
       
       </variablelist>	

	</sect1> <!-- End File and Archiving Commands -->



      <sect1 id="communications">
        <title>通讯命令</title>

	<para>下边命令中的某几个命令你会在<link
			linkend="cspammers">追踪垃圾邮件</link>练习中找到其用法, 
		用来进行网络数据的转换和分析. </para>

       <variablelist id="communinfo">
         <title><anchor id="communinfo1">信息与统计</title>

	<varlistentry>
	  <term><command>host</command></term>
	  <indexterm>
	    <primary>host</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>host</secondary>
	  </indexterm>
	  <listitem>
		  <para>通过名字或IP地址来搜索一个互联网主机的信息, 
			  使用DNS. </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>host surfacemail.com</userinput>
<computeroutput>surfacemail.com. has address 202.92.42.236</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ipcalc</command></term>
	  <indexterm>
	    <primary>ipcalc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ipcalc</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示一个主机IP信息. 
			  使用<option>-h</option>选项, 
			  <command>ipcalc</command>将会做一个DNS的反向查询, 
			  通过IP地址找到主机(服务器)名. </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>ipcalc -h 202.92.42.236</userinput>
<computeroutput>HOSTNAME=surfacemail.com</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>nslookup</command></term>
	  <indexterm>
	    <primary>nslookup</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>name server lookup</secondary>
	  </indexterm>
	  <listitem>

	    <para>通过IP地址在一个主机上做一个互联网的<quote>名字服务查询</quote>. 
			事实上, 这与<command>ipcalc -h</command>或<command>dig 
				-x</command>等价. 这个命令既可以交互运行也可以非交互运行, 
		   	换句话说, 就是在脚本中运行.
	      </para>

	    <para><command>nslookup</command>命令据说已经被慢慢的<quote>忽视</quote>了, 但事实上它是有一定的作用. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>nslookup -sil 66.97.104.180</userinput>
<computeroutput>nslookup kuhleersparnis.ch
 Server:         135.116.137.2
 Address:        135.116.137.2#53

 Non-authoritative answer:
 Name:   kuhleersparnis.ch</computeroutput>
	      </screen>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>dig</command></term>
	  <indexterm>
	    <primary>dig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>domain information groper</secondary>
	  </indexterm>
	  <listitem>

	    <para><command>D</command>omain <command>I</command>nformation
			<command>G</command>roper(域信息查询). 
			与<command>nslookup</command>很相似, 
			<command>dig</command>也可以在一个主机上做互联网的<quote>名字服务查询</quote>. 
			这个命令既可以交互运行也可以非交互运行, 
			换句话说, 就是在脚本中运行.
	      </para>

            <para>下面是一些<command>dig</command>命令有趣的选项, 
				<option>+time=N</option>选项用来设置查询超时为<emphasis>N</emphasis>秒, 
				<option>+nofail</option>选项用来持续查询服务器直到收到一个响应, 
	      <option>-x</option>会做反向地址查询. </para>

	  <para>比较下边这3个命令的输出, 
		  <command>dig -x</command>, 
	      <command>ipcalc -h</command>和
	      <command>nslookup</command>. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>dig -x 81.9.6.2</userinput>
<computeroutput>;; Got answer:
 ;; ->>HEADER<<- opcode: QUERY, status: NXDOMAIN, id: 11649
 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0

 ;; QUESTION SECTION:
 ;2.6.9.81.in-addr.arpa.         IN      PTR

 ;; AUTHORITY SECTION:
 6.9.81.in-addr.arpa.    3600    IN      SOA     ns.eltel.net. noc.eltel.net.
 2002031705 900 600 86400 3600

 ;; Query time: 537 msec
 ;; SERVER: 135.116.137.2#53(135.116.137.2)
 ;; WHEN: Wed Jun 26 08:35:24 2002
 ;; MSG SIZE  rcvd: 91</computeroutput>
	      </screen>
	  </para>

	    <example id="spamlookup">
	      <title>查找滥用的链接来报告垃圾邮件发送者</title>
	      <programlisting>&spamlookup;</programlisting>
	    </example>

	    <example id="isspammer">
	      <title>分析一个垃圾邮件域</title>
	      <programlisting>&isspammer;</programlisting>
	    </example>

	  <para>想获得比上边这个脚本更详细的版本, 请参考<xref linkend="isspammer2">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>traceroute</command></term>
	  <indexterm>
	    <primary>traceroute</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>traceroute</secondary>
	  </indexterm>
	  <listitem>

		  <para>跟踪包发送到远端主机过程中的路由信息. 
			  这个命令在LAN, WAN, 或者在Internet上都可以正常工作. 
			  远端主机可以通过IP地址来指定. 
			  这个命令的输出也可以通过管道中的<link linkend="grepref">grep</link>或<link
	      linkend="sedref">sed</link>命令来过滤. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>traceroute 81.9.6.2</userinput>
<computeroutput>traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets
 1  tc43.xjbnnbrb.com (136.30.178.8)  191.303 ms  179.400 ms  179.767 ms
 2  or0.xjbnnbrb.com (136.30.178.1)  179.536 ms  179.534 ms  169.685 ms
 3  192.168.11.101 (192.168.11.101)  189.471 ms  189.556 ms *
 ...</computeroutput>
	      </screen>
	  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="pingref"><command>ping</command></term>
	  <indexterm>
	    <primary>ping</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ping</secondary>
	  </indexterm>
	  <listitem>

	    <para>广播一个<quote>ICMP ECHO_REQUEST</quote>包到其他主机上, 
			既可以是本地网络也可以是远端网络. 
			这是一个测试网络连接的诊断工具, 
			应该小心使用. 
	      </para>

	    <para>如果<command>ping</command>成功之行, 那么返回的<link
				linkend="exitstatusref">退出状态码</link>为<errorcode>0</errorcode>. 
			可以用在脚本的测试语句中. 
	      </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>ping localhost</userinput>
<computeroutput>PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec

 --- localhost.localdomain ping statistics ---
 2 packets transmitted, 2 packets received, 0% packet loss
 round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="whoisref"><command>whois</command></term>
	  <indexterm>
	    <primary>whois</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>domain name server</secondary>
	  </indexterm>
	  <listitem>
	    <para>执行DNS(域名系统)查询. 
			<option>-h</option>选项允许指定需要查询的特定<emphasis>whois</emphasis>服务器. 
			请参考<xref linkend="ex18">和<xref linkend="spamlookup">. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>finger</command></term>
	  <indexterm>
	    <primary>finger</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>finger</secondary>
	  </indexterm>
	  <listitem>

		  <para>取得网络上的用户信息. 
			  另外这个命令可以显示一个用户的<filename>~/.plan</filename>,
			  <filename>~/.project</filename>, 
			  和<filename>~/.forward</filename>文件, 当然, 前提是如果这些文件存在的话. </para>

	  <para>
	      <screen>
<prompt>bash$ </prompt><userinput>finger</userinput>
<computeroutput>Login  Name           Tty      Idle  Login Time   Office     Office Phone
 bozo   Bozo Bozeman   tty1        8  Jun 25 16:59
 bozo   Bozo Bozeman   ttyp0          Jun 25 16:59
 bozo   Bozo Bozeman   ttyp1          Jun 25 17:07</computeroutput>



<prompt>bash$ </prompt><userinput>finger bozo</userinput>
<computeroutput>Login: bozo                             Name: Bozo Bozeman
 Directory: /home/bozo                   Shell: /bin/bash
 Office: 2355 Clown St., 543-1234
 On since Fri Aug 31 20:13 (MST) on tty1    1 hour 38 minutes idle
 On since Fri Aug 31 20:13 (MST) on pts/0   12 seconds idle
 On since Fri Aug 31 20:13 (MST) on pts/1
 On since Fri Aug 31 20:31 (MST) on pts/2   1 hour 16 minutes idle
 No mail.
 No Plan.</computeroutput>
	      </screen>
	    </para>
	      
		<para>出于安全上的考虑, 
			许多网络都禁用了<command>finger</command>, 
		   以及和它相关的幽灵进程.
	          <footnote>
		  <para><anchor id="daemonref"></para>
		  <para>一个<emphasis>幽灵进程</emphasis>指的是并未附加在终端会话中的后台进程. 
			  幽灵进程在指定的时间执行指定的服务, 
			  或者由特定的事件触发来执行指定的服务. 
		    </para>
		  <para>希腊文中的<quote>daemon</quote>意思是幽灵, 
			  这个词充满了神秘感和神奇的力量, 
			  在UNIX中幽灵进程总是在后台默默地执行着分配给它们的任务. 
		    </para>
	          </footnote>
	      </para>
	  
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chfn</command></term>
	  <indexterm>
	    <primary>chfn</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>finger</secondary>
	  </indexterm>
	  <listitem>
	    <para>修改<command>finger</command>命令所显示出来的用户信息. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>vrfy</command></term>
	  <indexterm>
	    <primary>vrfy</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>vrfy</secondary>
	  </indexterm>
	  <listitem>
	    <para>验证一个互联网的e-mail地址. </para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="commremote">
        <title><anchor id="commremote1">远端主机接入</title>

	<varlistentry>
	  <term><command>sx</command></term>
	  <term><command>rx</command></term>
	  <indexterm>
	    <primary>sx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sx</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>rx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rx</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>sx</command>和<command>rx</command>命令使用<emphasis>xmodem</emphasis>协议, 
			  置服务来向远端主机传输文件和接收文件. 
			  这些都是通讯安装包的一般部分, 比如<command>minicom</command>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sz</command></term>
	  <term><command>rz</command></term>
	  <indexterm>
	    <primary>sz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sz</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>rz</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rz</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>sz</command>和<command>rz</command>命令使用<emphasis>zmodem</emphasis>协议, 
			设置服务来向远端主机传输文件和接收文件. 
			<emphasis>Zmodem</emphasis>协议在某些方面比<emphasis>xmodem</emphasis>协议强, 
			比如使用更快的传输波特率, 并且可以对中断的文件进行续传. 
			与<command>sx</command>和<command>rx</command>一样,
	      这些都是通讯安装包的一般部分. </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="ftpref"><command>ftp</command></term>
	  <indexterm>
	    <primary>ftp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file transfer</secondary>
	  </indexterm>
	  <listitem>
		  <para>向远端服务器上传或下载的工具, 也是一种协议. 
			  一个ftp会话可以写到脚本中自动运行. 
	      (请参考<xref linkend="ex72">, <xref
	      linkend="encryptedpw">, 和<xref linkend="ftpget">). </para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>uucp</command></term>
	  <term><command>uux</command></term>
	  <term><command>cu</command></term>
	  <indexterm>
	    <primary>uucp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uucp</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>uux</primary>
	    <secondary>unix to unix execute</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cu</primary>
	    <secondary>call up</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uucp</secondary>
	  </indexterm>
	  <listitem>

		  <para><command>uucp</command>: <emphasis>UNIX到UNIX拷贝</emphasis>. 
			  这是一个通讯安装包, 
			  目的是为了在UNIX服务器之间传输文件. 
			  使用shell脚本来处理<command>uucp</command>命令序列是一种有效的方法. </para>

	    <para>因为互联网和电子邮件的出现, 
			<command>uucp</command>现在看起来已经很落伍了, 
			但是这个命令在互联网连接不可用或者不适合使用的地方, 
			这个命令还是可以完美的运行. 
			<command>uucp</command>的优点就是它的容错性, 
			即使有一个服务将拷贝操作中断了, 
			那么当连接恢复的时候, 这个命令还是可以在中断的地方续传. 
	      </para>

            <para>---</para>

	    <para><command>uux</command>: <emphasis>UNIX到UNIX执行</emphasis>. 
              在远端系统上执行一个命令. 这个命令是<command>uucp</command>包的一部分. </para>

            <para>---</para>

	    <para><command>cu</command>: <emphasis>C</emphasis>all <emphasis>U</emphasis>p
			一个远端系统并且作为一个简单终端进行连接. 
			这是一个<link
				linkend="telnetref">telnet</link>的缩减版本. 
			这个命令是<command>uucp</command>包的一部分. </para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="telnetref"><command>telnet</command></term>
	  <indexterm>
	    <primary>telnet</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>telnet</secondary>
	  </indexterm>
	  <listitem>
	    <para>连接远端主机的工具和协议. </para>
		<caution><para>telnet协议本身包含安全漏洞, 
				因此我们应该适当的避免使用. </para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="wgetref"><command>wget</command></term>
	  <indexterm>
	    <primary>wget</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>download</secondary>
	  </indexterm>
	  <listitem>

	    <para><command>wget</command>工具使用<emphasis>非交互</emphasis>的形式从web或ftp站点上取得或下载文件. 在脚本中使用正好. 
	      </para>

	    <para><programlisting>wget -p http://www.xyz23.com/file01.html
#  -p或--page-requisite选项将会使得wget取得所有在显示指定页时
#+ 所需要的文件. (译者: 比如内嵌图片和样式表等.)

wget -r ftp://ftp.xyz24.net/~bozo/project_files/ -O $SAVEFILE
#  -r选项将会递归的从指定站点
#+ 上下载所有连接. </programlisting></para>

	    <example id="quotefetch">
	      <title>获得一份股票报价</title>
	      <programlisting>&quotefetch;</programlisting>
	    </example>


            <para>请参考<xref linkend="wgetter2">和<xref
	      linkend="bashpodder">. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="lynxref"><command>lynx</command></term>
	  <indexterm>
	    <primary>lynx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>browser</secondary>
	  </indexterm>
	  <listitem>

		  <para><command>lynx</command>是一个网页浏览器, 
			  也是一个文件浏览器. 它可以(通过使用<option>-dump</option>选项)在脚本中使用. 它的作用是可以非交互的从Web或ftp站点上获得文件. 
	        <programlisting>lynx -dump http://www.xyz23.com/file01.html &gt;$SAVEFILE</programlisting>
            </para>		

            <para>使用<option>-traversal</option>选项, 
				<command>lynx</command>将会从参数中指定的HTTP URL开始, 
				<quote>遍历</quote>指定服务器上的所有连接. 
	      如果与<option>-crawl</option>选项一起用的话, 将会把每个输出的页面文本都放到一个log文件中. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rlogin</command></term>
	  <indexterm>
	    <primary>rlogin</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote login</secondary>
	  </indexterm>
	  <listitem>
		  <para><replaceable>远端登陆</replaceable>, 
			  在远端的主机上开启一个会话. 
			  这个命令存在安全隐患, 
			  所以要使用<link linkend="sshref">ssh</link>来代替. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rsh</command></term>
	  <indexterm>
	    <primary>rsh</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote shell</secondary>
	  </indexterm>
	  <listitem>
		  <para><replaceable>远端shell</replaceable>, 
			  在远端的主机上执行命令. 
			  这个命令存在安全隐患, 
			  所以要使用<command>ssh</command>来代替. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rcp</command></term>
	  <indexterm>
	    <primary>rcp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote copy</secondary>
	  </indexterm>
	  <listitem>
		  <para><replaceable>远端拷贝</replaceable>, 
			  在网络上的不同主机间拷贝文件. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rsync</command></term>
	  <indexterm>
	    <primary>rsync</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>remote update</secondary>
	  </indexterm>
	  <listitem>

		  <para><replaceable>远端同步</replaceable>, 
			  在网络上的不同主机间(同步)更新文件. </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>rsync -a ~/sourcedir/*txt /node1/subdirectory/</userinput>
	      </screen>
	    </para>

	    <example id="fc4upd">
	      <title>更新FC4(Fedora 4)</title>
	      <programlisting>&fc4upd;</programlisting>
	    </example>
	      
	    <para>在使用<command>rcp</command>, <command>rsync</command>,
	      还有另外一些有安全问题的类似工具的时候, 一定要小心, 因为将这些工具用在shell脚本中是不明智的. 
	      你应该考虑使用<command>ssh</command>, <command>scp</command>,
	      或者<command>expect</command>脚本来代替这些不安全的工具. </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="sshref"><command>ssh</command></term>
	  <indexterm>
	    <primary>ssh</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>secure shell</secondary>
	  </indexterm>
	  <listitem>
		  <para><replaceable>安全shell</replaceable>, 
			  登陆远端主机并在其上运行命令. 
			  这个工具具有身份认证和加密的功能, 
			  可以安全的替换<command>telnet</command>,
			  <command>rlogin</command>, <command>rcp</command>, 
			  和<command>rsh</command>等工具. 
			  请参考这个工具的<emphasis>man页</emphasis>来获取详细信息. 
	      </para>

	    <example id="remote">
	      <title>使用ssh</title>
	      <programlisting>&remote;</programlisting>
	    </example>

	      <caution>
	      <para>在循环中, <command>ssh</command>可能会引起一些异常问题. 
		根据comp.unix上的shell文档<ulink
		url="http://groups-beta.google.com/group/comp.unix.shell/msg/dcb446b5fff7d230">
		Usenet post</ulink>所描述的内容, 
	<command>ssh</command>继承了循环的<filename>stdin</filename>. 
	为了解决这个问题, 
		请使用<command>ssh</command>的<option>-n</option>或者<option>-f</option>选项. </para>
		<para>感谢, Jason Bechtel, 为我们指出这个问题. </para>
	      </caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>scp</command></term>
	  <indexterm>
	    <primary>scp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>secure copy</secondary>
	  </indexterm>
	  <listitem>
		  <para><replaceable>安全拷贝</replaceable>, 
			  在功能上与<command>rcp</command>很相似, 
			  就是在两个不同的网络主机之间拷贝文件, 
	      但是要使用鉴权的方式, 并且要使用与<command>ssh</command>类似的安全层. </para>
	  </listitem>
	</varlistentry>
       
       </variablelist>	


      <variablelist id="commlocal">
        <title><anchor id="commlocal1">本地网络</title>

	<varlistentry>
	  <term><anchor id="writeref"><command>write</command></term>
	  <indexterm>
	    <primary>write</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>write</secondary>
	  </indexterm>
	  <listitem>
	    <para>这是一个端到端通讯的工具. 
	      这个工具可以从你的终端上(console或者<firstterm>xterm</firstterm>)发送整行数据到另一个用户的终端上. 
	      <link linkend="mesgref">mesg</link>命令当然也可以用来禁用对于一个终端的写权限. </para>

	  <para>因为<command>write</command>命令是需要交互的, 
		  所以这个命令在脚本中很少使用. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>netconfig</command></term>
	  <indexterm>
	    <primary>netconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>network</secondary>
	  </indexterm>
	  <listitem>
	    <para>用来配置网络适配器(使用DHCP)的命令行工具. 
	      这个命令对于红帽发行版来说是内置的. 
	      </para>
	  </listitem>
	</varlistentry>

       </variablelist>	


      <variablelist id="commmail">
        <title><anchor id="commmail1">Mail</title>

	<varlistentry>
	  <term><command>mail</command></term>
	  <indexterm>
	    <primary>mail</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mail</secondary>
	  </indexterm>
	  <listitem>

	    <para>发送或者读取e-mail消息. </para>

            <para>如果把这个命令行的mail客户端当成一个脚本中的命令来使用的话, 效果非常好. </para>

	    <example id="selfmailer">
	      <title>一个mail自身的脚本</title>
	      <programlisting>&selfmailer;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mailto</command></term>
	  <indexterm>
	    <primary>mailto</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>MIME mail</secondary>
	  </indexterm>
	  <listitem>
	    <para>与<command>mail</command>命令很相似, 
	      <command>mailto</command>可以使用命令行或在脚本中发送e-mail消息. 
	      而且<command>mailto</command>也可以发送MIME(多媒体)消息. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>vacation</command></term>
	  <indexterm>
	    <primary>vacation</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mail</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个工具可以自动回复e-mail给发送者, 
	      表示邮件的接受者正在度假暂时无法收到邮件. 
		  这个工具与<command>sendmail</command>一起运行于网络上, 
		  并且这个工具不支持拨号的POPmail帐号. </para>
	  </listitem>
	</varlistentry>


       </variablelist>	

	</sect1> <!-- End Communications Commands -->



      <sect1 id="terminalccmds">
        <title>终端控制命令</title>

       <variablelist id="termcommandlisting">	
         <title><anchor id="termcommandlisting1">影响控制台或终端的命令</title>


	<varlistentry>
	  <term><command>tput</command></term>
	  <indexterm>
	    <primary>tput</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>terminal</secondary>
	  </indexterm>
	  <listitem>

		  <para>初始化终端或者从<filename>terminfo</filename>数据中取得终端信息. 
			  这个命令有许多选项, 每个选项都允许特定操作. 
	      <command>tput clear</command>与后边所介绍的<command>clear</command>命令等价, 
		  <command>tput reset</command>与后边所介绍的<command>reset</command>命令等价, 
		  <command>tput sgr0</command>可以复位终端, 但是并不清除屏幕. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>tput longname</userinput>
<computeroutput>xterm terminal emulator (XFree86 4.0 Window System)</computeroutput>
	      </screen>
	    </para>

	    <para>使用<command>tput cup X Y</command>将会把光标移动到当前终端的(X,Y)坐标上, 
	      使用这个命令之前一般都要先用<command>clear</command>命令清屏. </para>

	    <para>注意: <link linkend="sttyref">stty</link>提供了一个更强大的命令专门用来设置如何控制终端. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>infocmp</command></term>
	  <indexterm>
	    <primary>infocmp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>terminal</secondary>
	  </indexterm>
	  <listitem>

		  <para>这个命令会打印出大量当前终端的信息. 
			  事实上它是引用了<emphasis>terminfo</emphasis>数据库的内容. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>infocmp</userinput>
<computeroutput>#       通过infocmp显示出来, 内容都来自于文件:
 /usr/share/terminfo/r/rxvt
 rxvt|rxvt terminal emulator (X Window System), 
         am, bce, eo, km, mir, msgr, xenl, xon, 
         colors#8, cols#80, it#8, lines#24, pairs#64, 
         acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, 
         bel=^G, blink=\E[5m, bold=\E[1m,
         civis=\E[?25l, 
         clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M, 
         ...</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>reset</command></term>
	  <indexterm>
	    <primary>reset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>reset</secondary>
	  </indexterm>
	  <listitem>
		  <para>复位终端参数并且清除屏幕. 与<command>clear</command>命令一样, 
			  光标和提示符将会重新出现在终端的左上角. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="clearref"><command>clear</command></term>
	  <indexterm>
	    <primary>clear</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>clear</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>clear</command>命令只不过是简单的清除控制台或者<firstterm>xterm</firstterm>的屏幕. 
			  光标和提示符将会重新出现在屏幕或者xterm window的左上角. 
			  这个命令既可以用在命令行中也可以用在脚本中. 
	      请参考<xref linkend="ex30">. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>script</command></term>
	  <indexterm>
	    <primary>script</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>script</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个工具将会记录(保存到一个文件中)所有的用户按键信息(在控制台下的或在xterm window下的按键信息).
	      这其实就是创建了一个会话记录. </para>
	  </listitem>
	</varlistentry>

       </variablelist>	

	</sect1> <!-- End Terminal Control Commands -->

	
      <sect1 id="mathc">
        <title>数学计算命令</title>

       <variablelist id="mathcommandlisting">	
         <title><anchor id="mathcommandlisting1"><quote>操作数字</quote></title>

      <varlistentry>
	<term><command>factor</command></term>
	  <indexterm>
	    <primary>factor</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>factor</secondary>
	  </indexterm>
	  <listitem><para>将一个正数分解为多个素数. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>factor 27417</userinput>
<computeroutput>27417: 3 13 19 37</computeroutput>
	      </screen>
	    </para>

	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><anchor id="bcref"><command>bc</command></term>
	  <indexterm>
	    <primary>bc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bc</secondary>
	  </indexterm>
	  <listitem>

		  <para>Bash不能处理浮点运算, 并且缺乏特定的一些操作, 
			  这些操作都是一些重要的计算功能. 幸运的是, 
	      <command>bc</command>可以解决这个问题. </para>

	    <para><command>bc</command>不仅仅是个多功能灵活的精确计算工具, 
	      且它还提供许多编程语言才具备的一些方便功能. </para>

	    <para><command>bc</command>比较类似于C语言的语法. </para>

	    <para>因为它是一个完整的UNIX工具, 所以它可以用在<link linkend="piperef">pipe</link>中, 
	       <command>bc</command>在脚本中也是很常用的. </para>

	    <para>这里有一个简单的使用<command>bc</command>命令的模版, 可以用来计算脚本中的变量. 
	      这个模版经常用于<link linkend="commandsubref">命令替换</link>中. </para>

	      <para>
              <screen>
	      <userinput>variable=$(echo "OPTIONS; OPERATIONS" | bc)</userinput>
	      </screen>
	      </para>

            <example id="monthlypmt">
              <title>按月偿还贷款</title>
              <programlisting>&monthlypmt;</programlisting>
            </example>

            <example id="base">
              <title>数制转换</title>
              <programlisting>&base;</programlisting>
            </example>

	      <para>调用<command>bc</command>的另一种方法就是<link linkend="heredocref">here
		document</link>, 并把它嵌入到<link
		linkend="commandsubref">命令替换</link>块中. 
	当一个脚本需要将一个选项列表和多个命令传递到<command>bc</command>中时, 
	这种方法就显得非常合适了. </para>

              <para>
	      <programlisting>variable=`bc << LIMIT_STRING
options
statements
operations
LIMIT_STRING
`

...or...


variable=$(bc << LIMIT_STRING
options
statements
operations
LIMIT_STRING
)</programlisting>
              </para>


            <example id="altbc">
              <title>使用<quote>here document</quote>来调用<command>bc</command></title>
              <programlisting>&altbc;</programlisting>
            </example>

            <example id="cannon">
              <title>计算圆周率</title>
              <programlisting>&cannon;</programlisting>
            </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="dcref"><command>dc</command></term>
	  <indexterm>
	    <primary>dc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dc</secondary>
	  </indexterm>
	  <listitem>

	    <para><command>dc</command>(桌面计算器<command>d</command>esk
			<command>c</command>alculator)工具是面向栈的, 
			并且使用RPN(逆波兰表达式<quote>Reverse Polish Notation</quote>又叫<quote>后缀表达式</quote>). 
			与<command>bc</command>命令很相似, 
			但是这个工具具备好多只有编程语言才具备的能力. </para>

		<programlisting>
(
译者注: 正常表达式      逆波兰表达式
        a+b             a,b,+
        a+(b-c)         a,b,c,-,+
        a+(b-c)*d       a,d,b,c,-,*,+
)
		</programlisting>

		<para>绝大多数人都避免使用这个工具, 
			因为它需要非直观的RPN输入, 
	        但是, 它却有特定的用途. </para>

            <example id="hexconvert">
              <title>将10进制数字转换为16进制数字</title>
              <programlisting>&hexconvert;</programlisting>
            </example>

			<para>通过仔细学习<command>dc</command>的<firstterm>info</firstterm>页, 
				可以更深入的理解这个复杂的命令. 
				但是, 有一些精通<emphasis>dc巫术</emphasis>小组经常会炫耀他们使用这个强大而又晦涩难懂的工具时的一些技巧,
				并以此为乐. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo "16i[q]sa[ln0=aln100%Pln100/snlbx]sbA0D68736142snlbxq" | dc"</userinput>
<computeroutput>Bash</computeroutput>
	      </screen>
	  </para>

            <example id="factr">
              <title>因子分解</title>
              <programlisting>&factr;</programlisting>
            </example>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="awkmath"><command>awk</command></term>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>math</secondary>
	  </indexterm>
	  <listitem>
		  <para>在脚本中使用浮点运算的另一种方法是使用<link linkend="awkref">awk</link>内建的数学运算函数, 
	      可以用在<link linkend="shwrapper">shell包装</link>中. </para>

            <example id="hypot">
              <title>计算直角三角形的斜边</title>
              <programlisting>&hypot;</programlisting>
            </example>

	  </listitem>
	</varlistentry>

       </variablelist>	

	</sect1> <!-- End Math Commands -->


      <sect1 id="extmisc">
        <title>混杂命令</title>

       <variablelist id="misccommandlisting">	
         <title><anchor id="misccommandlisting1">一些不好归类的命令</title>

	<varlistentry>
	  <term><command>jot</command></term>
	  <term><command>seq</command></term>
	  <indexterm>
	    <primary>jot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>jot</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>seq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>seq</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>arguments</secondary>
	  </indexterm>
	  <listitem>
	    <para>这些工具用来生成一系列整数, 用户可以指定生成范围. 
	      </para>

		  <para>每个产生出来的整数一般都占一行, 
			  但是可以使用<option>-s</option>选项来改变这种设置. 
	      </para>
	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>seq 5</userinput>
<computeroutput>1
 2
 3
 4
 5</computeroutput>



<prompt>bash$ </prompt><userinput>seq -s : 5</userinput>
<computeroutput>1:2:3:4:5</computeroutput>
	      </screen>
	    </para>
	      
	      
	    <para><command>jot</command>和<command>seq</command>命令经常用在<link linkend="forloopref1">for循环</link>中. </para>

	    <example id="ex53">
	      <title>使用<command>seq</command>命令来产生循环参数</title>
	      <programlisting>&ex53;</programlisting>
	    </example>	    	   

	    <para>一个简单一些的例子:
	      <programlisting>#  产生10个连续扩展名的文件, 
#+ 名字分别是 file.1, file.2 . . . file.10.
COUNT=10
PREFIX=file

for filename in `seq $COUNT`
do
  touch $PREFIX.$filename
  #  或者, 你可以做一些其他的操作, 
  #+ 比如rm, grep, 等等. 
done</programlisting></para>

	    <example id="lettercount">
	      <title>字母统计</title>
	      <programlisting>&lettercount;</programlisting>
	    </example>	    	   

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="getopty"><command>getopt</command></term>
	  <indexterm>
	    <primary>getopt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>option</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>getopt</command>命令将会分析以<link
				  linkend="dashref">破折号</link>开头的命令行选项. 
			  这个外部命令与Bash的内建命令<link linkend="getoptsx">getopts</link>作用相同. 
			  通过使用<option>-l</option>标志, 
			  <command>getopt</command>可以处理超长(多个字符的)选项, 
	      并且也允许参数重置. </para>

	    <example id="ex33a">
	      <title>使用<command>getopt</command>来分析命令行选项</title>
	      <programlisting>&ex33a;</programlisting>
	    </example>

		<para>请参考<xref linkend="getoptsimple">, 
				这是对<command>getopt</command>命令的一个简单模拟. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="runpartsref"><command>run-parts</command></term>
	  <indexterm>
	    <primary>run-parts</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>run-parts</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>run-parts</command>命令

		<footnote><para>这个工具事实上是从Debian Linux发行版中的一个脚本借鉴过来的. </para></footnote>
	      
	     将会执行目标目录中所有的脚本, 
	     这些脚本会以ASCII码的循序进行排列. 
	     当然, 这些脚本都需要具有可执行权限. </para>
	      
	    <para><link linkend="cronref">cron</link> <link
	      linkend="daemonref">幽灵进程</link>会调用<command>run-parts</command>来运行<filename class="directory">/etc/cron.*</filename>下的所有脚本. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>yes</command></term>
	  <indexterm>
	    <primary>yes</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>yes</secondary>
	  </indexterm>
	  <listitem>

	    <para><command>yes</command>命令的默认行为是向<filename>stdout</filename>连续不断的输出字符<computeroutput>y</computeroutput>, 
		每个<computeroutput>y</computeroutput>单独占一行. 
	      可以使用<keycombo><keycap>control</keycap><keycap>c</keycap></keycombo>来结束输出. 
		  如果想换一个输出字符的话, 
		  可以使用<userinput>yes different string</userinput>, 
		  这样就会连续不断的输出<computeroutput>different string</computeroutput>到<filename>stdout</filename>. 
		  那么这样的命令究竟能用来做什么呢? 
		  在命令行或者脚本中, 
	      <command>yes</command>的输出可以通过重定向或管道来传递给一些命令, 这些命令的特点是需要用户输入来进行交互. 
		  事实上, 这个命令可以说是<command>expect</command>命令(译者注: 
		  这个命令本书未介绍, 
		  一个自动实现交互的命令)的一个简化版本. </para>

	  <para><userinput>yes | fsck /dev/hda1</userinput>将会以非交互的形式运行<command>fsck</command>(译者注: 
		  因为需要用户输入的y全由yes命令搞定了)(小心使用!). </para>

	   <para><userinput>yes | rm -r dirname</userinput> 与
	     <userinput>rm -rf dirname</userinput> 效果相同(小心使用!). </para>

	   <warning><para>当用<command>yes</command>命令的管道形式来使用一些可能具有潜在危险的系统命令的时候一定要深思熟虑, 
	     比如<link linkend="fsckref">fsck</link>或<link
			 linkend="fdiskref">fdisk</link>. 
		 可能会产生一些令人意外的副作用. </para></warning>

           <note>
	     <para><command>yes</command>命令也可用来分析变量. 
	       比如: </para>
	        <para>
	        <screen><prompt>bash$ </prompt><userinput>yes $BASH_VERSION</userinput>
<computeroutput>3.00.16(1)-release
 3.00.16(1)-release
 3.00.16(1)-release
 3.00.16(1)-release
 3.00.16(1)-release
 . . .</computeroutput>
	      </screen>
	        </para>
	     <para>这个<quote>特性</quote>估计也不会特别有用. </para>
           </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>banner</command></term>
	  <indexterm>
	    <primary>banner</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>banner</secondary>
	  </indexterm>
	  <listitem>
		  <para>将会把传递进来的参数字符串用一个ASCII字符(默认是'#')给画出来(就是将多个'#'拼出一副字符的图形), 
			  然后输出到<filename>stdout</filename>. 
			  可以作为硬拷贝重定向到打印机上. 
		  (译者注: 可以使用-w 选项设置宽度.) </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>printenv</command></term>
	  <indexterm>
	    <primary>printenv</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>environment</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示某个特定用户所有的<link linkend="envref">环境变量</link>. </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>printenv | grep HOME</userinput>
<computeroutput>HOME=/home/bozo</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lp</command></term>
	  <indexterm>
	    <primary>lp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lpr</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>lp</command>和<command>lpr</command>命令将会把文件发送到打印队列中, 
			  并且作为硬拷贝来打印. 

	      <footnote><para><emphasis>打印队列</emphasis>就是<quote>在线等待</quote>打印的作业组. </para></footnote>

	      这些命令会记录它们名字的起点, 直到行打印机的另一个阶段.
	      </para>

	      <para><prompt>bash$ </prompt><userinput>lp file1.txt</userinput>
	        或者 <prompt>bash$ </prompt><userinput>lp
		&lt;file1.txt</userinput></para>

	      <para>通常情况下都是将<command>pr</command>的格式化输出传递到<command>lp</command>中. </para>

	      <para><prompt>bash$ </prompt><userinput>pr -options file1.txt | lp</userinput>
	        </para>

	      <para>格式化的包, 比如<command>groff</command>和<emphasis>Ghostscript</emphasis>就可以将它们的输出直接发送给<command>lp</command>. </para>

	      <para><prompt>bash$ </prompt><userinput>groff -Tascii file.tr | lp</userinput>
	        </para>

	      <para><prompt>bash$ </prompt><userinput>gs -options | lp file.ps</userinput>
	        </para>

			<para>还有一些相关的命令, 比如<command>lpq</command>, 
				可以用来查看打印队列, 
	        而<command>lprm</command>, 可以从打印队列中删除作业. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="teeref"><command>tee</command></term>
	  <indexterm>
	    <primary>tee</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tee</secondary>
	  </indexterm>
	  <listitem>
	    <para>[这是UNIX从管道行业借来的主意.]</para>
	    <para>这是一个重定向操作, 但是与之前所看到的有点不同. 
			就像管道中的<quote>三通</quote>一样, 
			这个命令可以将命令或者管道命令的输出<quote>抽出</quote>到<emphasis>一个文件</emphasis>中, 
			而且不影响结果. 
			当你想将一个运行中进程的输出保存到文件时, 
			或者为了debug而保存输出记录的时候, 
			这个命令就显得非常有用了.
	      </para>
	    
	    <screen>
                             (重定向)
                            |----> 到文件
                            |
  ==========================|====================
  命令   --->   命令   ---> |tee ---> 命令 ---> ---> 管道的输出
  ===============================================
	      </screen>


	    <para><programlisting>cat listfile* | sort | tee check.file | uniq > result.file</programlisting>
	      (在对排序的结果进行<link
			  linkend="uniqref">uniq</link>(去掉重复行)之前, 
		  文件<filename>check.file</filename>保存了排过序的<quote>listfiles</quote>. )</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mkfifo</command></term>
	  <indexterm>
	    <primary>mkfifo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkfifo</secondary>
	  </indexterm>
	  <listitem>
		  <para><anchor id="namedpiperef">这个不大引人注意的命令可以创建一个<emphasis>命名管道</emphasis>, 
				  并产生一个临时的<emphasis>先进先出的buffer</emphasis>, 
				 用来在两个进程之间传递数据. 

				 <footnote><para>对于本话题的一个完美的介绍, 
				请参考Andy Vaught的文章, <ulink
				 url="http://www2.linuxjournal.com/lj-issues/issue41/2156.html">命名管道的介绍</ulink>, 
				 这是<ulink url="http://www.linuxjournal.com"><citetitle
		  pubwork="journal">Linux
		  Journal</citetitle>1997年9月的一个主题</ulink>. </para></footnote>

		  典型的应用是一个进程向FIFO中写数据, 
		  另一个进程读出来. 请参考<xref linkend="fifo">. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>pathchk</command></term>
	  <indexterm>
	    <primary>pathchk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pathchk</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个命令用来检查文件名的有效性. 
			  如果文件名超过了最大允许长度(255个字符), 
			  或者它所在的一个或多个路径搜索不到, 
			  那么就会产生一个错误结果.
	      </para>
	      
		  <para>不幸的是, 
			  <command>pathchk</command>并不能够返回一个可识别的错误码, 
			  因此它在脚本中几乎没有什么用. 
	      可以考虑使用<link linkend="rtif">文件测试操作</link>来替代这个命令. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="ddref"><command>dd</command></term>
	  <indexterm>
	    <primary>dd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dd</secondary>
	  </indexterm>
	  <listitem>
		  <para>这也是一个不太出名的工具, 
			  但却是一个令人恐惧的<quote>数据复制</quote>命令. 
			  最开始, 这个命令被用来在UNIX微机和IBM大型机之间通过磁带来交换数据, 
			  这个命令现在仍然有它的用途. 
			  <command>dd</command>命令只不过是简单的拷贝一个文件(或者<filename>stdin/stdout</filename>), 
			  但是它会做一些转换. 
			  下边是一些可能的转换, 比如 ASCII/EBCDIC, 
	        
		<footnote><para><acronym>EBCDIC</acronym> (发音是<quote>ebb-sid-ick</quote>)是单词(Extended Binary Coded Decimal Interchange Code)的首字母缩写. 
		  这是IBM的数据格式, 现在已经不常见了. 
		  <command>dd</command>命令的<option>conv=ebcdic</option>选项有一种比较古怪的用法, 
		  那就是对一个文件进行快速容易但不太安全的编码. 
		    <programlisting>cat $file | dd conv=swab,ebcdic > $file_encrypted
# 编码(看起来好像没什么用).		    
# 应该交换字节(swab), 有点晦涩. 

cat $file_encrypted | dd conv=swab,ascii > $file_plaintext
# 解码. </programlisting>
                </para></footnote>

				大写/小写, 在输入和输出之间的字节对的交换, 
				还有对输入文件做一些截头去尾的工作.
				<userinput>dd --help</userinput>列出了所有转换, 
				还列出了这个强大工具的其他一些选项. 
	      </para>

            <para>
	      <programlisting># 将一个文件转换为大写: 

dd if=$filename conv=ucase > $filename.uppercase
#                    lcase   # 转换为小写</programlisting>
            </para>

	    <example id="selfcopy">
	      <title>一个拷贝自身的脚本</title>
	      <programlisting>&selfcopy;</programlisting>
	    </example>

	    <example id="exercisingdd">
	      <title>练习<command>dd</command></title>
	      <programlisting>&exercisingdd;</programlisting>
	    </example>


		<para>为了展示<command>dd</command>的多种用途, 
			让我们使用它来记录按键. </para>

	    <example id="ddkeypress">
	      <title>记录按键</title>
	      <programlisting>&ddkeypress;</programlisting>
	    </example>	    

	    <para><command>dd</command>命令可以在数据流上做随机访问. 

	        <programlisting>echo -n . | dd bs=1 seek=4 of=file conv=notrunc
# "conv=notrunc"选项意味着输出文件不能被截短. 

# 感谢, S.C.</programlisting>
            </para>


			<para><command>dd</command>命令可以将数据或磁盘镜像拷贝到设备中, 
			也可以从设备中拷贝数据或磁盘镜像, 
			比如说磁盘或磁带设备都可以(<xref linkend="copycd">). 
				通常用来创建启动磁盘. </para>
             <para>
		<userinput>dd if=kernel-image of=/dev/fd0H1440</userinput>
             </para>

			 <para>同样的, <command>dd</command>可以拷贝软盘的整个内容(甚至是<quote>其他</quote>操作系统的磁盘格式), 
				 到硬盘驱动器上(以镜像文件的形式). 
	       </para>
             <para>
		<userinput>dd if=/dev/fd0 of=/home/bozo/projects/floppy.img</userinput>
             </para>

             <para>
				 <command>dd</command>命令还有一些其他用途, 
				 包括可以初始化临时交换文件(<xref linkend="ex73">)和ramdisks(内存虚拟硬盘)(<xref linkend="ramdisk">). 
				它甚至可以做一些对整个硬盘分区的底层拷贝, 
				虽然不建议这么做. </para>

	    <para>某些(可能是比较无聊的)人总会想一些关于<command>dd</command>命令的有趣应用. </para>

	    <example id="blotout">
	      <title>安全的删除一个文件</title>
	      <programlisting>&blotout;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="odref"><command>od</command></term>
	  <indexterm>
	    <primary>od</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>od</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>od</command>, 或者<emphasis>octal dump</emphasis>过滤器, 
			  将会把输入(或文件)转换为8进制或者其他进制. 
			  在你需要查看或处理一些二进制数据文件或者一个不可读的系统设备文件的时候, 
			  这个命令非常有用, 比如<filename>/dev/urandom</filename>, 
	      或者是一个二进制数据过滤器. 请参考<xref
	      linkend="seedingrandom">和<xref linkend="rnd">. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>hexdump</command></term>
	  <indexterm>
	    <primary>hexdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hexadecimal</secondary>
	  </indexterm>
	  <listitem>
		  <para>对二进制文件进行 16进制, 8进制, 10进制, 
			  或者ASCII码的查阅动作. 这个命令大体上与上边的<command>od</command>命令的作用相同, 
			  但是远没有<command>od</command>命令有用. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>objdump</command></term>
	  <indexterm>
	    <primary>objdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>object binary dump</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示编译后的二进制文件或二进制可执行文件的信息, 
			  以16进制的形式显示, 或者显示反汇编列表(使用<option>-d</option>选项). </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>objdump -d /bin/ls</userinput>
<computeroutput>/bin/ls:     file format elf32-i386

 Disassembly of section .init:

 080490bc &lt;.init&gt;:
  80490bc:       55                      push   %ebp
  80490bd:       89 e5                   mov    %esp,%ebp
  . . .</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mcookie</command></term>
	  <indexterm>
	    <primary>magic</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cookie</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个命令会产生一个<quote>magic cookie</quote>, 
			  这是一个128-bit(32-字符)的伪随机16进制数字, 
			  这个数字一般都用来作为X server的鉴权<quote>签名</quote>. 
			  这个命令还可以用来在脚本中作为一种生成随机数的手段, 
			  当然这是一种<quote>小吃店</quote>(译者注: 虽然不太正统, 但是方便快捷)的风格. 
	      <programlisting>random000=$(mcookie)</programlisting>
	    </para>

	    <para>当然, 要想达到同样的目的还可以使用<link linkend="md5sumref">md5</link>命令. 
	      <programlisting># 产生关于脚本自身的md5 checksum. 
random001=`md5sum $0 | awk '{print $1}'`
# 使用 'awk' 来去掉文件名. </programlisting>
	    </para>

	    <para><command>mcookie</command>命令还给出了另一种产生<quote>唯一</quote>文件名的方法. </para>

	    <example id="tempfilename">
	      <title>文件名产生器</title>
	      <programlisting>&tempfilename;</programlisting>
	    </example>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>units</command></term>
	  <indexterm>
	    <primary>units</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>conversion</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个工具用来在不同的计量单位之间互相转换. 
			  当你在交互模式下正常调用时, 
			  会发现在脚本中<command>units</command>命令也是非常有用的. </para>
	    <example id="unitconversion">
	      <title>将长度单位-米, 转化为英里</title>
	      <programlisting>&unitconversion;</programlisting>
	    </example>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>m4</command></term>
	  <indexterm>
	    <primary>m4</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>macro</secondary>
	  </indexterm>
	  <listitem>
	    <para>一个隐藏的财宝, <command>m4</command>是一个强大的宏处理过滤器, 
			<footnote><para><emphasis>宏</emphasis>是一个符号常量, 
				将会被扩展成一个命令字符串或者一系列的参数进行操作. 
		 </para></footnote>
		 差不多可以说是一种语言了. 
		 虽然最开始这个工具是用来作为<emphasis>RatFor</emphasis>的预处理器而编写的, 
		 但是后来证明<command>m4</command>即使作为独立的工具来使用也是非常有用的. 
		 事实上, <command>m4</command>结合了许多工具的功能, 
		 比如<link linkend="evalref">eval</link>,
	      <link linkend="trref">tr</link>, 和<link
	      linkend="awkref">awk</link>, 除此之外, 它还使得宏扩展变得更加容易. 
	      </para>

	    <para>在2004年4月的<ulink url="http://www.linuxjournal.com"><citetitle
	      pubwork="journal">Linux Journal</citetitle></ulink>问题列表中有一篇关于<command>m4</command>命令用法的好文章. </para>

	    <example id="m4">
	      <title>使用m4</title>
	      <programlisting>&m4;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>doexec</command></term>
	  <indexterm>
	    <primary>doexec</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>executable arg list</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>doexec</command>命令允许将一个随便的参数列表传递到一个
			<emphasis>二进制可执行文件</emphasis>中. 
			比较特殊的, 甚至可以传递<varname>argv[0]</varname>(相当于脚本中的<link
	      linkend="posparamref1">$0</link>), 这样就可以使用不同的名字来调用这个可执行文件, 
	  并且通过不同的调用名字, 还可以让这个可执行文件执行不同的动作. 
	  这也可以说是一种将参数传递到可执行文件中的比较绕圈子的做法. 
	      </para>

		  <para>比如, 
			<filename class="directory">/usr/local/bin</filename>目录可能包含一个<quote>aaa</quote>的二进制文件. 
			使用<command>doexec /usr/local/bin/aaa list</command>可以<emphasis>列出</emphasis>当前工作目录下所有以<quote>a</quote>开头的文件, 
			而使用<command>doexec /usr/local/bin/aaa delete </command>将会<emphasis>删除</emphasis>这些文件. </para>

		<note><para>可执行文件的不同行为必须定义在可执行文件自身的代码中, 
				可以使用如下的shell脚本来做类比: 
                <programlisting>case `basename $0` in
"name1" ) do_something;;
"name2" ) do_something_else;;
"name3" ) do_yet_another_thing;;
*       ) bail_out;;
esac</programlisting></para></note>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>dialog</command></term>
	  <indexterm>
	    <primary>dialog</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dialog</secondary>
	  </indexterm>
	  <listitem>
	    <para><link linkend="dialogref">dialog</link>工具集提供了一种从脚本中调用交互对话框的方法. 
	      <command>dialog</command>更好的变种版本是 --
	      <command>gdialog</command>, <command>Xdialog</command>,
	      和<command>kdialog</command> -- 事实上是调用X-Windows的界面工具集. 
	      请参考<xref linkend="dialog">. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sox</command></term>
	  <indexterm>
	    <primary>sox</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sound</secondary>
	  </indexterm>
	  <listitem>

	    <para><command>sox</command>命令, 
	      也就是<quote><emphasis>so</emphasis>und
			  e<emphasis>x</emphasis>change</quote>命令, 
		 可以进行声音文件的转换. 
	      事实上, 可执行文件<filename>/usr/bin/play</filename>(现在不建议使用)只不过是<emphasis>sox</emphasis>的一个shell包装器而已. </para>

            <para>举个例子, <command>sox soundfile.wav
	      soundfile.au</command>将会把一个WAV文件转换成(Sun音频格式)AU声音文件. </para>

  <para>Shell脚本非常适合于使用<command>sox</command>的声音操作来批处理声音文件. 
	  比如, <ulink url="http://osl.iu.edu/~tveldhui/radio/"> Linux Radio
	      Timeshift HOWTO</ulink>和<ulink
	      url="http://savannah.nongnu.org/projects/audiodo">MP3do
	      Project</ulink>. </para>

	  </listitem>
	</varlistentry>


      </variablelist>

        </sect1> <!-- End Miscellaneous Commands -->

  </chapter> <!-- External Filters, Programs and Commands -->



  <chapter id="system">
    <title>系统与管理命令</title>


      <para>在<filename class="directory">/etc/rc.d</filename>目录中的启动和关机脚本中包含了好多有用的(和没用的)系统管理命令. 
		  这些命令通常总是被root用户使用, 用于系统维护或者是紧急系统文件修复. 
		  一定要小心使用这些工具, 因为如果滥用的话, 它们会损坏你的系统. </para>

      <variablelist id="usersgroups">
        <title><anchor id="usersgroups1">User和Group类</title>

	<varlistentry>
	  <term><command>users</command></term>
	  <indexterm>
	    <primary>users</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>users</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示所有的登录用户. 这个命令与<command>who -q</command>基本一致. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>groups</command></term>
	  <indexterm>
	    <primary>groups</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>groups</secondary>
	  </indexterm>
	  <listitem>
	    <para>列出当前用户和他所属的组. 这相当于<link
				linkend="groupsref">$GROUPS</link>内部变量, 
			但是这个命令将会给出组名字, 而不是数字. </para>
	    <screen><prompt>bash$ </prompt><userinput>groups</userinput>
<computeroutput>bozita cdrom cdwriter audio xgrp</computeroutput>

<prompt>bash$ </prompt><userinput>echo $GROUPS</userinput>
<computeroutput>501</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chown</command></term>
	  <term><command>chgrp</command></term>
	  <indexterm>
	    <primary>chown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chown</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>chgrp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chgrp</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>chown</command>命令将会修改一个或多个文件的所有权. 
			对于<replaceable>root</replaceable>用户来说, 
		   如果他想将文件的所有权从一个用户换到另一个用户的话, 
	      那么使用这个命令是非常好的选择. 
	      一个普通用户不能修改文件的所有权, 即使他是文件的宿主也不行. 
	         <footnote><para>这是在Linux机器上或者在带有磁盘配额的UNIX系统上的真实情况. </para></footnote>
	      </para>

	  <para>
	      <screen><prompt>root# </prompt><userinput>chown bozo *.txt</userinput>
<computeroutput></computeroutput>
	      </screen>
	    </para>

		<para><command>chgrp</command>将会修改一个或多个文件的<replaceable>group</replaceable>所有权. 
			但前提是你必须是这些文件的宿主, 并且必须是目的组的成员(或者是<replaceable>root</replaceable>), 
			这样你才能够使用这个命令. 
	      <programlisting>chgrp --recursive dunderheads *.data
#  "dunderheads"(译者: 晕,蠢才...) 组现在拥有了所有的"*.data"文件. 
#+ 包括所有$PWD目录下的子目录中的文件(--recursive的作用就是包含子目录). 
</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>useradd</command></term>
	  <term><command>userdel</command></term>
	  <indexterm>
	    <primary>useradd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>useradd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>userdel</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>userdel</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>useradd</command>管理命令将会在系统上添加一个用户帐号, 
			  并且如果指定的话, 还会为特定的用户创建home目录. 
	      相应的, <command>userdel</command>命令将会从系统上删除一个用户帐号, 
		 <footnote><para>如果正在被删除的特定用户已经登录了主机, 那么<command>userdel</command>命令将会失败. </para></footnote>
	      并且会删除相应的文件. </para>

	  <note><para><command>adduser</command>与<command>useradd</command>是完全相同的, 
			<command>adduser</command>通常仅仅是个符号链接. 
	      </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>usermod</command></term>
	  <indexterm>
	    <primary>usermod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>usermod</secondary>
	  </indexterm>
	  <listitem>
		  <para>修改用户帐号. 可以修改给定用户帐号的密码, 
			  组身份, 截止日期, 或者其他一些属性. 
			  使用这个命令, 用户的密码可能会被锁定, 因为密码会影响到帐号的有效性. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>groupmod</command></term>
	  <indexterm>
	    <primary>groupmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>group</secondary>
	  </indexterm>
	  <listitem>
	    <para>修改指定组. 组名字或者ID号都可以用这个命令来修改. 
	      </para>
	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="idref"><command>id</command></term>
	  <indexterm>
	    <primary>id</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>id</secondary>
	  </indexterm>
	  <listitem>

		  <para><command>id</command>命令将会列出当前进程真实有效的用户ID, 还有用户的组ID. 
			  这与Bash内部变量<link linkend="uidref">$UID</link>,
	      <link linkend="euidref">$EUID</link>, 和<link
	      linkend="groupsref">$GROUPS</link>很相像. 
	      </para>

	    <screen><prompt>bash$ </prompt><userinput>id</userinput>
<computeroutput>uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)</computeroutput>

<prompt>bash$ </prompt><userinput>echo $UID</userinput>
<computeroutput>501</computeroutput></screen>

		<note><para><command>id</command>命令只有在<emphasis>有效</emphasis>ID与<emphasis>实际</emphasis>ID不符时, 
				才会显示<emphasis>有效</emphasis>ID. </para></note>

            <para>请参考<xref linkend="amiroot">. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="whoref"><command>who</command></term>
	  <indexterm>
	    <primary>who</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>whoami</secondary>
	  </indexterm>
	  <listitem>

	    <para>显示系统上所有已经登录的用户. </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>who</userinput>
<computeroutput>bozo  tty1     Apr 27 17:45
 bozo  pts/0    Apr 27 17:46
 bozo  pts/1    Apr 27 17:47
 bozo  pts/2    Apr 27 17:49
</computeroutput>
	      </screen>
	    </para>

	    <para><option>-m</option>选项将会给出当前用户的详细信息. 
			将任意两个参数传递到<command>who</command>中, 
			都等价于<command>who -m</command>, 
			就像<command>who am i</command>或<command>who The Man</command>. 
		</para> 
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>who -m</userinput>
<computeroutput>localhost.localdomain!bozo  pts/2    Apr 27 17:49</computeroutput>
	      </screen>
	    </para>


	    <para><anchor id="whoamiref"><command>whoami</command>与<command>who
	      -m</command>很相似, 但是只列出用户名. </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>whoami</userinput>
<computeroutput>bozo</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>w</command></term>
	  <indexterm>
	    <primary>w</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>w</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示所有的登录用户和属于它们的进程. 
			  这是一个<command>who</command>命令的扩展版本. 
			  <command>w</command>的输出可以通过管道传递到<command>grep</command>命令中, 
			  这样就可以查找指定的用户或进程. </para>
	    <screen><prompt>bash$ </prompt><userinput>w | grep startx</userinput>
<computeroutput>bozo  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>logname</command></term>
	  <indexterm>
	    <primary>logname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logname</secondary>
	  </indexterm>
	  <listitem>

		  <para>显示当前用户的登录名(可以在<filename>/var/run/utmp</filename>中找到). 
			  这与上边的<link linkend="whoamiref">whoami</link>很相近. 
	      </para>

	    <screen><prompt>bash$ </prompt><userinput>logname</userinput>
<computeroutput>bozo</computeroutput>

<prompt>bash$ </prompt><userinput>whoami</userinput>
<computeroutput>bozo</computeroutput></screen>	    

            <para>然而...</para>

	    <screen><prompt>bash$ </prompt><userinput>su</userinput>
<computeroutput>Password: ......</computeroutput>

<prompt>bash# </prompt><userinput>whoami</userinput>
<computeroutput>root</computeroutput>
<prompt>bash# </prompt><userinput>logname</userinput>
<computeroutput>bozo</computeroutput></screen>	    

	      
	    <note><para><command>logname</command>只会打印出登录的用户名, 
				而<command>whoami</command>将会给出附着到当前进程的用户名. 
				就像我们上边看到的那样, 这两个名字有时会不同. </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="suref"><command>su</command></term>
	  <indexterm>
	    <primary>su</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>su</secondary>
	  </indexterm>
	  <listitem>
	    <para>使用替换的用户(<emphasis>s</emphasis>ubstitute <emphasis>u</emphasis>ser)身份来运行一个程序或脚本. 
			<command>su rjones</command>将会以用户<emphasis>rjones</emphasis>的身份来启动shell. 
			使用<command>su</command>命令时, 如果不使用任何参数的话, 
			那默认就是<emphasis>root</emphasis>用户. 请参考<xref linkend="fifo">. 
			</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sudo</command></term>
	  <indexterm>
	    <primary>sudo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sudo</secondary>
	  </indexterm>
	  <listitem>
		  <para>以root(或其他用户)的身份来运行一个命令. 
			  这个命令可以用在脚本中, 这样就允许以正规的用户身份来运行脚本. 
	      </para>

	      <para><programlisting>#!/bin/bash

# 某些命令. 
sudo cp /root/secretfile /home/bozo/secret
# 其余的命令. </programlisting></para>
	    
	    <para>文件<filename>/etc/sudoers</filename>中保存有允许调用<command>sudo</command>命令的用户名. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>passwd</command></term>
	  <indexterm>
	    <primary>passwd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>password</secondary>
	  </indexterm>
	  <listitem>

	    <para>设置, 修改, 或者管理用户的密码. </para>

	    <para><command>passwd</command>命令可以用在脚本中, 
	      但是<emphasis>估计你不想这么用</emphasis>, 呵呵. </para>

	    <example id="setnewpw">
	      <title>设置一个新密码</title>
	      <programlisting>&setnewpw;</programlisting>
	    </example>

            <para><command>passwd</command>命令的<option>-l</option>,
				<option>-u</option>, 和<option>-d</option>选项允许锁定, 
				解锁, 和删除一个用户的密码. 只有root用户可以使用这些选项. 
			</para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ac</command></term>
	  <indexterm>
	    <primary>ac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>accounting</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示用户登录的连接时间, 
			  就像从<filename>/var/log/wtmp</filename>中读取一样. 
			  这是一个GNU统计工具. 
	      </para>
	    <screen><prompt>bash$ </prompt><userinput>ac</userinput>
<computeroutput>        total       68.08</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>last</command></term>
	  <indexterm>
	    <primary>last</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logged in</secondary>
	  </indexterm>
	  <listitem>

		  <para>用户<emphasis>最后</emphasis>登录的信息, 
			  就像从<filename>/var/log/wtmp</filename>中读出来一样. 
			  这个命令也可以用来显示远端登录. 
	      </para>

            <para>比如, 显示最后几次系统的重启信息: </para>

	    <screen><prompt>bash$ </prompt><userinput>last reboot</userinput>
<computeroutput>reboot   system boot  2.6.9-1.667      Fri Feb  4 18:18          (00:02)    
 reboot   system boot  2.6.9-1.667      Fri Feb  4 15:20          (01:27)    
 reboot   system boot  2.6.9-1.667      Fri Feb  4 12:56          (00:49)    
 reboot   system boot  2.6.9-1.667      Thu Feb  3 21:08          (02:17)    
 . . .

 wtmp begins Tue Feb  1 12:50:09 2005</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>newgrp</command></term>
	  <indexterm>
	    <primary>newgrp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>group</secondary>
	  </indexterm>
	  <listitem>
		  <para>不用登出就可以修改用户的组ID. 并且允许访问新组的文件. 
			  因为用户可能同时属于多个组, 这个命令很少被使用. 
	      </para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="terminalssys">
        <title><anchor id="terminalssys1">终端类命令</title>

	<varlistentry>
	  <term><command>tty</command></term>
	  <indexterm>
	    <primary>tty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tty</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示当前用户终端的名字. 
			  注意每一个单独的<firstterm>xterm</firstterm>窗口都被算作一个不同的终端.
	      </para>
	    <screen><prompt>bash$ </prompt><userinput>tty</userinput>
<computeroutput>/dev/pts/1</computeroutput></screen>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="sttyref"><command>stty</command></term>
	  <indexterm>
	    <primary>stty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>stty</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示并(或)修改终端设置. 这个复杂命令可以用在脚本中, 
			  并可以用来控制终端的行为和其显示输出的方法. 参见这个命令的info页, 并仔细学习它.
	      </para>

	    <example id="erase">
	      <title>设置一个擦除字符</title>
	      <programlisting>&erase;</programlisting>
	    </example>

	    <example id="secretpw">
	      <title><command>保密密码</command>: 关闭终端对于密码的echo</title>
	      <programlisting>&secretpw;</programlisting>
	    </example>

		<para>一个创造性的<command>stty</command>命令的用法, 
			检测用户所按的键(不用敲<keycap>回车</keycap>). 
		</para>

	    <example id="keypress">
	      <title>按键检测</title>
	      <programlisting>&keypress;</programlisting>
	    </example>

	    <para>请参考<xref linkend="timeout">. </para>


	    <sidebar><title>终端与模式terminals and modes</title>

			<para>一般情况下, 一个终端都是工作在<emphasis>canonical</emphasis>(标准)模式下. 
				当用户按键后, 事实上所产生的字符并没有马上传递到运行在当前终端上的程序. 
				终端上的一个本地缓存保存了这些按键. 当用按下<keycap>回车</keycap>键的时候, 
				才会将所有保存的按键信息传递到运行的程序中. 
				这就意味着在终端内部存在一个基本的行编辑器. 
			</para>

	    <para>
	        <screen><prompt>bash$ </prompt><userinput>stty -a</userinput>
<computeroutput>speed 9600 baud; rows 36; columns 96; line = 0;
 intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;
 start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O;
 ...
 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt</computeroutput>
                </screen>
	    </para>

            <para>在使用canonical模式的时候, 可以对本地终端行编辑器所定义的特殊按键进行重新定义. 

	        <screen>
<prompt>bash$ </prompt><userinput>cat > filexxx</userinput>
<userinput>wha&lt;ctl-W&gt;I&lt;ctl-H&gt;foo bar&lt;ctl-U&gt;hello world&lt;ENTER&gt;</userinput>
<userinput>&lt;ctl-D&gt;</userinput>
<prompt>bash$ </prompt><userinput>cat filexxx</userinput>
<computeroutput>hello world</computeroutput>		
<prompt>bash$ </prompt><userinput>wc -c < filexxx</userinput>
<computeroutput>12</computeroutput>		
                </screen>

				控制终端的进程只保存了12个字符(11个字母加上一个换行), 
				虽然用户敲了26个按键. 
            </para>

            <para>在non-canonical((<quote>raw</quote>)模式下, 
				每次按键(包括特殊定义的按键, 
				比如<keycap>ctl-H</keycap>)都将会立即发送一个字符到控制进程中. 
              </para>


			  <para>Bash提示符禁用了<option>icanon</option>和<option>echo</option>, 
				  因为它用自己的行编辑器代替了终端的基本行编辑器, 因为Bash的行编辑器更好. 
				  比如, 当你在Bash提示符下敲<keycap>ctl-A</keycap>的时候, 
				  终端将不会显示<keycap>^A</keycap>, 
				  但是Bash将会获得<keycap>\1</keycap>字符, 
				  然后解释这个字符, 这样光标就移动到行首了.
              </para>

	    <para><emphasis>Stephane Chazelas</emphasis></para>  

	    </sidebar>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>setterm</command></term>
	  <indexterm>
	    <primary>setterm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>terminal</secondary>
	  </indexterm>
	  <listitem>

		  <para>设置特定的终端属性. 
			这个命令将向它所在终端的<filename>stdout</filename>发送一个字符串, 
			这个字符串将修改终端的行为.
	      </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>setterm -cursor off</userinput>
<computeroutput>bash$</computeroutput>
	      </screen>
	    </para>

		<para><command>setterm</command>命令可以放在脚本中用来修改写入到<filename>stdout</filename>上的文本的外观. 
			当然, 如果你只想完成这个目的的话, 
			还有<link linkend="colorizingref">更合适的工具</link>可以用. </para>

	    <para><programlisting>setterm -bold on
echo bold hello

setterm -bold off
echo normal hello</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tset</command></term>
	  <indexterm>
	    <primary>tset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tset</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示或初始化终端设置. 
	      可以把它看成一个功能比较弱的<command>stty</command>命令. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>tset -r</userinput>
<computeroutput>Terminal type is xterm-xfree86.
 Kill is control-U (^U).
 Interrupt is control-C (^C).</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>setserial</command></term>
	  <indexterm>
	    <primary>setserial</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>serial</secondary>
	  </indexterm>
	  <listitem>

		  <para>设置或者显示串口参数. 
			  这个脚本只能被root用户来运行, 
			  并且通常都在系统安装脚本中使用.
	      </para>

	    <para><programlisting># 来自于/etc/pcmcia/serial脚本: 

IRQ=`setserial /dev/$DEVICE | sed -e 's/.*IRQ: //'`
setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>getty</command></term>
	  <term><command>agetty</command></term>
	  <indexterm>
	    <primary>getty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>getty</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>agetty</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>agetty</secondary>
	  </indexterm>
	  <listitem>
		  <para>一个终端的初始化过程通常都是使用<command>getty</command>或<command>agetty</command>来建立, 
			  这样才能让用户登录. 这些命令并不用在用户的shell脚本中. 
			  它们的行为与<command>stty</command>很相似. 
		  </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="mesgref"><command>mesg</command></term>
	  <indexterm>
	    <primary>mesg</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mesg</secondary>
	  </indexterm>
	  <listitem>
		  <para>启用或禁用当前用户终端的访问权限. 
			  禁用访问权限将会阻止网络上的另一用户向这个终端<link linkend="writeref">写</link>消息. 
	      </para>

		  <tip><para>当你正在编写文本文件的时候, 在文本中间突然来了一个莫名其妙的消息, 
				  你会觉得非常烦人. 在多用户的网络环境下, 如果你不想被打断, 
				那么你必须关闭其他用户对你终端的写权限. 
	      </para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="wallref"><command>wall</command></term>
	  <indexterm>
	    <primary>wall</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wall</secondary>
	  </indexterm>
	  <listitem>
		  <para>这是一个缩写单词<quote><link linkend="writeref">write</link> all</quote>, 
			 也就是, 向登录到网络上的所有终端的所有用户都发送一个消息. 
			 最早这是一个管理员的工具, 很有用, 比如, 
			 当系统有问题的时候, 
			 管理可以警告系统上的所有人暂时离开(请参考<xref linkend="ex70">). 
			 </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>wall System going down for maintenance in 5 minutes!</userinput>
<computeroutput>Broadcast message from bozo (pts/1) Sun Jul  8 13:53:27 2001...

 System going down for maintenance in 5 minutes!</computeroutput>
	      </screen>
	    </para>

		<note><para>如果某个特定终端使用<command>mesg</command>来禁止了写权限, 
				那么<command>wall</command>将不会给它发消息. 
	      </para></note>

	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="statisticssys">
        <title><anchor id="statisticssys1">信息与统计类</title>

	<varlistentry>
	  <term><command>uname</command></term>
	  <indexterm>
	    <primary>uname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uname</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示系统信息(OS, 内核版本, 等等.) ,输出到<filename>stdout</filename>上. 
			  使用<option>-a</option>选项, 将会给出详细的系统信息(请参考<xref linkend="ex41">). 
				  使用<option>-s</option>选项只会输出OS类型. </para>

	    <screen><prompt>bash$ </prompt><userinput>uname -a</userinput>
<computeroutput>Linux localhost.localdomain 2.2.15-2.5.0 #1 Sat Feb 5 00:13:43 EST 2000 i686 unknown</computeroutput>

<prompt>bash$ </prompt><userinput>uname -s</userinput>
<computeroutput>Linux</computeroutput></screen>	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>arch</command></term>
	  <indexterm>
	    <primary>arch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>arch</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示系统的硬件体系结构. 
			  等价于<command>uname -m</command>. 
			  请参考<xref linkend="casecmd">. </para>
	    <screen><prompt>bash$ </prompt><userinput>arch</userinput>
<computeroutput>i686</computeroutput>

<prompt>bash$ </prompt><userinput>uname -m</userinput>
<computeroutput>i686</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lastcomm</command></term>
	  <indexterm>
	    <primary>lastcomm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>last</secondary>
	  </indexterm>
	  <listitem>
		  <para>给出前一个命令的信息, 存储在<filename>/var/account/pacct</filename>文件中. 
			  命令名字和用户名字都可以通过选项来指定. 这是GNU的一个统计工具. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="lastlogref"><command>lastlog</command></term>
	  <indexterm>
	    <primary>lastlog</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>last</secondary>
	  </indexterm>
	  <listitem>
		  <para>列出系统上所有用户最后登录的时间. 
			  然后保存到<filename>/var/log/lastlog</filename>文件中. </para>
	    <para>
	      <screen><prompt>bash$ </prompt><userinput>lastlog</userinput>
<computeroutput>root          tty1                      Fri Dec  7 18:43:21 -0700 2001
 bin                                     **Never logged in**
 daemon                                  **Never logged in**
 ...
 bozo          tty1                      Sat Dec  8 21:14:29 -0700 2001</computeroutput>



<prompt>bash$ </prompt><userinput>lastlog | grep root</userinput>
<computeroutput>root          tty1                      Fri Dec  7 18:43:21 -0700 2001</computeroutput>
	      </screen>
	      </para>

		  <caution><para>如果用户对于文件<filename>/var/log/lastlog</filename>没有读权限的话, 
				  那么调用这个命令就会失败. </para></caution>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lsof</command></term>
	  <indexterm>
	    <primary>lsof</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lsof</secondary>
	  </indexterm>
	  <listitem>
		  <para>列出打开的文件. 这个命令将会把所有当前打开的文件都列出到一份详细的表格中, 
			  包括文件的宿主信息, 尺寸, 还有与它们相关的信息等等. 
			  当然, <command>lsof</command>也可以通过管道输出到<link linkend="grepref">grep</link>和(或)<link linkend="awkref">awk</link>中, 
			  来分析它的内容. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>lsof</userinput>
<computeroutput>COMMAND    PID    USER   FD   TYPE     DEVICE    SIZE     NODE NAME
 init         1    root  mem    REG        3,5   30748    30303 /sbin/init
 init         1    root  mem    REG        3,5   73120     8069 /lib/ld-2.1.3.so
 init         1    root  mem    REG        3,5  931668     8075 /lib/libc-2.1.3.so
 cardmgr    213    root  mem    REG        3,5   36956    30357 /sbin/cardmgr
 ...</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>strace</command></term>
	  <indexterm>
	    <primary>strace</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>trace</secondary>
	  </indexterm>
	  <listitem>
	    <para>系统跟踪(<command>S</command>ystem <command>trace</command>): 
			是跟踪<firstterm>系统调用</firstterm>和信号的诊断和调试工具. 
			如果你想了解特定的程序或者工具包为什么运行失败的话, 
			那么这个命令和下边的<command>ltrace</command>命令就显得非常有用了, 
	       . . . 当然, 这种失败现象可能是由缺少相关的库, 或者其他问题所引起. 
	      </para>

	    <para>
	    <screen><prompt>bash$ </prompt><userinput>strace df</userinput>
<computeroutput>execve("/bin/df", ["df"], [/* 45 vars */]) = 0
 uname({sys="Linux", node="bozo.localdomain", ...}) = 0
 brk(0)                                  = 0x804f5e4

 ...</computeroutput>
	    </screen>
	    </para>

	    <para>这是Solaris <command>truss</command>命令的Linux的等价工具. </para> 

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ltrace</command></term>
	  <indexterm>
	    <primary>ltrace</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>trace</secondary>
	  </indexterm>
	  <listitem>
	    <para>库跟踪工具(<command>L</command>ibrary <command>trace</command>): 
	      跟踪给定命令的<firstterm>调用库</firstterm>的相关信息. 
	      </para>

	    <para>
	    <screen><prompt>bash$ </prompt><userinput>ltrace df</userinput>
<computeroutput>__libc_start_main(0x804a910, 1, 0xbfb589a4, 0x804fb70, 0x804fb68 &lt;unfinished ...&gt:
 setlocale(6, "")                                 = "en_US.UTF-8"
bindtextdomain("coreutils", "/usr/share/locale") = "/usr/share/locale"
textdomain("coreutils")                          = "coreutils"
__cxa_atexit(0x804b650, 0, 0, 0x8052bf0, 0xbfb58908) = 0
getenv("DF_BLOCK_SIZE")                          = NULL

 ...</computeroutput>
	    </screen>
	    </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><anchor id="nmapref"><command>nmap</command></term>
	  <indexterm>
	    <primary>nmap</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>port scan</secondary>
	  </indexterm>
	  <listitem>
	    <para>网络映射(<command>N</command>etwork <command>map</command>per)与端口扫描程序. 
			这个命令将会扫描一个服务器来定位打开的端口, 
			并且定位与这些端口相关的服务. 
	      这个命令也能够上报一些包过滤与防火墙的信息. 
	     这是一个防止网络被黑客入侵的非常重要的安全工具. 
	      </para>
	    <para><programlisting>#!/bin/bash

SERVER=$HOST                           # localhost.localdomain (127.0.0.1).
PORT_NUMBER=25                         # SMTP端口.

nmap $SERVER | grep -w "$PORT_NUMBER"  # 察看指定端口是否打开?
#              grep -w 匹配整个单词. 
#+             这样就不会匹配类似于1025这种含有25的端口了. 

exit 0

# 25/tcp     open        smtp</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>nc</command></term>
	  <indexterm>
	    <primary>nc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>nc</secondary>
	  </indexterm>
	  <listitem>

		  <para><command>nc</command>(<emphasis>netcat</emphasis>)工具是一个完整的工具包, 
			  可以用它连接和监听TCP和UDP端口. 
			  它能作为诊断和测试工具, 
			  也能作为基于脚本的HTTP客户端和服务器组件. 
	      </para>

	    <para>
	    <screen><prompt>bash$ </prompt><userinput>nc localhost.localdomain 25</userinput>
<computeroutput>220 localhost.localdomain ESMTP Sendmail 8.13.1/8.13.1; Thu, 31 Mar 2005 15:41:35 -0700</computeroutput></screen>
	    </para>

            <example id="iscan">
              <title>扫描远程机器上的<emphasis>identd</emphasis>服务进程</title>
              <programlisting>&iscan;</programlisting>
            </example>

	    <para>
			并且, 当然, 
			这里还有Dr. Andrew Tridgell在BistKeeper事件中臭名卓著的一行脚本: 
	        <programlisting>echo clone | nc thunk.org 5000 > e2fsprogs.dat</programlisting>
	    </para>
	      
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="freeref"><command>free</command></term>
	  <indexterm>
	    <primary>free</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>free</secondary>
	  </indexterm>
	  <listitem>
		  <para>使用表格形式来显示内存和缓存的使用情况. 
			  这个命令的输出非常适合于使用<link linkend="grepref">grep</link>, 
			  <link linkend="awkref">awk</link>或者<command>Perl</command>来分析. 
			  <command>procinfo</command>将会显示<command>free</command>命令所能显示的所有信息, 而且更加详细. 
	      </para>

	    <screen><prompt>bash$ </prompt><command>free</command>
<computeroutput>                total       used       free     shared    buffers     cached
   Mem:         30504      28624       1880      15820       1608       16376
   -/+ buffers/cache:      10640      19864
   Swap:        68540       3128      65412</computeroutput></screen>

            <para>打印出未使用的RAM内存: </para>
	    <screen><prompt>bash$ </prompt><command>free | grep Mem | awk '{ print $4 }'</command>
<computeroutput>1880</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="procinforef"><command>procinfo</command></term>
	  <indexterm>
	    <primary>procinfo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>procinfo</secondary>
	  </indexterm>
	  <listitem>
	    <para>从<link linkend="devprocref"><filename
	      class="directory">/proc</filename>
	  pseudo-filesystem</link>中提取并显示所有信息和统计资料. 
	  这个命令将给出更详细的信息. 
	      </para>

	    <screen><prompt>bash$ </prompt><userinput>procinfo | grep Bootup</userinput>
<computeroutput>Bootup: Wed Mar 21 15:15:50 2001    Load average: 0.04 0.21 0.34 3/47 6829</computeroutput>
</screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="lsdevref"><command>lsdev</command></term>
	  <indexterm>
	    <primary>lsdev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>device</secondary>
	  </indexterm>
	  <listitem>
	    <para>列出系统设备, 也就是显示所有安装的硬件. </para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>lsdev</userinput>
<computeroutput>Device            DMA   IRQ  I/O Ports
 ------------------------------------------------
 cascade             4     2 
 dma                          0080-008f
 dma1                         0000-001f
 dma2                         00c0-00df
 fpu                          00f0-00ff
 ide0                     14  01f0-01f7 03f6-03f6
 ...</computeroutput>
	      </screen>
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="duref"><command>du</command></term>
	  <indexterm>
	    <primary>du</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>du</secondary>
	  </indexterm>
	  <listitem>
	    <para>递归的显示(磁盘)文件的使用状况. 除非特殊指定, 否则默认是当前工作目录. 
	      </para>

	    <screen><prompt>bash$ </prompt><command>du -ach</command>
<computeroutput>1.0k    ./wi.sh
 1.0k    ./tst.sh
 1.0k    ./random.file
 6.0k    .
 6.0k    total</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="dfref"><command>df</command></term>
	  <indexterm>
	    <primary>df</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>df</secondary>
	  </indexterm>
	  <listitem>
	    <para>使用列表的形式显示文件系统的使用状况. </para>

	    <screen><prompt>bash$ </prompt><command>df</command>
<computeroutput>Filesystem           1k-blocks      Used Available Use% Mounted on
 /dev/hda5               273262     92607    166547  36% /
 /dev/hda8               222525    123951     87085  59% /home
 /dev/hda7              1408796   1075744    261488  80% /usr</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>dmesg</command></term>
	  <indexterm>
	    <primary>dmesg</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dmesg</secondary>
	  </indexterm>
	  <listitem>
		  <para>将所有的系统启动消息输出到<filename>stdout</filename>上. 
			  方便除错, 并且可以查出安装了哪些设备驱动和察看使用了哪些系统中断. 
	      <command>dmesg</command>命令的输出当然也放在脚本中, 并使用<link linkend="grepref">grep</link>, 
	      <link linkend="sedref">sed</link>, 或<link
	      linkend="awkref">awk</link>来进行分析. </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>dmesg | grep hda</userinput>
<computeroutput>Kernel command line: ro root=/dev/hda2
 hda: IBM-DLGA-23080, ATA DISK drive
 hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63
 hda: hda1 hda2 hda3 < hda5 hda6 hda7 > hda4</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>stat</command></term>
	  <indexterm>
	    <primary>stat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>stat</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示一个或多个给定文件(也可以是目录文件或设备文件)的详细统计信息(<emphasis>stat</emphasis>istic).  
	      </para>
	    <para>
	      <screen><prompt>bash$ </prompt><userinput>stat test.cru</userinput>
<computeroutput>  File: "test.cru"
   Size: 49970        Allocated Blocks: 100          Filetype: Regular File
   Mode: (0664/-rw-rw-r--)         Uid: (  501/ bozo)  Gid: (  501/ bozo)
 Device:  3,8   Inode: 18185     Links: 1    
 Access: Sat Jun  2 16:40:24 2001
 Modify: Sat Jun  2 16:40:24 2001
 Change: Sat Jun  2 16:40:24 2001</computeroutput>
	      </screen>
	    </para>

		<para>如果目标文件不存在, 
			<command>stat</command>将会返回一个错误消息. </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>stat nonexistent-file</userinput>
<computeroutput>nonexistent-file: No such file or directory</computeroutput>
	      </screen>
	    </para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="vmstatref"><command>vmstat</command></term>
	  <indexterm>
	    <primary>vmstat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>virtual memory</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示虚拟内存的统计信息. </para>
	    <para>
	    <screen><prompt>bash$ </prompt><userinput>vmstat</userinput>
<computeroutput>   procs                      memory    swap          io system         cpu
 r  b  w   swpd   free   buff  cache  si  so    bi    bo   in    cs  us  sy id
 0  0  0      0  11040   2636  38952   0   0    33     7  271    88   8   3 89</computeroutput>
	    </screen>
	    </para>
  
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>netstat</command></term>
	  <indexterm>
	    <primary>netstat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>netstat</secondary>
	  </indexterm>
	  <listitem>

		  <para>显示当前网络的统计状况和信息, 
			  比如路由表和激活的连接, 
			  这个工具将访问<filename>/proc/net</filename>(<xref linkend="devproc">)中的信息. 
				  请参考<xref linkend="constat">. </para>
	    <para><command>netstat -r</command>等价于<link
	      linkend="routeref">route</link>命令. </para>

	      <screen><prompt>bash$ </prompt><userinput>netstat</userinput>
<computeroutput>Active Internet connections (w/o servers)
 Proto Recv-Q Send-Q Local Address           Foreign Address         State      
 Active UNIX domain sockets (w/o servers)
 Proto RefCnt Flags       Type       State         I-Node Path
 unix  11     [ ]         DGRAM                    906    /dev/log
 unix  3      [ ]         STREAM     CONNECTED     4514   /tmp/.X11-unix/X0
 unix  3      [ ]         STREAM     CONNECTED     4513
 . . .</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="uptimeref"><command>uptime</command></term>
	  <indexterm>
	    <primary>uptime</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uptime</secondary>
	  </indexterm>
	  <listitem>

		  <para>显示系统运行的时间, 
			  还有其他的一些统计信息. 
	      </para>

	    <screen><prompt>bash$ </prompt><userinput>uptime</userinput>
<computeroutput>10:28pm  up  1:57,  3 users,  load average: 0.17, 0.34, 0.27</computeroutput></screen>

			<note><para><firstterm>load average</firstterm>如果小于或等于1, 
					那么就意味着系统会马上处理. 
					如果大于1, 那么就意味着进程需要排队. 
					如果大于3, 那么就意味着, 系统性能已经显著下降了.
	      </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="hnameref"><command>hostname</command></term>
	  <indexterm>
	    <primary>hostname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hostname</secondary>
	  </indexterm>
	  <listitem>

		  <para>显示系统的主机名字. 
			  这个命令在<filename class="directory">/etc/rc.d</filename>安装脚本(或类似的<filename>/etc/rc.d/rc.sysinit</filename>)中设置主机名. 
			  等价于<command>uname -n</command>, 
			  并且与<link linkend="hostnameref">$HOSTNAME</link>内部变量很相像. </para>

	    <screen><prompt>bash$ </prompt><userinput>hostname</userinput>
<computeroutput>localhost.localdomain</computeroutput>

<prompt>bash$ </prompt><userinput>echo $HOSTNAME</userinput>
<computeroutput>localhost.localdomain</computeroutput></screen>

	    <para>与<command>hostname</command>命令很相像的命令还有<command>domainname</command>, 
	      <command>dnsdomainname</command>, 
	      <command>nisdomainname</command>, 
		  和<command>ypdomainname</command>命令. 
		  使用这些命令来显示(或设置)系统DNS或NIS/YP域名. 
		  对于<command>hostname</command>命令来说, 
		  使用不同的选项就可以分别达到上边这些命令的目的. </para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="hostidref"><command>hostid</command></term>
	  <indexterm>
	    <primary>hostid</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>host id</secondary>
	  </indexterm>
	  <listitem>

	    <para>用16进制表示法来显示主机的32位ID. </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>hostid</userinput>
<computeroutput>7f0100</computeroutput></screen>
	    </para>

	    <note>
	    <para>这个命令据说对于特定系统可以获得一个<quote>唯一</quote>的序号. 
	      某些产品的注册过程可能会需要这个序号来作为用户的许可证. 
	      不幸的是, <command>hostid</command>只会使用字节对转换的方法来返回机器的网络地址, 网络地址用16进制表示. 
	      </para>

		  <para>对于一个典型的没有网络的Linux机器来说, 
			  它的网络地址保存在<filename>/etc/hosts</filename>中. </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>cat /etc/hosts</userinput>
<computeroutput>127.0.0.1               localhost.localdomain localhost</computeroutput>
</screen>
	    </para>

		<para>碰巧, 通过对<userinput>127.0.0.1</userinput>进行字节转换, 
			我们获得了<userinput>0.127.1.0</userinput>, 
			用16进制表示就是<userinput>007f0100</userinput>, 
			这就是上边<command>hostid</command>命令返回的结果. 
			这样几乎所有的无网络的Linux机器都会得到这个<emphasis>hostid</emphasis>. </para>
	    </note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sar</command></term>
	  <indexterm>
	    <primary>sar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>system activity report</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>sar</command>(System Activity Reporter系统活动报告)命令将会给出系统统计的一个非常详细的概要. 
	      Santa Cruz Operation(<quote>以前的</quote>SCO)公司在1999年4月份以开源软件的形式发布了<command>sar</command>. </para>

	  <para>这个命令并不是基本Linux发行版的一部分, 
		  但是你可以从<ulink
			  url="http://perso.wanadoo.fr/sebastien.godard/">sysstat 
			  utilities</ulink>所编写的<ulink
	      url="mailto:sebastien.godard@wanadoo.fr">Sebastien
	      Godard</ulink>包中获得这个工具. </para>

	    <screen>
<prompt>bash$ </prompt><userinput>sar</userinput>
<computeroutput>Linux 2.4.9 (brooks.seringas.fr) 	09/26/03

10:30:00          CPU     %user     %nice   %system   %iowait     %idle
10:40:00          all      2.21     10.90     65.48      0.00     21.41
10:50:00          all      3.36      0.00     72.36      0.00     24.28
11:00:00          all      1.12      0.00     80.77      0.00     18.11
Average:          all      2.23      3.63     72.87      0.00     21.27

14:32:30          LINUX RESTART

15:00:00          CPU     %user     %nice   %system   %iowait     %idle
15:10:00          all      8.59      2.40     17.47      0.00     71.54
15:20:00          all      4.07      1.00     11.95      0.00     82.98
15:30:00          all      0.79      2.94      7.56      0.00     88.71
Average:          all      6.33      1.70     14.71      0.00     77.26</computeroutput>
           </screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>readelf</command></term>
	  <indexterm>
	    <primary>elf</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>statistics</secondary>
	  </indexterm>
	  <listitem>
	    <para>这个命令会显示<emphasis>elf</emphasis>格式的二进制文件的统计信息. 这个工具是<emphasis>binutils</emphasis>工具包的一部分. </para>
	    <screen><prompt>bash$ </prompt><userinput>readelf -h /bin/bash</userinput>
<computeroutput>ELF Header:
   Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
   Class:                             ELF32
   Data:                              2's complement, little endian
   Version:                           1 (current)
   OS/ABI:                            UNIX - System V
   ABI Version:                       0
   Type:                              EXEC (Executable file)
   . . .</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>size</command></term>
	  <indexterm>
	    <primary>size</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>segment</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>size [/path/to/binary]</command>命令可以显示2进制可执行文件或归档文件每部分的尺寸. 
			  这个工具主要提供给程序员使用. 
	      </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>size /bin/bash</userinput>
<computeroutput>   text    data     bss     dec     hex filename
  495971   22496   17392  535859   82d33 /bin/bash</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist id="syslog">
        <title><anchor id="syslog1">系统日志类</title>

	<varlistentry>
	  <term><command>logger</command></term>
	  <indexterm>
	    <primary>logger</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logger</secondary>
	  </indexterm>
	  <listitem>

		  <para>附加一个用户产生的消息到系统日志中(<filename>/var/log/messages</filename>). 
			  即使不是root用户, 也可以调用<command>logger</command>. 
	      <programlisting>logger Experiencing instability in network connection at 23:10, 05/21.
# 现在, 运行'tail /var/log/messages'.</programlisting></para>

			<para>通过在脚本中调用<command>logger</command>命令, 
				就可以将调试信息写到<filename>/var/log/messages</filename>中. 
                 <programlisting>logger -t $0 -i Logging at line "$LINENO".
# "-t"选项可以为日志入口指定标签. 
# "-i"选项记录进程ID.

# tail /var/log/message
# ...
# Jul  7 20:48:58 localhost ./test.sh[1712]: Logging at line 3.</programlisting>
            </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>logrotate</command></term>
	  <indexterm>
	    <primary>logrotate</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logrotate</secondary>
	  </indexterm>
	  <listitem>

		  <para>这个工具用来管理系统的log文件, 
			  可以在合适的时候轮换, 压缩, 删除, 或(和)e-mail它们. 
			  这个工具将从旧的log文件中取得一些杂乱的记录, 
			  并保存到<filename class="directory">/var/log</filename>中. 
	      一般的, 每天都是通过<link linkend="cronref">cron</link>来运行<command>logrotate</command>. </para>

	  <para>在<filename>/etc/logrotate.conf</filename>中添加合适的入口就可以管理自己的log文件了, 
		  就像管理系统log文件一样. 
	       </para>

	     <note><para>Stefano Falsetto创造了<ulink
	     url="http://www.gnu.org/software/rottlog/">rottlog</ulink>,
	     他认为这是<command>logrotate</command>的改进版本. </para></note>

	  </listitem>
	</varlistentry>
	
      </variablelist>


      <variablelist id="jobcontrolsys">
        <title><anchor id="jobcontrolsys1">作业控制类</title>

	<varlistentry>
	  <term><anchor id="ppssref"><command>ps</command></term>
	  <indexterm>
	    <primary>ps</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ps</secondary>
	  </indexterm>
	  <listitem>

	    <para>进程统计(<replaceable>P</replaceable>rocess
			<replaceable>S</replaceable>tatistics): 
			通过进程宿主或PID(进程ID)来列出当前正在执行的进程. 
			通常都是使用<option>ax</option>或<option>aux</option>选项来调用这个命令, 
			并且结果可以通过管道传递到<link linkend="grepref">grep</link>或<link linkend="sedref">sed</link>中来搜索特定的进程(请参考<xref linkend="ex44">和<xref linkend="pidid">). </para>

	    <screen><prompt>bash$ </prompt><userinput> ps ax | grep sendmail</userinput>
<computeroutput>295 ?	   S	  0:00 sendmail: accepting connections on port 25</computeroutput></screen>

	    <para>如果想使用<quote>树</quote>的形式来显示系统进程: 
	      那么就使用<command>ps afjx</command>或<command>ps ax --forest</command>. </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>pgrep</command></term>
	  <term><command>pkill</command></term>
	  <indexterm>
	    <primary>pgrep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>process grep</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>pkill</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>process kill</secondary>
	  </indexterm>

	  <listitem>
	    <para><command>ps</command>命令可以与<link linkend="grepref">grep</link>或<link linkend="killref">kill</link>结合使用. </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>ps a | grep mingetty</userinput>
<computeroutput>2212 tty2     Ss+    0:00 /sbin/mingetty tty2
 2213 tty3     Ss+    0:00 /sbin/mingetty tty3
 2214 tty4     Ss+    0:00 /sbin/mingetty tty4
 2215 tty5     Ss+    0:00 /sbin/mingetty tty5
 2216 tty6     Ss+    0:00 /sbin/mingetty tty6
 4849 pts/2    S+     0:00 grep mingetty</computeroutput>


<prompt>bash$ </prompt><userinput>pgrep mingetty</userinput>
<computeroutput>2212 mingetty
 2213 mingetty
 2214 mingetty
 2215 mingetty
 2216 mingetty</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>pstree</command></term>
	  <indexterm>
	    <primary>pstree</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pstree</secondary>
	  </indexterm>
	  <listitem>
		  <para>使用<quote>树</quote>形式列出当前执行的进程. 
			  <option>-p</option>选项显示PID, 也就是进程名字. 
		  </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>top</command></term>
	  <indexterm>
	    <primary>top</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>processes</secondary>
	  </indexterm>
	  <listitem>

		  <para>连续不断的显示cpu占有率最高的进程. 
			  <option>-b</option>选项将会以文本方式来显示, 
			  以便于可以在脚本中进行分析或访问. 
		  </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>top -b</userinput>
<computeroutput>  8:30pm  up 3 min,  3 users,  load average: 0.49, 0.32, 0.13
 45 processes: 44 sleeping, 1 running, 0 zombie, 0 stopped
 CPU states: 13.6% user,  7.3% system,  0.0% nice, 78.9% idle
 Mem:    78396K av,   65468K used,   12928K free,       0K shrd,    2352K buff
 Swap:  157208K av,       0K used,  157208K free                   37244K cached

   PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
   848 bozo      17   0   996  996   800 R     5.6  1.2   0:00 top
     1 root       8   0   512  512   444 S     0.0  0.6   0:04 init
     2 root       9   0     0    0     0 SW    0.0  0.0   0:00 keventd
   ...</computeroutput>  
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>nice</command></term>
	  <indexterm>
	    <primary>nice</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>nice</secondary>
	  </indexterm>
	  <listitem>
		  <para>使用经过修改的优先级来运行一个后台作业. 
			  优先级从19(最低)到-20(最高)
			  只有<emphasis>root</emphasis>用户可以设置负的(相对比较高的)优先级. 
			  相关的命令还有<command>renice</command>, 
			  <command>snice</command>, 
	      和<command>skill</command>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>nohup</command></term>
	  <indexterm>
	    <primary>nohup</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>nohup</secondary>
	  </indexterm>
	  <listitem>
	    <para>保持一个命令进程处于运行状态, 即使这个命令进程所属的用户登出系统. 
		  这个命令进程将会运行在前台, 除非在它前面加上<token>&</token>. 
		  如果你在脚本中使用<command>nohup</command>命令, 
		  那么你最好同时使用<link linkend="waitref">wait</link>命令, 
		  这样就可以避免产生孤儿进程或僵尸进程. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="pidofref"><command>pidof</command></term>
	  <indexterm>
	    <primary>pidof</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>process ID</secondary>
	  </indexterm>
	  <listitem>
		  <para>获取一个正在运行作业的<emphasis>进程ID(PID)</emphasis>. 
			  因为一些作业控制命令, 比如<link
	    linkend="killref">kill</link>和<command>renice</command>只能使用进程的<emphasis>PID</emphasis>(而不是它的名字)作为参数, 
	    所以有的时候必须得取得<emphasis>PID</emphasis>. 
	    <command>pidof</command>命令与<link
	    linkend="ppidref">$PPID</link>内部变量非常相似. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>pidof xclock</userinput>
<computeroutput>880</computeroutput>
	      </screen>
	    </para>

            <example id="killprocess">
              <title>使用<command>pidof</command>命令帮忙kill一个进程</title>
              <programlisting>&killprocess;</programlisting>
            </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fuser</command></term>
	  <indexterm>
	    <primary>fuser</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fuser</secondary>
	  </indexterm>
	  <listitem>
	    <para>或取一个正在访问某个或某些文件(或目录)的进程ID. 
			使用<option>-k</option>选项将会kill这些进程. 
			对于系统安全来说, 
	      尤其是在脚本中想阻止未被授权的用户访问系统服务的时候, 
	      这个命令就显得非常有用了. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>fuser -u /usr/bin/vim</userinput>
<computeroutput>/usr/bin/vim:         3207e(bozo)</computeroutput>



<prompt>bash$ </prompt><userinput>fuser -u /dev/null</userinput>
<computeroutput>/dev/null:            3009(bozo)  3010(bozo)  3197(bozo)  3199(bozo)</computeroutput>
	      </screen>
	    </para>

           <para>在进行正常插入或删除保存的媒体(比如CD ROM或者USB闪存设备)的时候, <command>fuser</command>命令非常的有用. 
			   某些情况下, 也就是当你<link linkend="umountref">umount</link>一个设备失败的时候, 
			   会出现<errorname>设备忙</errorname>错误消息. 
		这意味着某些用户或进程正在访问这个设备.	
		可以使用<command>fuser -um /dev/device_name</command>来解决这种问题, 
		这样你就可以kill所有相关的进程. 
	     </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>umount /mnt/usbdrive</userinput>
<computeroutput>umount: /mnt/usbdrive: device is busy</computeroutput>



<prompt>bash$ </prompt><userinput>fuser -um /dev/usbdrive</userinput>
<computeroutput>/mnt/usbdrive:        1772c(bozo)</computeroutput>

<prompt>bash$ </prompt><userinput>kill -9 1772</userinput>
<prompt>bash$ </prompt><userinput>umount /mnt/usbdrive</userinput>
	      </screen>
	    </para>

		<para><command>fuser</command>命令的<option>-n</option>选项可以获得正在访问某一<emphasis>端口</emphasis>的进程. 
	      当和<link linkend="nmapref">nmap</link>命令结合使用的时候尤其有用. </para>

	  <para>
	      <screen><prompt>root# </prompt><userinput>nmap localhost.localdomain</userinput>
<computeroutput>PORT     STATE SERVICE
 25/tcp   open  smtp</computeroutput>



<prompt>root# </prompt><userinput>fuser -un tcp 25</userinput>
<computeroutput>25/tcp:               2095(root)</computeroutput>

<prompt>root# </prompt><userinput>ps ax | grep 2095 | grep -v grep</userinput>
<computeroutput>2095 ?        Ss     0:00 sendmail: accepting connections</computeroutput>
	      </screen>
            </para>


	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="cronref"><command>cron</command></term>
	  <indexterm>
	    <primary>cron</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>crond</secondary>
	  </indexterm>
	  <listitem>

		  <para>管理程序调度器, 用来执行一些日常任务, 
			  比如清除和删除系统log文件, 或者更新<database>slocate</database>数据库. 
			  这是<link linkend="atref">at</link>命令的超级用户版本(虽然每个用户都可以有自己的<filename>crontab</filename>文件, 
			  并且这个文件可以使用<command>crontab</command>命令来修改). 
	      它以<link linkend="daemonref">幽灵进程</link>的身份来运行, 
		  并且从<filename>/etc/crontab</filename>中获得执行的调度入口. 
			</para>

			<note><para>一般Linux风格的系统都使用<command>crond</command>, 
					用的是Matthew Dillon版本的<command>cron</command>. </para></note>

	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist id="runcontrolsys">
        <title><anchor id="runcontrolsys1">启动与进程控制类</title>

	<varlistentry>
	  <term><command>init</command></term>
	  <indexterm>
	    <primary>init</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>init</secondary>
	  </indexterm>
	  <listitem>
	    <para><anchor id="inittabref"></para>
	    <para><command>init</command>命令是所有进程的<link
				linkend="forkref">父进程</link>. 
			在系统启动的最后一步调用, 
			<command>init</command>将会依据<filename>/etc/inittab</filename>来决定系统的运行级别. 
			只能使用root身份来运行它的别名 - <command>telinit</command>. 
		</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>telinit</command></term>
	  <indexterm>
	    <primary>telinit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>telinit</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>init</command>命令的符号链接, 
			  这是一种修改系统运行级别的手段, 
	      通常在系统维护的时候, 或者在紧急的文件系统修复的时候才能用. 
		  只能使用root身份调用. 
		  调用这个命令是非常危险的 -
	      在你使用之前确定你已经很好地了解它! </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>runlevel</command></term>
	  <indexterm>
	    <primary>runlevel</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>runlevel</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示当前的和最后的运行级别, 也就是, 
			  判断系统是处于终止状态(runlevel为<literal>0</literal>), 
			  单用户模式(<literal>1</literal>), 多用户模式(<literal>2</literal>或<literal>3</literal>), 
	      X Windows(<literal>5</literal>), 
		  还是正处于重起状态(<literal>6</literal>). 
		  这个命令将会访问<filename>/var/run/utmp</filename>文件. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>halt</command></term>
	  <term><command>shutdown</command></term>
	  <term><command>reboot</command></term>
	  <indexterm>
	    <primary>halt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>halt</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>shutdown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shutdown</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>reboot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>reboot</secondary>
	  </indexterm>
	  <listitem>
	    <para>设置系统关机的命令, 通常比电源关机的优先级高. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>service</command></term>
	  <indexterm>
	    <primary>service</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>service</secondary>
	  </indexterm>
	  <listitem>
	    <para>开启或停止一个系统<firstterm>服务</firstterm>. 
	    在<filename class="directory">/etc/init.d</filename>
	    和<filename class="directory">/etc/rc.d</filename>中的启动脚本使用这个命令来启动服务. 
	  </para>
	  <para>
	      <screen><prompt>root# </prompt><userinput>/sbin/service iptables stop</userinput>
<computeroutput>Flushing firewall rules:                                   [  OK  ]
 Setting chains to policy ACCEPT: filter                    [  OK  ]
 Unloading iptables modules:                                [  OK  ]</computeroutput>
	      </screen>
	    </para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="networksys">
        <title><anchor id="networksys1">网络类</title>

	<varlistentry>
	  <term><command>ifconfig</command></term>
	  <indexterm>
	    <primary>ifconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ifconfig</secondary>
	  </indexterm>
	  <listitem>
	    <para>网络的<emphasis>接口配置</emphasis>和调试工具. </para>

	      <screen><prompt>bash$ </prompt><userinput>ifconfig -a</userinput>
<computeroutput>lo        Link encap:Local Loopback
           inet addr:127.0.0.1  Mask:255.0.0.0
           UP LOOPBACK RUNNING  MTU:16436  Metric:1
           RX packets:10 errors:0 dropped:0 overruns:0 frame:0
           TX packets:10 errors:0 dropped:0 overruns:0 carrier:0
           collisions:0 txqueuelen:0 
           RX bytes:700 (700.0 b)  TX bytes:700 (700.0 b)</computeroutput></screen>

   <para><command>ifconfig</command>命令绝大多数情况都是在启动的时候设置接口, 
	   或者在重启的时候关闭它们. 
	      </para>

	    <para><programlisting># 来自于/etc/rc.d/init.d/network中的代码片断

# ...

# 检查网络是否启动. 
[ ${NETWORKING} = "no" ] && exit 0

[ -x /sbin/ifconfig ] || exit 0

# ...

for i in $interfaces ; do
  if ifconfig $i 2>/dev/null | grep -q "UP" >/dev/null 2>&1 ; then
    action "Shutting down interface $i: " ./ifdown $i boot
  fi
# grep命令的GNU指定选项"-q"的意思是"安静", 也就是, 不产生输出. 
# 这样, 后边重定向到/dev/null的操作就有点多余了.
       
# ...

echo "Currently active devices:"
echo `/sbin/ifconfig | grep ^[a-z] | awk '{print $1}'`
#                            ^^^^^  应该被引用以防止通配(globbing). 
#  下边这段也能工作. 
#    echo $(/sbin/ifconfig | awk '/^[a-z]/ { print $1 })'
#    echo $(/sbin/ifconfig | sed -e 's/ .*//')
#  感谢, S.C., 做了额外的注释. </programlisting></para>

	    <para>请参考<xref linkend="online">. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>iwconfig</command></term>
	  <indexterm>
	    <primary>iwconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wireless</secondary>
	  </indexterm>
	  <listitem>
		  <para>这是为了配置无线网络的命令集合. 
			  可以说是上边的<command>ifconfig</command>的无线版本. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="routeref"><command>route</command></term>
	  <indexterm>
	    <primary>route</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>route</secondary>
	  </indexterm>
	  <listitem>

	    <para>显示内核路由表信息, 或者查看内核路由表的修改情况. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>route</userinput>
<computeroutput>Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
 pm3-67.bozosisp *               255.255.255.255 UH       40 0          0 ppp0
 127.0.0.0       *               255.0.0.0       U        40 0          0 lo
 default         pm3-67.bozosisp 0.0.0.0         UG       40 0          0 ppp0</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chkconfig</command></term>
	  <indexterm>
	    <primary>chkconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>network configuration</secondary>
	  </indexterm>
	  <listitem>

		  <para>检查网络配置. 
			  这个命令负责显示和管理在启动过程中所开启的网络服务
	      (这些服务都是从<filename class="directory">/etc/rc?.d</filename>目录中开启的). 
	      </para>

	    <para>最开始是从IRIX到Red Hat Linux的一个接口, 
	      <command>chkconfig</command>在某些Linux发行版中并不是核心安装的一部分. </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>chkconfig --list</userinput>
<computeroutput>atd             0:off   1:off   2:off   3:on    4:on    5:on    6:off
 rwhod           0:off   1:off   2:off   3:off   4:off   5:off   6:off
 ...</computeroutput>
	      </screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tcpdump</command></term>
	  <indexterm>
	    <primary>tcpdump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tcp</secondary>
	  </indexterm>
	  <listitem>
		  <para>网络包的<quote>嗅探器</quote>. 
			  这是一个用来分析和调试网络上传输情况的工具, 
			  它所使用的手段是把所有匹配指定规则的包头都显示出来. 
	      </para>

	      <para>显示主机<emphasis>bozoville</emphasis>和主机<emphasis>caduceus</emphasis>之间所有传输的ip包. 
	      <screen><prompt>bash$ </prompt><userinput>tcpdump ip host bozoville and caduceus</userinput>
	      </screen>
	      </para>

	      <para>当然, <command>tcpdump</command>的输出是可以进行分析的, 
	        可以用我们之前讨论的<link
		linkend="tpcommandlisting1">文本处理工具</link>来分析结果. </para>
	  </listitem>
	</varlistentry>

      </variablelist>



      <variablelist id="filesystemsys">
        <title><anchor id="filesystemsys1">文件系统类</title>

	<varlistentry>
	  <term><anchor id="mountref"><command>mount</command></term>
	  <indexterm>
	    <primary>mount</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mount</secondary>
	  </indexterm>
	  <listitem>
	    <para>加载一个文件系统, 通常都用来安装外部设备, 比如软盘或CDROM. 
			文件<filename>/etc/fstab</filename>将会提供一个方便的列表, 
			这个列表列出了所有可用的文件系统, 分区和设备, 
			另外还包括某些选项, 比如是否可以自动或者手动的mount. 
			文件<filename>/etc/mtab</filename>显示了当前已经mount的文件系统和分区(包括虚拟的, 
			比如<filename class="directory">/proc</filename>). </para>

	    <para><command>mount -a</command>将会mount所有出现在<filename>/etc/fstab</filename>中的文件系统和分区, 
	      除了那些标记有<option>noauto</option>(非自动)选项的. 
		  启动的时候, 
		  在<filename class="directory">/etc/rc.d</filename>中的一个启动脚本(<filename>rc.sysinit</filename>或者一些相似的脚本)将会调用<command>mount -a</command>, 
	      目的是mount所有可用的文件系统和分区. </para>


	    <para><programlisting>mount -t iso9660 /dev/cdrom /mnt/cdrom
# 加载CDROM
mount /mnt/cdrom
# 如果/mnt/cdrom包含在/etc/fstab中的话, 那么这么调用就是一种简便的方法. </programlisting>
     </para>

     <para>这个多功能的命令甚至可以将一个普通文件mount到块设备中, 
       这样一来, 就可以象做操作文件系统一样来操作这个文件. 
	   先将这个文件与一个<link linkend="loopbackref">loopback
       device</link>设备相关联, 然后<command>Mount</command>就能达到这个目的了. 
       这种应用一般都是用来mount或检查一个ISO9660镜像, 经过检查后这个镜像会被烧录到CDR上. 
       
	  <footnote><para>关于烧录CDR的更多细节, 可以参考Alex
	    Withers的文章, <ulink
	    url="http://www2.linuxjournal.com/lj-issues/issue66/3335.html">创建
	    CD</ulink>, 这篇文章是1999年10月在<ulink
	    url="http://www.linuxjournal.com"><citetitle
	    pubwork="journal">Linux
	     Journal</citetitle></ulink>上发表的. </para></footnote>

       </para>

	     <example id="isomountref">
	      <title>检查一个CD镜像</title>
	       <programlisting># 以root身份...

mkdir /mnt/cdtest  # 准备一个mount入口, 如果你没准备的话. 

mount -r -t iso9660 -o loop cd-image.iso /mnt/cdtest   # mount这个镜像.
#                  "-o loop" option equivalent to "losetup /dev/loop0"
cd /mnt/cdtest     # 现在检查这个镜像. 
ls -alR            # 列出目录树中的文件. 
                   # 诸如此类. </programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="umountref"><command>umount</command></term>
	  <indexterm>
	    <primary>umount</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>umount</secondary>
	  </indexterm>
	  <listitem>
		  <para>卸除一个当前已经mount的文件系统. 
			  在删除已经mount上的软盘或CDROM之前, 这个设备必须被<command>umount</command>, 
			  否则文件系统将会被损坏. 
	      <programlisting>umount /mnt/cdrom
# 现在你可以按下弹出键(指的是cdrom或软盘驱动器上的弹出按键), 并安全的弹出光盘. </programlisting></para>

		  <note><para><command>automount</command>工具, 
				  如果对这个工具进行了适当的安装, 
				  那么当需要访问或退出磁盘(或软盘)的时候, 
				  就能够自动的mount和unmount它们了. 
				  但是如果在带有软躯或光驱的笔记本电脑上使用的话, 
				  可能会引起问题. 
		</para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sync</command></term>
	  <indexterm>
	    <primary>sync</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sync</secondary>
	  </indexterm>
	  <listitem>
	    <para>当你需要更新硬盘buffer中的数据时, 这个命令可以强制将你buffer上的数据立即写入到硬盘上(同步带有buffer的驱动器). 
	      在某些情况下, 
		  一个<command>sync</command>命令可能会挽救你刚刚更新的数据, 比如说突然断电, 
		 所以这个命令可以给系统管理员和普通用户一些保障. 
	      以前, 系统重启前都使用<userinput>sync;
		  sync</userinput> (两次, 为了保证绝对可靠), 
		  这是一种谨慎小心的可靠方法. 
	      </para>
	    <para>某些时候, 比如说当你想安全删除文件的时候(请参考<xref
				linkend="blotout">), 或者当磁盘灯开始闪烁的时候, 
				你可能需要强制对buffer进行立即刷新. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="losetupref"><command>losetup</command></term>
	  <indexterm>
	    <primary>losetup</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>losetup</secondary>
	  </indexterm>
	  <listitem>
	    <para>建立和配置<link linkend="loopbackref">loopback设备</link>. </para>

	    <example id="createfs">
	      <title>在一个文件中创建文件系统</title>
	      <programlisting>SIZE=1000000  # 1 meg

head -c $SIZE < /dev/zero > file  # 建立指定尺寸的文件. 
losetup /dev/loop0 file           # 作为loopback设备来创建. 
mke2fs /dev/loop0                 # 创建文件系统. 
mount -o loop /dev/loop0 /mnt     # mount.

# 感谢, S.C.</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>mkswap</command></term>
	  <indexterm>
	    <primary>mkswap</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mkswap</secondary>
	  </indexterm>
	  <listitem>
		  <para>创建一个交换分区或文件. 
			  交换区域随后必须马上使用<command>swapon</command>来启用. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>swapon</command></term>
	  <term><command>swapoff</command></term>
	  <indexterm>
	    <primary>swapon</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>swapon</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>swapoff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>swapoff</secondary>
	  </indexterm>
	  <listitem>
		  <para>启用/禁用交换分区或文件. 
			  这两个命令通常在启动和关机的时候才有效. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="mke2fsref"><command>mke2fs</command></term>
	  <indexterm>
	    <primary>mke2fs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mke2fs</secondary>
	  </indexterm>
	  <listitem>
	    <para>创建Linux ext2文件系统. 这个命令必须以root身份调用. 
	      </para>
	      

	    <example id="adddrv">
	      <title>添加一个新的硬盘驱动器</title>
	      <programlisting>&adddrv;</programlisting>
	    </example>

	    <para>请参考<xref linkend="createfs">和<xref
	      linkend="ramdisk">.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tune2fs</command></term>
	  <indexterm>
	    <primary>tune2fs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tune2fs</secondary>
	  </indexterm>
	  <listitem>
		  <para>调整ext2文件系统. 可以用来修改文件系统参数, 
			  比如mount的最大数量. 必须以root身份调用. 
	      </para>

	    <warning><para>这是一个非常危险的命令. 一旦用错, 你需要自己负责, 因为它可能会破坏你的文件系统. </para></warning>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>dumpe2fs</command></term>
	  <indexterm>
	    <primary>dumpe2fs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dumpe2fs</secondary>
	  </indexterm>
	  <listitem>
		  <para>打印(输出到<filename>stdout</filename>)非常详细的文件系统信息. 
			  必须以root身份调用. 
	      </para>

	    <screen><prompt>root# </prompt><command>dumpe2fs /dev/hda7 | grep 'ount count'</command>
<computeroutput>dumpe2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09
 Mount count:              6
 Maximum mount count:      20</computeroutput></screen>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>hdparm</command></term>
	  <indexterm>
	    <primary>hdparm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hard disk parameters</secondary>
	  </indexterm>
	  <listitem>
		  <para>显示或修改硬盘参数. 这个命令必须以root身份调用, 
			  如果滥用的话会有危险.
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="fdiskref"><command>fdisk</command></term>
	  <indexterm>
	    <primary>fdisk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fdisk</secondary>
	  </indexterm>
	  <listitem>
	    <para>在存储设备上(通常都是硬盘)创建和修改一个分区表. 必须以root身份使用. 
	      </para>
	    <warning><para>谨慎使用这个命令. 如果出错, 会破坏你现存的文件系统. 
	      </para></warning>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="fsckref"><command>fsck</command></term>
	  <term><command>e2fsck</command></term>
	  <term><command>debugfs</command></term>
	  <indexterm>
	    <primary>fsck</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fsck</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>e2fsck</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>e2fsck</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>debugfs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>debugfs</secondary>
	  </indexterm>
	  <listitem>

	    <para>文件系统的检查, 修复, 和除错命令集合. </para>

		<para><command>fsck</command>: 
			检查UNIX文件系统的前端工具(也可以调用其它的工具). 
			文件系统的类型一般都是默认的ext2. 
	      </para>

	    <para><command>e2fsck</command>: ext2文件系统检查器. </para>

		<para><command>debugfs</command>: ext2文件系统除错器. 
			这个功能多 - 并且危险的工具, 主要用处之一就是(尝试)恢复删除的文件. 
			只有高级用户才能用! 
	      </para>

		  <caution><para>上边的这几个命令都必须以root身份调用, 
				  这些命令都很危险, 如果滥用的话会破坏文件系统. 
	      </para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>badblocks</command></term>
	  <indexterm>
	    <primary>badblocks</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>badblocks</secondary>
	  </indexterm>
	  <listitem>
		  <para>检查存储设备的坏块(物理损坏). 
			  这个命令在格式化新安装的硬盘时候, 或者在测试"备份媒体"完整性的时候会被用到. 
	        <footnote><para><link
		linkend="mke2fsref">mke2fs</link>的<option>-c</option>选项也会进行磁盘坏块检查. 
		</para></footnote>
	      举个例子, <command>badblocks /dev/fd0</command>用来测试软盘. </para>

	    <para>如果<command>badblocks</command>使用不慎的话, 可能会引起比较糟糕的结果(覆盖所有数据), 但是在只读模式下就不会发生这种情况. 
	      如果root用户要测试某个设备(这是通常情况), 
	      那么root用户必须使用这个命令. 
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lsusb</command></term>
	  <term><command>usbmodules</command></term>
	  <indexterm>
	    <primary>lsusb</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>usb</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>usbmodules</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>usb</secondary>
	  </indexterm>
	  <listitem>

		  <para><command>lsusb</command>命令会显示所有USB(Universal 
			  Serial Bus通用串行总线)总线和使用USB的设备. 
	      </para>

            <para><command>usbmodules</command>命令会输出连接USB设备的驱动模块的信息. 
	      </para>

            <para>
	      <screen><prompt>root# </prompt><userinput>lsusb</userinput>
<computeroutput>Bus 001 Device 001: ID 0000:0000  
 Device Descriptor:
   bLength                18
   bDescriptorType         1
   bcdUSB               1.00
   bDeviceClass            9 Hub
   bDeviceSubClass         0 
   bDeviceProtocol         0 
   bMaxPacketSize0         8
   idVendor           0x0000 
   idProduct          0x0000

   . . .</computeroutput>
	      </screen>
            </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lspci</command></term>
	  <indexterm>
	    <primary>lspci</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pci</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示<firstterm>pci</firstterm>总线及其设备. </para>

            <para>
	      <screen><prompt>bash$ </prompt><userinput>lspci</userinput>
<computeroutput>00:00.0 Host bridge: Intel Corporation 82845 845 (Brookdale) Chipset Host Bridge (rev 04)
 00:01.0 PCI bridge: Intel Corporation 82845 845 (Brookdale) Chipset AGP Bridge (rev 04)
 00:1d.0 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #1) (rev 02)
 00:1d.1 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #2) (rev 02)
 00:1d.2 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #3) (rev 02)
 00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev 42)

   . . .</computeroutput>
	      </screen>
            </para>

	  </listitem>
	</varlistentry>



	<varlistentry>
	  <term><command>mkbootdisk</command></term>
	  <indexterm>
	    <primary>mkbootdisk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>bootdisk</secondary>
	  </indexterm>
	  <listitem>
		  <para>创建启动软盘, 启动盘可以唤醒系统, 
			  比如当MBR(master boot record主启动记录)坏掉的时候. 
			  <command>mkbootdisk</command>命令其实是一个Bash脚本, 
			  由Erik Troan所编写, 放在<filename
	      class="directory">/sbin</filename>目录中. </para> 
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chroot</command></term>
	  <indexterm>
	    <primary>chroot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chroot</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>root</secondary>
	    <tertiary>change</tertiary>
	  </indexterm>
	  <listitem>
		  <para>修改ROOT目录. 一般的命令都是从<link linkend="pathref">$PATH</link>中获得的, 
			  相对的, 默认根目录是 /.
	      这个命令将会把根目录修改为另一个目录(并且也将把工作目录修改到那). 
		  这个命令对于安全目的非常有用, 
		  举个例子, 某些情况下, 系统管理员希望限制一些特定的用户, 
		  比如那些<link linkend="telnetref">telnet</link>上来的用户, 
		  将他们限定到文件系统上一个安全的地方(有时候, 
		  这被称为将一个guest用户限制在<quote>chroot监牢</quote>中). 
		  注意, 在使用<command>chroot</command>命令后, 
		  系统的二进制可执行文件的目录就不再可用了. 
	      </para>

	      <para><userinput>chroot /opt</userinput>将会使得原来的<filename
		class="directory">/usr/bin</filename>变为<filename
		class="directory">/opt/usr/bin</filename>. 
		同样, <userinput>chroot /aaa/bbb /bin/ls</userinput>将会使得<command>ls</command>命令以<filename>/aaa/bbb</filename>作为根目录, 
		而不是之前的<filename class="directory">/</filename>. 
		如果使用<command>alias XX 'chroot /aaa/bbb ls'</command>, 
		并把这句放到用户的<filename>~/.bashrc</filename>文件中的话, 
		这样可以有效地限制运行命令<quote>XX</quote>时, 
		命令<quote>XX</quote>可以使用文件系统的范围. </para>


	<para>当从启动盘恢复的时候(<command>chroot</command>到<filename>/dev/fd0</filename>), 
		或者当系统从死机状态恢复过来并作为<command>lilo</command>选项的时候, 
		<command>chroot</command>命令都是非常方便的. 
		其它的应用还包括从不同的文件系统进行安装(一个<link 
			linkend="rpmref">rpm</link>选项)或者从CDROM上运行一个只读文件系统. 
		只能以root身份调用, 小心使用. 
	      </para>

		  <caution><para>由于正常的<varname>$PATH</varname>不再被关联, 
				  所以可能需要将一些特定的系统文件拷贝到<emphasis>chroot</emphasis>之后的目录中, 
	      </para></caution>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lockfile</command></term>
	  <indexterm>
	    <primary>lockfile</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lockfile</secondary>
	  </indexterm>
	  <listitem>
		  <para>这个工具是<command>procmail</command>包的一部分(<ulink 
				  url="http://www.procmail.org">www.procmail.org</ulink>). 
			  它可以创建一个<emphasis>锁定文件</emphasis>, 
			  <emphasis>锁定文件</emphasis>是一种用来控制访问文件, 设备或资源的标记文件. 
			  锁定文件就像一个标记一样被使用, 如果特定的文件, 设备, 
			  或资源正在被一个特定的进程所使用(<quote>busy</quote>), 
			  那么对于其它进程来说, 就只能进行受限访问(或者不能访问). 
	      </para>

            <para><programlisting>lockfile /home/bozo/lockfiles/$0.lock
# 创建一个以脚本名字为前缀的写保护锁定文件. </programlisting></para>
	      
		<para>锁定文件用在一些特定的场合, 
			比如说保护系统的mail目录以防止多个用户同时修改, 
			或者提示一个modem端口正在被访问, 
			或者显示<application>Netscape</application>的一个实例正在使用它的缓存. 
			脚本可以做一些检查工作, 
			比如说一个特定的进程可以创建一个锁定文件, 
			那么只要检查这个特定的进程是否在运行, 
			就可以判断出锁定文件是否存在了. 
			注意如果脚本尝试创建一个已经存在的锁定文件的话, 
			那么脚本很可能被挂起. 
	      </para>

		  <para>一般情况下, 应用对于锁定文件的创建和检查都放在<filename 
				  class="directory">/var/lock</filename>目录中. 
			  <footnote><para>因为只有<firstterm>root</firstterm>用户才具有对<filename class="directory">/var/lock</filename>目录的写权限, 
				一般的用户脚本不能在那里设置一个锁定文件. 
		 </para></footnote>
	      脚本可以使用下面的方法来检测锁定文件是否存在.
	        <programlisting>appname=xyzip
# 应用"xyzip"创建锁定文件"/var/lock/xyzip.lock". 

if [ -e "/var/lock/$appname.lock" ]
then
  ...</programlisting></para>

	  </listitem>
	</varlistentry>

	<varlistentry>
		<term><command>flock</command></term>
	  <indexterm>
	    <primary>flock</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lock file</secondary>
	  </indexterm>
	  <listitem>

	    <para><command>flock</command>命令不像<command>lockfile</command>那么有用. 
			它在一个文件上设置一个<quote>咨询性</quote>的锁, 
			(译者注: <quote>咨询性</quote>的锁有时也称为<quote>建议性</quote>的锁, 
			这种锁只对协同进程起作用, 还有一种锁叫<quote>强制性</quote>锁, 
			这种锁加锁的对象读写操作都会由内核做检查, 
			更多的细节请参考flock(1), flock(2), 
			/usr/src/linux/Documentation/locks.txt和mandatory.txt), 
			然后在锁持续的期间可以执行一个命令. 
	      这样可以避免这个命令完成前有另外的进程试图在这个文件上设置锁. </para>

	    <para><programlisting>flock $0 cat $0 > lockfile__$0
#  上面这行表示脚本正处于列出自身内容到标准输出的过程中, 
#+ 设置一把锁锁住脚本文件自身. </programlisting></para>

            <note><para>与<command>lockfile</command>不同, 
	      <command>flock</command><emphasis>不会</emphasis>自动创建一个锁定文件. </para></note>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mknod</command></term>
	  <indexterm>
	    <primary>mknod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mknod</secondary>
	  </indexterm>
	  <listitem>
	    <para>创建块或者字符设备文件(当在系统上安装新硬盘时, 必须这么做). 
	      <command>MAKEDEV</command>工具事实上具有<command>mknod</command>的全部功能, 
	      而且更容易使用. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>MAKEDEV</command></term>
	  <indexterm>
	    <primary>MAKEDEV</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>make device file</secondary>
	  </indexterm>
	  <listitem>
		  <para>创建设备文件的工具. 
			  必须在<filename class="directory">/dev</filename>目录下, 
	      并且以root身份使用. 

	    <screen><prompt>root# </prompt><command>./MAKEDEV</command></screen>

	      这是<command>mknod</command>的高级版本. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tmpwatch</command></term>
	  <indexterm>
	    <primary>tmpwatch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tmpwatch</secondary>
	  </indexterm>
	  <listitem>
		  <para>自动删除在指定时间内未被访问过的文件. 
			  通常都是被<link linkend="cronref">cron</link>调用, 
			  用来删掉旧的log文件. </para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="periphsys">
        <title><anchor id="periphsys1">备份类</title>

	<varlistentry>
	  <term><command>dump</command></term>
	  <term><command>restore</command></term>
	  <indexterm>
	    <primary>dump</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dump</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>restore</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>restore</secondary>
	  </indexterm>
	  <listitem>
		  <para><command>dump</command>命令是一个精巧的文件系统备份工具, 
			  通常都用在比较大的安装版本和网络上. 
			  <footnote><para>单用户Linux系统的操作更倾向于使用简单的备份工具, 
				比如<command>tar</command>. </para></footnote>
		它读取原始的磁盘分区并且以二进制形式来写备份文件. 
		需要备份的文件可以保存到各种各样的存储设备上, 包括磁盘和磁带. 
	      <command>restore</command>命令用来恢复
	      <command>dump</command>所产生的备份. </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fdformat</command></term>
	  <indexterm>
	    <primary>fdformat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>floppy</secondary>
	  </indexterm>
	  <listitem>
	    <para>对软盘进行低级格式化. </para>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="sysresources">
        <title><anchor id="sysresources1">系统资源类</title>

	<varlistentry>
	  <term><command>ulimit</command></term>
	  <indexterm>
	    <primary>ulimit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ulimit</secondary>
	  </indexterm>
	  <listitem>

	    <para>设置系统资源的使用<emphasis>上限</emphasis>. 
			通常情况下都是使用<option>-f</option>选项来调用, 
			<option>-f</option>用来设置文件尺寸的限制(<command>ulimit 
				-f 1000</command>就是将文件大小限制为1M). 
			<option>-c</option>(译者注: 这里应该是作者笔误, 
			作者写的是<option>-t</option>)选项来限制coredump尺寸(<command>ulimit
			 -c 0</command>就是不要coredump). 
		 一般情况下, 
		 <command>ulimit</command>的值应该设置在<filename>/etc/profile</filename>和(或)<filename>~/.bash_profile</filename>中(请参考<xref
	      linkend="files">). </para>

            <important>

	    <para>合理的使用<command>ulimit</command>命令可以保护系统免受可怕的<emphasis>fork炸弹</emphasis>的迫害. </para>

	    <para>
	    <programlisting>#!/bin/bash
# 这个脚本只是为了展示用. 
# 你要自己为运行这个脚本的后果负责 -- 它*将*凝固你的系统. 

while true  #  死循环. 
do
  $0 &      #  这个脚本调用自身 . . .
            #+ fork无限次 . . .
            #+ 直到系统完全不动, 因为所有的资源都耗尽了. 
done        #  这就像令人郁闷的<quote>魔术师不断变出雨伞</quote>的场景. 

exit 0      #  这里不会真正的退出, 因为这个脚本不会终止. </programlisting>
	    </para>

		<para>当这个脚本超过预先设置的限制时, 
			在<filename>/etc/profile</filename>中的<command>ulimit -Hu 
			XX</command>(<emphasis>XX</emphasis>就是需要限制的用户进程)可以终止这个脚本的运行. 
	    </para>

            </important>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="quotaref"><command>quota</command></term>
	  <indexterm>
	    <primary>quota</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>quota</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示用户或组的磁盘配额. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="setquotaref"><command>setquota</command></term>
	  <indexterm>
	    <primary>setquota</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>quota</secondary>
	  </indexterm>
	  <listitem>
	    <para>从命令行中设置用户或组的磁盘配额. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <indexterm>
	    <primary>umask</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>umask</secondary>
	  </indexterm>
	  <term><anchor id="umaskref"><command>umask</command></term>
	  <listitem>
	    <para>设定用户创建文件时缺省的权限<firstterm>mask</firstterm>(掩码). 
	      也可以用来限制特定用户的默认文件属性. 
		  所有用户创建的文件属性都是由<command>umask</command>所指定的. 
		  传递给umask命令的值(8进制)定义了文件的<firstterm>屏蔽</firstterm>权限. 
	      比如, <command>umask
			  022</command>将会使得新文件的权限最多为755(777与022进行<quote>与非</quote>操作). 

		  <footnote><para>NAND<quote><firstterm>与非</firstterm></quote>是一种逻辑操作. 
		  事实上, 这种操作与减法很相像. </para></footnote>

	     当然, 用户随后可以使用<link
			 linkend="chmodref">chmod</link>来修改指定文件的属性. 
	     用户一般都将设置<command>umask</command>值得地方放在<filename>/etc/profile</filename>或(和)<filename>~/.bash_profile</filename>中(请参考<xref
	      linkend="files">). </para>

	    <example id="rot13a">
	      <title>用<command>umask</command>将输出文件隐藏起来</title>
	      <programlisting>&rot13a;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rdev</command></term>
	  <indexterm>
	    <primary>rdev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rdev</secondary>
	  </indexterm>
	  <listitem>
		  <para>取得root device, swap space, 或video mode的相关信息, 或者对它们进行修改. 
			  一般情况下, <command>rdev</command>的功能都是被<command>lilo</command>所使用, 
			  但是在建立一个ram disk的时候, 这个命令也很有用. 
			  小心使用, 这是一个危险的命令. 
	     </para>
	   </listitem>
	 </varlistentry>
	 
      </variablelist>


      <variablelist id="modulessys">
        <title><anchor id="modulessys1">模块类</title>

	<varlistentry>
	  <term><command>lsmod</command></term>
	  <indexterm>
	    <primary>lsmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示所有安装的内核模块. </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>lsmod</userinput>
<computeroutput>Module                  Size  Used by
 autofs                  9456   2 (autoclean)
 opl3                   11376   0
 serial_cs               5456   0 (unused)
 sb                     34752   0
 uart401                 6384   0 [sb]
 sound                  58368   0 [opl3 sb uart401]
 soundlow                 464   0 [sound]
 soundcore               2800   6 [sb sound]
 ds                      6448   2 [serial_cs]
 i82365                 22928   2
 pcmcia_core            45984   0 [serial_cs ds i82365]</computeroutput>
	      </screen>
	    </para>
	    <note><para>使用<command>cat /proc/modules</command>可以得到同样的结果. </para></note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>insmod</command></term>
	  <indexterm>
	    <primary>insmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	  <listitem>
		  <para>强制安装一个内核模块(如果可能的话, 
			  使用<command>modprobe</command>来代替). 
			  必须以root身份调用. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rmmod</command></term>
	  <indexterm>
	    <primary>rmmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	  <listitem>
	    <para>强制卸载一个内核模块. 必须以root身份调用. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>modprobe</command></term>
	  <indexterm>
	    <primary>modprobe</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	  <listitem>
	    <para>模块装载器, 一般情况下都是在启动脚本中自动调用. 必须以root身份来运行. </para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>depmod</command></term>
	  <indexterm>
	    <primary>depmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	  <listitem>
	    <para>创建模块依赖文件, 一般都是在启动脚本中调用. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>modinfo</command></term>
	  <indexterm>
	    <primary>modinfo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>loadable modules</secondary>
	  </indexterm>
	  <listitem>

	    <para>输出一个可装载模块的信息. </para>

	      <screen><prompt>bash$ </prompt><userinput>modinfo hid</userinput>
<computeroutput>filename:    /lib/modules/2.4.20-6/kernel/drivers/usb/hid.o
 description: "USB HID support drivers"
 author:      "Andreas Gal, Vojtech Pavlik &lt;vojtech@suse.cz&gt;"
 license:     "GPL"</computeroutput>
	      </screen>
	  </listitem>
	</varlistentry>

      </variablelist>


      <variablelist id="miscsys">
        <title><anchor id="miscsys1">杂项类</title>

	<varlistentry>
	  <term><command>env</command></term>
	  <indexterm>
	    <primary>env</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>env</secondary>
	  </indexterm>
	  <listitem>
	    <para>使用设置过的或修改过(并不是修改整个系统环境)的<link
	      linkend="envref">环境变量</link>来运行一个程序或脚本. 
	      使用<option>[varname=xxx]</option>形式可以在脚本中修改环境变量. 
	     如果没有指定参数, 那么这个命令将会显示所有设置的环境变量. 
	      </para>

		  <note><para>在Bash或其它Bourne shell的衍生物中, 
				  是可以在同一命令行上设置多个变量的. 
	      <programlisting>var1=value1 var2=value2 commandXXX
# $var1和$var2只设置在'commandXXX'的环境中. </programlisting>	      
            </para></note>

			<tip><para>当不知道shell或解释器路径的时候, 
					脚本的第一行(#!<quote>sha-bang</quote>行)可以使用<command>env</command>. 
	      <programlisting>#! /usr/bin/env perl

print "This Perl script will run,\n";
print "even when I don't know where to find Perl.\n";

# 在不知道perl程序路径的时候, 
# 这么写有利于跨平台移植. 
# 感谢, S.C.</programlisting>
            </para></tip>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ldd</command></term>
	  <indexterm>
	    <primary>ldd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ldd</secondary>
	  </indexterm>
	  <listitem>
	    <para>显示一个可执行文件和它所需要共享库之间依赖关系. </para>
	    <screen><prompt>bash$ </prompt><userinput>ldd /bin/ls</userinput>
<computeroutput>libc.so.6 => /lib/libc.so.6 (0x4000c000)
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x80000000)</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="watchref"><command>watch</command></term>
	  <indexterm>
	    <primary>watch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>periodic</secondary>
	  </indexterm>
	  <listitem>
	    <para>以指定的时间间隔来重复运行一个命令. </para>
	    <para>默认的时间间隔是2秒, 但是可以使用<option>-n</option>选项进行修改. </para>
	    <para><programlisting>watch -n 5 tail /var/log/messages
# 每隔5秒钟显示系统log文件(/var/log/messages)的结尾. </programlisting></para>	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>strip</command></term>
	  <indexterm>
	    <primary>strip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>symbol</secondary>
	  </indexterm>
	  <listitem>
		  <para>从可执行文件中去掉调试符号的引用. 这样做可以减小可执行文件的尺寸, 但是就不能调试了. 
		  </para>
	    <para>这个命令一般都用在<link linkend="makefileref">Makefile</link>中, 
	      但是很少用在shell脚本中. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>nm</command></term>
	  <indexterm>
	    <primary>nm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>symbol</secondary>
	  </indexterm>
	  <listitem>
	    <para>列出未strip过的, 经过编译的, 2进制文件的全部符号. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rdist</command></term>
	  <indexterm>
	    <primary>rdist</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rdist</secondary>
	  </indexterm>
	  <listitem>
	    <para>远程分布客户端: 在远端服务器上同步, 克隆, 或者备份一个文件系统. </para>
	  </listitem>
	</varlistentry>

      </variablelist>



      <sect1 id="sysscripts">
        <title>分析一个系统脚本</title>

      <para><anchor id="killall2ref"></para>

		  <para>利用我们所学到的关于管理命令的知识, 让我们一起来练习分析一个系统脚本. 
			  最简单并且最短的系统脚本之一是<quote>killall</quote>, 
	   <footnote><para>系统的<firstterm>killall</firstterm>脚本不应该与<filename
	   class="directory">/usr/bin</filename>中的<link
	   linkend="killallref">killall</link>命令相混淆. 
	   </para></footnote>
	这个脚本被用来在系统关机时挂起运行的脚本. </para>

	    <example id="ex55">
	      <title><command>killall</command>, 来自于<filename class="directory">/etc/rc.d/init.d</filename></title>
	      <programlisting>&ex55;</programlisting>
	    </example>
      
      <para>这个没有那么糟. 除了在变量匹配的地方玩了一点花样, 其它也没有别的材料了. </para>

      <formalpara><title>练习1</title>
        <para>在<filename class="directory">/etc/rc.d/init.d</filename>中, 
			分析<command>halt</command>脚本. 
			比脚本<command>killall</command>长一些, 
			但是概念上很相近. 对这个脚本做一个拷贝, 
			放到你的home目录下并且用它练习一下, 
			(<emphasis>不</emphasis>要以root身份运行它). 
			使用<option>-vn</option>标志来模拟运行一下(<userinput>sh -vn scriptname</userinput>). 
			添加详细的注释. 将<quote>action</quote>命令修改为<quote>echo</quote>. </para></formalpara>

      <formalpara><title>练习2</title>
		  <para>察看<filename class="directory">/etc/rc.d/init.d</filename>下的更多更复杂的脚本. 
		  看看你是不是能够理解其中的一些脚本. 使用上边的过程来分析这些脚本. 为了更详细的理解, 你可能也需要分析在<filename
			  class="directory">/usr/share/doc/initscripts-?.??</filename>目录下的文件<filename>sysvinitfiles</filename>, 
			这些都是<quote>initscripts</quote>文档的一部分. </para></formalpara>

	</sect1> <!-- Analyzing a System Script -->

  </chapter> <!-- System and Administrative Commands -->



  <chapter id="commandsub">
    <title>命令替换</title>

      <indexterm>
	<primary>$</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>`</secondary>
      </indexterm>

	   <para>
		   <anchor id="commandsubref"><command>命令替换</command>能够重新分配一个<footnote><para>对于<emphasis>命令替换</emphasis>来说, 
		这个<command>命令</command>既可以是外部的系统命令, 
		也可以是内部脚本的<emphasis>内建命令</emphasis>, 
		甚至可以是<link linkend="rvt">脚本函数</link>. </para></footnote>
	     甚至是多个命令的输出; 
	     它会将命令的输出如实地添加到另一个上下文中. 
	        <footnote><para>从技术的角度来讲, 
		<emphasis>命令替换</emphasis>将会抽取一个命令的输出, 
		然后使用<token>=</token>操作将其赋值到一个变量中. 
		</para></footnote>
	     </para>


		 <para><anchor id="backquotesref">命令替换的典型用法形式, 
			是使用<firstterm>后置引用</firstterm>(`...`). 
			使用后置引用的(反引号)命令会产生命令行文本. 

	      <programlisting>script_name=`basename $0`
echo "The name of this script is $script_name."</programlisting></para>


	    <formalpara>
			<title>这样一来, 命令的输出就能够保存到变量中, 
			或者传递到另一个命令中作为这个命令的参数, 
			甚至可以用来产生<link linkend="forloopref1">for</link>循环的参数列表. 
	      </title>
	      <para></para>
	    </formalpara>

            <para>
	      <programlisting>rm `cat filename`   # <quote>filename</quote>包含了需要被删除的文件列表. 
#
# S. C. 指出, 这种使用方法可能会产生"参数列表太长"的错误. 
# 更好的方法是              xargs rm -- < filename 
# ( -- 同时涵盖了某些特殊情况, 这种特殊情况就是, 以<quote>-</quote>开头的文件名会产生不良结果.)

textfile_listing=`ls *.txt`
# 变量中包含了当前工作目录下所有的*.txt文件. 
echo $textfile_listing

textfile_listing2=$(ls *.txt)   # 这是命令替换的另一种形式. 
echo $textfile_listing2
# 同样的结果. 

# 如果将文件列表放入到一个字符串中的话, 
# 可能会混入一个新行. 
#
# 一种安全的将文件列表传递到参数中的方法就是使用数组. 
#      shopt -s nullglob    # 如果不匹配, 那就不进行文件名扩展. 
#      textfile_listing=( *.txt )
#
# 感谢, S.C.</programlisting>
            </para>

              <note><para>命令替换将会调用一个<link
	      linkend="subshellsref">subshell</link>. </para></note>



              <caution><para>命令替换可能会引起单词分割(word split). 
	        <programlisting>COMMAND `echo a b`     # 两个参数: a and b

COMMAND "`echo a b`"   # 1个参数: "a b"

COMMAND `echo`         # 无参数

COMMAND "`echo`"       # 一个空参数


# 感谢, S.C.</programlisting></para>


		  <para>即使没有引起单词分割(word split), 
			  命令替换也会去掉多余的新行. 

		<programlisting># cd "`pwd`"  # 这句总能正常运行. 
# 然而...

mkdir 'dir with trailing newline
'

cd 'dir with trailing newline
'

cd "`pwd`"  # 错误消息:
# bash: cd: /tmp/file with trailing newline: No such file or directory

cd "$PWD"   # 运行良好.





old_tty_setting=$(stty -g)   # 保存旧的终端设置. 
echo "Hit a key "
stty -icanon -echo           # 对终端禁用"canonical"模式. 
                             # 这样的话, 也会禁用了*本地*的echo. 
key=$(dd bs=1 count=1 2&gt; /dev/null)   #  使用'dd'命令来取得一个按键. 
stty "$old_tty_setting"      # 恢复旧的设置. 
echo "You hit ${#key} key."  # ${#variable} = number of characters in $variable
#
# 除了回车, 你随便敲任何按键都会输出"You hit 1 key."
# 如果敲回车, 那么输出就是"You hit 0 key."
# 新行已经被命令替换吃掉了. 

感谢, S.C.</programlisting>
              </para>
              </caution>


              <caution>
				  <para>如果用<command>echo</command>命令输出一个<emphasis>未引用</emphasis>变量, 
		而且这个变量以命令替换的结果作为值, 
		那么这个变量中的换行符将会被删除. 
		这可能会引起一些异常状况. 

		<programlisting>dir_listing=`ls -l`
echo $dir_listing     # 未引用, 就是没用引号括起来

# 期望打印出经过排序的目录列表. 

# 可惜, 我们只能获得这些: 
# total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo
# bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh

# 新行消失了. 


echo "$dir_listing"   # 引用起来
# -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt
# -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh
# -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh</programlisting>
              </para>
              </caution>



			  <para>命令替换甚至允许将整个文件的内容放到变量中, 
				  可以使用<link linkend="ioredirref">重定向</link>或者<link 
					  linkend="catref">cat</link>命令. </para>

             <para>
	         <programlisting>variable1=`&lt;file1`      #  将"file1"的内容放到"variable1"中. 
variable2=`cat file2`   #  将"file2"的内容放到"variable2"中. 
                        #  但是这行将会fork一个新进程, 
                        #+ 所以这行代码将会比第一行代码执行得慢. 

#  注意:
#  变量中可以包含空白, 
#+ 甚至是(厌恶至极的), 控制字符. </programlisting>
             </para>

             <para>
	         <programlisting>#  摘录自系统文件, /etc/rc.d/rc.sysinit
#+ (这是红帽系统中的)


if [ -f /fsckoptions ]; then
        fsckoptions=`cat /fsckoptions`
...
fi
#
#
if [ -e "/proc/ide/${disk[$device]}/media" ] ; then
             hdmedia=`cat /proc/ide/${disk[$device]}/media`
...
fi
#
#
if [ ! -n "`uname -r | grep -- "-"`" ]; then
       ktag="`cat /proc/version`"
...
fi
#
#
if [ $usb = "1" ]; then
    sleep 5
    mouseoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=02"`
    kbdoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=01"`
...
fi</programlisting>
             </para>

	     <caution>
             <para>不要将一个<emphasis>长</emphasis>文本文件的全部内容设置到变量中, 
	       除非你有一个非常好的原因非这么做不可, 
	       也不要将<emphasis>二进制</emphasis>文件的内容保存到变量中, 即使是开玩笑也不行. </para>

	    <example id="stupscr">
	      <title>愚蠢的脚本策略</title>
	      <programlisting>&stupscr;</programlisting>
	    </example>

	     <para>注意, 在这里不会发生<emphasis>缓冲区溢出</emphasis>错误. 
			 因为这是一个解释型语言的实例, 
			 Bash就是一种解释型语言, 
			 解释型语言会比编译型语言提供更多的对程序错误的保护措施. 
	       </para>

	     </caution>


	      <para>变量替换允许将一个<link linkend="forloopref1">loop</link>的输出设置到一个变量中. 
		这么做的关键就是将循环中<link
			linkend="echoref">echo</link>命令的输出全部截取. 
		</para>

	    <example id="csubloop">
	      <title>将一个循环输出的内容设置到变量中</title>
	      <programlisting>&csubloop;</programlisting>
	    </example>



	      <sidebar>
              <para>命令替换使得扩展有效Bash工具集变为可能
		这样, 写一段小程序或者一段脚本就可以达到目的. 
		因为程序或脚本的输出会传到<filename>stdout</filename>上(就像一个标准UNIX工具所做的那样), 
		然后重新将这些输出保存到变量中. 
		(译者: 作者的意思就是在这种情况下写脚本和写程序作用是一样的.)</para>

		<para>
		<programlisting>#include &lt;stdio.h&gt;

/*  "Hello, world." C program  */		

int main()
{
  printf( "Hello, world." );
  return (0);
}</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>gcc -o hello hello.c</userinput>
	      </screen>
		</para>

		<para>
                <programlisting>#!/bin/bash
# hello.sh		

greeting=`./hello`
echo $greeting</programlisting>
	      <screen><prompt>bash$ </prompt><userinput>sh hello.sh</userinput>
<computeroutput>Hello, world.</computeroutput>
	        </screen>
	        </para>
	        </sidebar>
	      
	      <note>

			  <para>对于命令替换来说, 
				  <command>$(COMMAND)</command>形式已经取代了后置引用"`". 
			</para>

	      <para><programlisting>output=$(sed -n /"$1"/p $file)   # 来自于例子"grp.sh". 
	      
# 将文本文件的内容保存到一个变量中. 
File_contents1=$(cat $file1)      
File_contents2=$(&lt;$file2)        # Bash也允许这么做. </programlisting></para>

              <para><command>$(...)</command>形式的命令替换在处理双反斜线(\\)时与<command>`...`</command>形式不同. </para>

              <para>		
	      <screen><prompt>bash$ </prompt><userinput>echo `echo \\`</userinput>
<computeroutput></computeroutput>

<prompt>bash$ </prompt><userinput>echo $(echo \\)</userinput>
<computeroutput>\</computeroutput>
	      </screen>
              </para>		

              <para><command>$(...)</command>形式的命令替换是允许嵌套的. 
		  <footnote>
		    <para>
				事实上, 对于后置引用的嵌套是可行的, 
				但是只能将内部的反引号转义才行, 
				就像John默认指出的那样. 
		      <programlisting>word_count=` wc -w \`ls -l | awk '{print $9}'\` `</programlisting>
		    </para>
		  </footnote>
		
		</para>

              <para><programlisting>word_count=$( wc -w $(ls -l | awk '{print $9}') )</programlisting>
              </para>

              <para>或者, 可以更加灵活 . . .</para>

      <example id="agram2">
		  <title>找anagram(回文构词法, 可以将一个有意义的单词, 
			  变换为1个或多个有意义的单词, 但是还是原来的子母集合)</title>
	<programlisting>&agram2;</programlisting>
      </example>


              </note>


     <para>命令替换在脚本中使用的例子: 
       <orderedlist>
         <listitem><para><xref linkend="bingrep"></para></listitem>
	 <listitem><para><xref linkend="casecmd"></para></listitem>
	 <listitem><para><xref linkend="seedingrandom"></para></listitem>
	 <listitem><para><xref linkend="ex57"></para></listitem>
         <listitem><para><xref linkend="lowercase"></para></listitem>
	 <listitem><para><xref linkend="grp"></para></listitem>
	 <listitem><para><xref linkend="ex53"></para></listitem>
         <listitem><para><xref linkend="ex24"></para></listitem>
	 <listitem><para><xref linkend="symlinks"></para></listitem>
	 <listitem><para><xref linkend="stripc"></para></listitem>
	 <listitem><para><xref linkend="redir4"></para></listitem>
	 <listitem><para><xref linkend="tree"></para></listitem>
	 <listitem><para><xref linkend="pidid"></para></listitem>
	 <listitem><para><xref linkend="monthlypmt"></para></listitem>
	 <listitem><para><xref linkend="base"></para></listitem>
	 <listitem><para><xref linkend="altbc"></para></listitem>
       </orderedlist>
     </para>  

  </chapter> <!-- Command Substitution -->



  <chapter id="arithexp">
    <title>算术扩展</title>


      <para><anchor id="arithexpref">算术扩展提供了一种强力工具, 
			  可以在脚本中执行(整型)算法操作. 
			  可以使用<link linkend="backquotesref">backticks</link>, 
			  <link linkend="dblparens">double parentheses</link>, 
			  或<link linkend="letref">let</link>来将字符串转换为数字表达式. </para>

      <variablelist id="arithexpvar">
        <title><anchor id="arithexpvar1">一些变化</title>

	<varlistentry>
		<term>使用后置引用的算术扩展(通常都是和<link 
				linkend="exprref">expr</link>一起使用)</term> <indexterm>
	    <primary>arithmetic</primary> <secondary>expansion</secondary>
	  </indexterm> <indexterm>
	    <primary>arithmetic</primary> <secondary>expansion</secondary>
	  </indexterm> <listitem>
	    <para><programlisting>z=`expr $z + 3`          # 'expr'命令将会执行这个扩展. </programlisting></para>

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term>使用双括号形式的算术扩展</term>
	  <indexterm><primary>double</primary>
	  <secondary>parentheses</secondary></indexterm>
	  <term>也可以使用<command>let</command>命令</term>
	  <indexterm><primary>let</primary>
	  <secondary>let</secondary></indexterm>


	  <listitem>

	   <para>后置引用形式的算术扩展已经被双括号形式所替代了 -- 
		   <userinput>((...))</userinput>和<userinput>$((...))</userinput> 
		  -- 当然也可以使用非常方便的<command>let</command>结构. </para>

	    <para>
	      <programlisting>z=$(($z+3))
z=$((z+3))                                  #  也正确. 
                                            #  使用双括号的形式, 
                                            #+ 参数解引用
                                            #+ 是可选的. 

# $((EXPRESSION))是算数表达式.              #  不要与命令替换
                                            #+ 相混淆. 



# 使用双括号的形式也可以不用给变量赋值. 

  n=0
  echo "n = $n"                             # n = 0

  (( n += 1 ))                              # 递增. 
# (( $n += 1 )) is incorrect!
  echo "n = $n"                             # n = 1


let z=z+3
let "z += 3"  #  使用引用的形式, 允许在变量赋值的时候存在空格. 
              #  'let'命令事实上执行得的是算术赋值, 
              #+ 而不是算术扩展. </programlisting>
	    </para>

     <para>下边是一些在脚本中使用算术扩展的例子: 
       <orderedlist>
         <listitem><para><xref linkend="ex45"></para></listitem>
         <listitem><para><xref linkend="ex25"></para></listitem>
         <listitem><para><xref linkend="ex66"></para></listitem>
	 <listitem><para><xref linkend="bubble"></para></listitem>
	 <listitem><para><xref linkend="tree"></para></listitem>
       </orderedlist>
     </para>  

	  </listitem>
	</varlistentry>

      </variablelist>

  </chapter> <!-- Arithmetic Expansion -->



  <chapter id="io-redirection">
    <title>I/O重定向</title>

      <para><anchor id="ioredirref"></para>

      <para>默认情况下始终有3个<quote>文件</quote>处于打开状态, 
	<filename>stdin</filename>(键盘),
	<filename>stdout</filename>(屏幕), 
	和<filename>stderr</filename>(错误消息输出到屏幕上). 
	这3个文件和其他打开的文件都可以被重定向. 
	对于重定向简单的解释就是捕捉一个文件, 命令, 
	程序, 脚本, 或者是脚本中的代码块(请参考<xref
		linkend="ex8">和<xref linkend="rpmcheck">)的输出, 
			然后将这些输出作为输入发送到另一个文件, 命令, 程序, 或脚本中. 
	</para>

      <para><anchor id="fdref">每个打开的文件都会被分配一个文件描述符. 

               <footnote><para>一个<emphasis>文件描述符</emphasis>说白了就是文件系统为了跟踪这个打开的文件而分配给它的一个数字. 
			也可以的将其理解为文件指针的一个简单版本. 
		 与C语言中<emphasis>文件句柄</emphasis>的概念很相似. </para></footnote>

	<filename>stdin</filename>, <filename>stdout</filename>, 
	和<filename>stderr</filename>的文件描述符分别是0, 1, 和 2. 
	除了这3个文件, 对于其他那些需要打开的文件, 保留了文件描述符3到9. 
	在某些情况下, 将这些额外的文件描述符分配给<filename>stdin</filename>, 
	<filename>stdout</filename>, 或<filename>stderr</filename>作为临时的副本链接是非常有用的. 
		<footnote><para>使用<replaceable>文件描述符5</replaceable>可能会引起问题. 
		当Bash使用<link linkend="execref">exec</link>创建一个子进程的时候, 
		子进程会继承fd5(参考Chet Ramey的归档e-mail, 
		<ulink url="http://www.geocrawler.com/archives/3/342/1996/1/0/1939805/">
	       SUBJECT: RE:  File descriptor 5 is held open</ulink>).
	       最好还是不要去招惹这个特定的fd. </para></footnote>
	在经过复杂的重定向和刷新之后需要把它们恢复成正常状态(请参考<xref linkend="redir1">). </para>

      <para><anchor id="ioredirectionref"></para>

      <programlisting>   COMMAND_OUTPUT >
      # 将stdout重定向到一个文件. 
      # 如果这个文件不存在, 那就创建, 否则就覆盖. 

      ls -lR > dir-tree.list
      # 创建一个包含目录树列表的文件. 

   : > filename
      # >操作, 将会把文件"filename"变为一个空文件(就是size为0). 
      # 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同). 
      # :是一个占位符, 不产生任何输出. 

   > filename    
      # >操作, 将会把文件"filename"变为一个空文件(就是size为0). 
      # 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同). 
      # (与上边的": >"效果相同, 但是某些shell可能不支持这种形式.)

   COMMAND_OUTPUT >>
      # 将stdout重定向到一个文件. 
      # 如果文件不存在, 那么就创建它, 如果存在, 那么就追加到文件后边. 


      # 单行重定向命令(只会影响它们所在的行): 
      # --------------------------------------------------------------------

   1>filename
      # 重定向stdout到文件"filename". 
   1>>filename
      # 重定向并追加stdout到文件"filename". 
   2>filename
      # 重定向stderr到文件"filename". 
   2>>filename
      # 重定向并追加stderr到文件"filename". 
   &>filename
      # 将stdout和stderr都重定向到文件"filename". 

   M>N
     # "M"是一个文件描述符, 如果没有明确指定的话默认为1. 
     # "N"是一个文件名. 
     # 文件描述符"M"被重定向到文件"N". 
   M&gt;&amp;N
     # "M"是一个文件描述符, 如果没有明确指定的话默认为1. 
     # "N"是另一个文件描述符. 

      #==============================================================================

      # 重定向stdout, 一次一行. 
      LOGFILE=script.log

      echo "This statement is sent to the log file, \"$LOGFILE\"." 1>$LOGFILE
      echo "This statement is appended to \"$LOGFILE\"." 1>>$LOGFILE
      echo "This statement is also appended to \"$LOGFILE\"." 1>>$LOGFILE
      echo "This statement is echoed to stdout, and will not appear in \"$LOGFILE\"."
      # 每行过后, 这些重定向命令会自动"reset". 



      # 重定向stderr, 一次一行. 
      ERRORFILE=script.errors

      bad_command1 2>$ERRORFILE       #  Error message sent to $ERRORFILE.
      bad_command2 2>>$ERRORFILE      #  Error message appended to $ERRORFILE.
      bad_command3                    #  Error message echoed to stderr,
                                      #+ and does not appear in $ERRORFILE.
      # 每行过后, 这些重定向命令也会自动"reset". 
      #==============================================================================



   2>&amp;1
      # 重定向stderr到stdout. 
      # 将错误消息的输出, 发送到与标准输出所指向的地方. 

   i>&amp;j
      # 重定向文件描述符<emphasis>i</emphasis>到<emphasis>j</emphasis>. 
      # 指向<emphasis>i</emphasis>文件的所有输出都发送到<emphasis>j</emphasis>. 

   >&amp;j
      # 默认的, 重定向文件描述符<emphasis>1</emphasis>(stdout)到<emphasis>j</emphasis>. 
      # 所有传递到stdout的输出都送到<emphasis>j</emphasis>中去. 

   0< FILENAME
    < FILENAME
      # 从文件中接受输入. 
      # 与<quote>></quote>是成对命令, 并且通常都是结合使用. 
      #
      # grep search-word &lt;filename


   [j]&lt;&gt;filename
      # 为了读写"filename", 把文件"filename"打开, 并且将文件描述符"j"分配给它. 
      # 如果文件"filename"不存在, 那么就创建它. 
      # 如果文件描述符"j"没指定, 那默认是fd 0, stdin. 
      #
      # 这种应用通常是为了写到一个文件中指定的地方. 
      echo 1234567890 > File    # 写字符串到"File". 
      exec 3&lt;&gt; File             # 打开"File"并且将fd 3分配给它. 
      read -n 4 <&3             # 只读取4个字符. 
      echo -n . >&3             # 写一个小数点. 
      exec 3>&-                 # 关闭fd 3.
      cat File                  # ==> 1234.67890
      # 随机访问. 



   |
      # 管道. 
      # 通用目的处理和命令链工具. 
      # 与<quote>></quote>, 很相似, 但是实际上更通用. 
      # 对于想将命令, 脚本, 文件和程序串连起来的时候很有用. 
      cat *.txt | sort | uniq > result-file
      # 对所有.txt文件的输出进行排序, 并且删除重复行. 
      # 最后将结果保存到<quote>result-file</quote>中. 
</programlisting>

      <para>可以将输入输出重定向和(或)管道的多个实例结合到一起写在同一行上. 

       <programlisting>command &lt; input-file &gt; output-file

command1 | command2 | command3 > output-file</programlisting>
        请参考<xref linkend="derpm">和<xref linkend="fifo">. </para>

       
       <para>可以将多个输出流重定向到一个文件上. 

         <programlisting>ls -yz >> command.log 2>&1
#  将错误选项"yz"的结果放到文件"command.log"中. 
#  因为stderr被重定向到这个文件中, 
#+ 所有的错误消息也就都指向那里了. 

#   注意, 下边这个例子就不会给出相同的结果. 
ls -yz 2>&1 >> command.log
#  输出一个错误消息, 但是并不写到文件中. 

#  如果将stdout和stderr都重定向, 
#+ 命令的顺序会有些不同. 
</programlisting></para>


      <variablelist id="closingfiledescriptors">
        <title><anchor id="cfd">关闭文件描述符</title>

	<varlistentry>
	  <term><token>n<&-</token></term>
	  <listitem>
	    <para>关闭输入文件描述符<replaceable>n</replaceable>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>0<&-</token></term>
	  <term><token><&-</token></term>
	  <listitem>
	    <para>关闭<filename>stdin</filename>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>n>&-</token></term>
	  <listitem>
	    <para>关闭输出文件描述符<replaceable>n</replaceable>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>1>&-</token></term>
	  <term><token>>&-</token></term>
	  <listitem>
	    <para>关闭<filename>stdout</filename>. </para>
	  </listitem>
	</varlistentry>

      </variablelist>


	  <para>子进程继承了打开的文件描述符. 这就是为什么管道可以工作. 
		  如果想阻止fd被继承, 那么可以关掉它. 
	    <programlisting># 只将stderr重定到一个管道. 

exec 3>&1                              # 保存当前stdout的"值". 
ls -l 2>&1 >&3 3>&- | grep bad 3>&-    # 对'grep'关闭fd 3(但不关闭'ls'). 
#              ^^^^   ^^^^
exec 3>&-                              # 对于剩余的脚本来说, 关闭它. 

# 感谢, S.C. </programlisting>
        </para>

	<para>如果想了解关于I/O重定向更多的细节, 请参考<xref linkend="ioredirintro">. </para>




      <sect1><title>使用<command>exec</command></title>


	<para><anchor id="usingexecref"></para>

		<para><command>exec &lt;filename</command>命令会将<filename>stdin</filename>重定向到文件中. 
			从这句开始, 所有的<filename>stdin</filename>就都来自于这个文件了, 
		而不是标准输入(通常都是键盘输入). 
		这样就提供了一种按行读取文件的方法, 
		并且可以使用<link linkend="sedref">sed</link>和/或<link linkend="awkref">awk</link>来对每一行进行分析. </para>

      <example id="redir1">
	<title>使用<command>exec</command>重定向<filename>stdin</filename></title>
	<programlisting>&redir1;</programlisting>
      </example>

        <para>同样的, <command>exec &gt;filename</command>命令将会把<filename>stdout</filename>重定向到一个指定的文件中. 
	  这样所有命令的输出就都会发送到那个指定的文件, 
	  而不是<filename>stdout</filename>. </para>

      <important>
        <para>
			<command>exec N > filename</command>会影响整个脚本或<emphasis>当前shell</emphasis>. 
			对于这个指定<link linkend="processidref">PID</link>的脚本或shell来说, 
			从这句命令执行之后, 就会重定向到这个文件中, 
			然而 . . .
        </para>
        <para>
	  <command>N > filename</command>只会影响新fork出来的进程, 而不会影响整个脚本或shell. 
	  not the entire script or shell.
        </para>
	<para>感谢你, Ahmed Darwish, 指出这个问题. </para>
      </important>



      <example id="reassignstdout">
	<title>使用<command>exec</command>来重定向<filename>stdout</filename></title>
	<programlisting>&reassignstdout;</programlisting>
      </example>

      <example id="upperconv">
	<title>使用<command>exec</command>在同一个脚本中重定向<filename>stdin</filename>和<filename>stdout</filename></title>
	<programlisting>&upperconv;</programlisting>
      </example>

      <para>I/O重定向是一种避免可怕的<link
      linkend="parvis">子shell中不可访问变量</link>问题的方法. 
      </para>

      <example id="avoidsubshell">
	<title>避免子shell</title>
	<programlisting>&avoidsubshell;</programlisting>
      </example>

       

       </sect1><!-- Using exec For Redirection -->	



      <sect1 id="redircb"><title>代码块重定向</title>

        <para><anchor id="redirref">象<link
	  linkend="whileloopref">while</link>, <link
	  linkend="untilloopref">until</link>, 和<link
	  linkend="forloopref1">for</link>循环代码块, 
	  甚至<link linkend="ifthen">if/then</link>测试结构的代码块, 
	  都可以对<filename>stdin</filename>进行重定向. 
	  即使函数也可以使用这种重定向方式(请参考<xref linkend="realname">). 
	  要想做到这些, 都要依靠代码块结尾的<token>&lt;</token>操作符. 
	  </para>

      <example id="redir2">
	<title><emphasis>while</emphasis>循环的重定向</title>
	<programlisting>&redir2;</programlisting>
      </example>

      <example id="redir2a">
	<title>重定向<emphasis>while</emphasis>循环的另一种形式</title>
	<programlisting>&redir2a;</programlisting>
      </example>

      <example id="redir3">
	<title>重定向<emphasis>until</emphasis>循环</title>
	<programlisting>&redir3;</programlisting>
      </example>

      <example id="redir4">
	<title>重定向<emphasis>for</emphasis>循环</title>
	<programlisting>&redir4;</programlisting>
      </example>

      <para>我们也可以修改前面的例子使其能重定向循环的标准输出. </para>

      <example id="redir4a">
	<title>重定向<emphasis>for</emphasis>循环(<filename>stdin</filename>和<filename>stdout</filename>都进行重定向)</title>
	<programlisting>&redir4a;</programlisting>
      </example>

      <example id="redir5">
	<title>重定向<emphasis>if/then</emphasis>测试结构</title>
	<programlisting>&redir5;</programlisting>
      </example>

      <example id="namesdata">
	<title>用于上面例子的<quote>names.data</quote>数据文件</title>
	<programlisting>&namesdata;</programlisting>
      </example>

      <para>重定向代码块的<filename>stdout</filename>, 
	与"将代码块的输出保存到文件中"具有相同的效果. 请参考<xref
	linkend="rpmcheck">. </para>

      <para><link linkend="heredocref">here document</link>
        是重定向代码块的一个特例. </para>

      </sect1><!--  Redirecting Code Blocks -->



      <sect1 id="redirapps"><title>重定向的应用</title>

      <para>巧妙地运用I/O重定向, 能够解析和粘合命令输出的各个片断(请参考<xref
	linkend="readredir">). 这样就可以产生报告与日志文件. </para>

      <example id="logevents">
	<title>事件纪录</title>
	<programlisting>&logevents;</programlisting>
      </example>


       </sect1><!-- Applications -->	


  </chapter> <!-- I/O Redirection -->



  <chapter id="here-docs">
    <title>Here Document</title>

    <epigraph>
      <attribution>Aldous Huxley, <quote>Island</quote></attribution>
      <para>Here and now, boys.</para>
    </epigraph>
    
      <para><anchor id="heredocref"></para>

      <indexterm>
	<primary><<</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary><<</secondary>
      </indexterm>
      
      <para>一个<firstterm>here document</firstterm>就是一段带有特殊目的的代码段. 
	它使用<link linkend="ioredirref">I/O重定向</link>的形式将一个命令序列传递到一个交互程序或者命令中, 比如<link
	linkend="ftpref">ftp</link>, <link linkend="catref">cat</link>,
	或者<firstterm>ex</firstterm>文本编辑器. </para>

      <para><programlisting>COMMAND &lt;&lt;InputComesFromHERE
...
InputComesFromHERE</programlisting></para>


	  <para><firstterm>limit string</firstterm>用来界定命令序列的范围(译者注: 
	两个相同的limit string之间就是命令序列). 
	特殊符号<token><<</token>用来标识limit string. 
	这个符号的作用就是将文件的输出重定向到程序或命令的<filename>stdin</filename>中. 
	与<userinput>interactive-program <
	command-file</userinput>很相似, 其中<filename>command-file</filename>包含: 

	  <programlisting>command #1
command #2
...</programlisting></para>

      <para>而<emphasis>here document</emphasis>看上去是下面这个样子: </para>

      <para><programlisting>#!/bin/bash
interactive-program &lt;&lt;LimitString
command #1
command #2
...
LimitString</programlisting></para>

      <para>选择一个名字非常诡异<emphasis>limit string</emphasis>能够有效的避免命令列表与<emphasis>limit string</emphasis>重名的问题. </para>

      <para>注意, 某些情况下, 把<emphasis>here document</emphasis>用在非交互工具或命令中, 也会取得非常好的效果, 
	比如, <link linkend="wallref">wall</link>. </para>


      <example id="ex70">
	<title><command>广播</command>: 将消息发送给每个登陆的用户</title>
	<programlisting>&ex70;</programlisting>
      </example>


	  <para>对于某些看上去不太可能的工具, 
		  比如<firstterm>vi</firstterm>, 
        也能够使用<emphasis>here document</emphasis>. </para>

      <example id="ex69">
	<title><command>虚拟文件</command>: 创建一个2行的虚拟文件</title>
	<programlisting>&ex69;</programlisting>
      </example>

      <para>
		  上边的脚本也可以不用<command>vi</command>而改用<command>ex</command>来实现, 
		  <emphasis>here document</emphasis>包含<command>ex</command>命令列表的形式足以形成自己的类别了, 
		  称为<firstterm>ex script</firstterm>. 

	  <programlisting>#!/bin/bash
#  把所有后缀为".txt"文件
#+ 中的"Smith"都替换成"Jones". 

ORIGINAL=Smith
REPLACEMENT=Jones

for word in $(fgrep -l $ORIGINAL *.txt)
do
  # -------------------------------------
  ex $word &lt;&lt;EOF
  :%s/$ORIGINAL/$REPLACEMENT/g
  :wq
EOF
  # :%s是"ex"的替换命令. (译者注: 与vi和vim的基本命令相同)
  # :wq是保存并退出的意思. 
  # -------------------------------------
done</programlisting>
	</para>

      <para><anchor id="catscriptref"></para>
      <para>与<quote>ex script</quote>相似的是<firstterm>cat script</firstterm>. </para>

      <example id="ex71">
	<title>使用<command>cat</command>的多行消息</title>
	<programlisting>&ex71;</programlisting>
      </example>


      <para><option>-</option>选项用来标记here document的limit string
		  (<userinput>&lt;&lt;-LimitString</userinput>), 
		  可以抑制输出时前边的tab(不是空格). 这么做可以增加一个脚本的可读性. </para>

      <example id="ex71a">
	<title>带有抑制tab功能的多行消息</title>
	<programlisting>&ex71a;</programlisting>
      </example>


	  <para><emphasis>here document</emphasis>支持参数和命令替换. 
		  所以也可以给here document的消息体传递不同的参数, 
		  这样相应的也会修改输出. 
	</para>

      <example id="ex71b">
	<title>使用参数替换的here document</title>
	<programlisting>&ex71b;</programlisting>
      </example>

      <para>这是一个非常有用的脚本, 其中使用了包含参数替换的here document.  </para>

      <example id="ex72">
	<title>上传一个文件对到<quote>Sunsite</quote>的incoming目录</title>
	<programlisting>&ex72;</programlisting>
      </example>

      
	  <para>在here document的开头, 引用或转义<quote>limit string</quote>, 
		  会使得here document消息体中的参数替换被禁用. 
	</para>

      <example id="ex71c">
	<title>关闭参数替换</title>
	<programlisting>&ex71c;</programlisting>
      </example>

      <para>禁用了参数替换后, 将允许输出文本本身(译者注: 就是未转义的原文). 
        如果你想产生脚本甚至是程序代码的话, 那么可以使用这种办法. </para>
      
      <example id="generatescript">
	<title>生成另外一个脚本的脚本</title>
	<programlisting>&generatescript;</programlisting>
      </example>



      <para>
        也可以将here document的输出保存到变量中. 
	<programlisting>variable=$(cat &lt;&lt;SETVAR
This variable
runs over multiple lines.
SETVAR)

echo "$variable"</programlisting>
      </para>


      <para>A here document can supply input to a function in the same
        script.</para>

	    <example id="hf">
	      <title>Here document与函数</title>
	      <programlisting>&hf;</programlisting>
	    </example>

      <para><anchor id="anonheredoc0"></para>
		  <para>也可以这么使用<token>:</token>(冒号), 
			  做一个假命令来从一个here document中接收输出. 
        这么做事实上就是创建了一个<quote>匿名</quote>的here document. 
	</para>

	<example id="anonheredoc">
	  <title><quote>匿名</quote>的here Document</title>
	<programlisting>#!/bin/bash

: &lt;&lt;TESTVARIABLES
${HOSTNAME?}${USER?}${MAIL?}  # 如果其中某个变量没被设置, 那么就打印错误信息. 
TESTVARIABLES

exit 0</programlisting>
       </example>


      <para><anchor id="cblock1"></para>
		  <tip><para>上边所示技术的一种变化, 可以用来<quote>注释</quote>掉代码块. </para></tip>

      <example id="commentblock">
	<title>注释掉一段代码块</title>
	<programlisting>&commentblock;</programlisting>
      </example>


      <tip><para>关于这种小技巧的另一个应用就是能够产生<quote>自文档化(self-documenting)</quote>的脚本. </para></tip>

      <example id="selfdocument">
	<title>一个自文档化(self-documenting)的脚本</title>
	<programlisting>&selfdocument;</programlisting>
      </example>

      <para>使用<link linkend="catscriptref">cat脚本</link>也能够完成相同的目的. </para>

      <para>
      <programlisting>DOC_REQUEST=70

if [ "$1" = "-h"  -o "$1" = "--help" ]     # 请求帮助. 
then                                       # 使用"cat脚本" . . . 
  cat &lt;&lt;DOCUMENTATIONXX
List the statistics of a specified directory in tabular format.
---------------------------------------------------------------
The command line parameter gives the directory to be listed.
If no directory specified or directory specified cannot be read,
then list the current working directory.

DOCUMENTATIONXX
exit $DOC_REQUEST
fi</programlisting>
      </para>


	  <para>请参考<xref linkend="isspammer2">可以看到更多关于<quote>自文档化</quote>脚本的好例子. </para>

	  <note>
		  <para>Here document创建临时文件, 
			  但是这些文件将在打开后被删除, 
			  并且不能够被任何其他进程所访问. 
	    </para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>bash -c 'lsof -a -p $$ -d0' << EOF</userinput>
<prompt>&gt; </prompt><userinput>EOF</userinput>
<computeroutput>lsof    1213 bozo    0r   REG    3,5    0 30386 /tmp/t1213-0-sh (deleted)</computeroutput>
	      </screen>
	  </para>
	  </note>

	<caution><para>某些工具是不能放入<emphasis>here document</emphasis>中运行的. </para></caution>

         <para><anchor id="indentedls"></para>

	<warning>

	<para>结尾的<emphasis>limit string</emphasis>, 
	  就是here document最后一行的limit string, 
	  必须从<emphasis>第一个</emphasis>字符开始. 
	  它的前面不能够有任何<emphasis>前置的空白</emphasis>. 
	  而在这个limit string后边的空白也会引起异常. 
	  空白将会阻止limit string的识别. 
	  (译者注: 下边这个脚本由于结束limit string的问题, 
	  造成脚本无法结束, 所有内容全部被打印出来, 
	  所以注释就不译了, 保持这个例子脚本的原样.)
  </para>

	  
	  
	 <para>
	 <programlisting>#!/bin/bash

echo "----------------------------------------------------------------------"

cat &lt;&lt;LimitString
echo "This is line 1 of the message inside the here document."
echo "This is line 2 of the message inside the here document."
echo "This is the final line of the message inside the here document."
     LimitString
#^^^^Indented limit string. Error! This script will not behave as expected.

echo "----------------------------------------------------------------------"

#  These comments are outside the 'here document',
#+ and should not echo.

echo "Outside the here document."

exit 0

echo "This line had better not echo."  # Follows an 'exit' command.</programlisting>
	 </para>
	  </warning>


	  <para>对于那些使用<quote>here document</quote>, 并且非常复杂的任务, 
		  最好考虑使用<command>expect</command>脚本语言, 
		  这种语言就是为了达到向交互程序添加输入的目的而量身定做的. 
	  </para>



      <sect1><title>Here String</title>

	 <para><anchor id="herestringsref"></para>

         <para><firstterm>here string</firstterm>可以看成是<firstterm>here document</firstterm>的一种定制形式. 
			 除了<command>COMMAND &lt;&lt;&lt;$WORD</command>, 就什么都没有了, 
			<varname>$WORD</varname>将被扩展并且被送入<varname>COMMAND</varname>的<filename>stdin</filename>中. </para>

        <para>
	<programlisting>String="This is a string of words."

read -r -a Words <<< "$String"
#  "read"命令的-a选项
#+ 将会把结果值按顺序的分配给数组中的每一项. 

echo "First word in String is:    ${Words[0]}"   # This
echo "Second word in String is:   ${Words[1]}"   # is
echo "Third word in String is:    ${Words[2]}"   # a
echo "Fourth word in String is:   ${Words[3]}"   # string
echo "Fifth word in String is:    ${Words[4]}"   # of
echo "Sixth word in String is:    ${Words[5]}"   # words.
echo "Seventh word in String is:  ${Words[6]}"   # (null)
                                                 # $String的结尾. 

# 感谢, Francisco Lobo的这个建议. </programlisting>
        </para>

      <example id="prependex">
	<title>在一个文件的开头添加文本</title>
	<programlisting>&prependex;</programlisting>
      </example>

      <example id="mailboxgrep">
	<title>分析一个邮箱</title>
	<programlisting>&mailboxgrep;</programlisting>
      </example>

         <para>练习: 找出<emphasis>here string</emphasis>的其他用法. </para>

      </sect1><!--   Here Strings    -->


  </chapter> <!-- Here Documents -->



  <chapter id="Recess-Time">
    <title>休息片刻</title>

      <blockquote>
	<literallayout>  
	  这片刻的休息可以让读者放松一下, 并且学习了这么多东西, 
	  读者也可以发出会心的微笑了. 

	  Linux同志们, 向你们致敬! 你正在阅读的这些东西, 将会给你们带来好运. 
	  把这份文档发给你的10个朋友. 在拷贝这份文档之前, 
	  在信的结尾加上一个100行的Bash脚本, 然后发送给列表上的第一个人. 
	  最后在信的底部删除他们的名字, 并把你自己的名字添加到列表的尾部. 

	  千万不要打断这个发送的通道! 并且在48小时之内发送出去. 
	  Brooklyn的Wilfred P.就因为没有成功的发送他的10个拷贝, 
	  当他第2天早上醒来, 发现他变成了一个"COBOL 程序员". 
	  而Newport News的Howard L.在一个月内才发出了他的10个拷贝, 
	  如果有足够的硬件, 
	  一个月的时间足以建立一个100个节点的Beowulf cluster来玩<emphasis>Tuxracer</emphasis>了. 
	  Chicago的Amelia V.对这封信付之一笑, 并且打断了这个发送通道. 
	  不久之后, 她的终端爆炸了, 
	  现在, 她不得不每天为MS Windows编写文档. 

	  千万不要打断这个发送的通道!  今天就把10个拷贝发送出去! 


	<emphasis>Courtesy 'NIX "fortune cookies", with some
	  alterations and many apologies</emphasis>
	</literallayout>  

      </blockquote>
      
  </chapter> <!-- Recess Time -->

  </part> <!-- Part 3 (Beyond the Basics) -->

  

  <part label="第四部分" id="part4">
    <title>高级主题</title>

    <partintro>
		<para>到了这儿, 我们准备深入讨论一些在脚本编程中的难点, 
			和一些不寻常的话题. 随着话题的展开, 我们会采用很多种方法, 
			并且使用检查<emphasis>边界条件</emphasis>的方式来<quote>打开信封</quote>, 
			看清楚其中的奥妙. 
	(看看我们在探索未知领域的时候, 到底会发生什么?). </para>
     </partintro>

  <chapter id="regexp">
      <title>正则表达式</title>

    <epigraph>
      <attribution>Stowe Boyd</attribution>
      <para>. . . 与软件开发相关的一些需要思想的行为, 主要取决于你对问题的深刻见解. </para>
    </epigraph>

      <para><anchor id="regexref"></para>

		  <para>为了充分发挥shell编程的威力, 
			  你必须精通正则表达式. 
	脚本中经常使用的某些命令, 和工具包通常都支持正则表达式, 
	比如<link linkend="grepref">grep</link>, <link
	linkend="exprref">expr</link>, <link linkend="sedref">sed</link>
	和<link linkend="awkref">awk</link>解释器. </para>



      <sect1><title>一份简要的正则表达式介绍</title>

		  <para>正则表达式就是由一系列特殊字符组成的字符串, 
			  其中每个特殊字符都被称为<emphasis>元字符</emphasis>, 
			  这些<emphasis>元字符</emphasis>并不表示为它们字面上的含义, 
			  而会被解释为一些特定的含义. 
	  具个例子, 比如引用符号, 可能就是表示某人的演讲内容, 
	  <emphasis>同上</emphasis>, 也可能表示为我们下面将要讲到的符号的元-含义. 
	  正则表达式其实是由普通字符和元字符共同组成的集合, 
	  这个集合用来匹配(或指定)模式. 
	  </para>
	
	<para>一个正则表达式会包含下列一项或多项: 
	</para>

        <itemizedlist>

	  <listitem>
		  <para><firstterm>一个字符集</firstterm>. 这里所指的字符集只包含普通字符, 
			  这些字符只表示它们的字面含义. 
			  正则表达式的最简单形式就是<emphasis>只</emphasis>包含字符集, 
			  而不包含元字符. </para>
	  </listitem>

	  <listitem>
		  <para><firstterm>锚</firstterm>. <emphasis>锚</emphasis>指定了正则表达式所要匹配的文本在文本行中所处的位置. 
	      比如, <token>^</token>, 和<token>$</token>就是锚. </para>
	  </listitem>

	  <listitem>
		  <para><firstterm>修饰符</firstterm>. 它们扩大或缩小(<emphasis>修改</emphasis>)了正则表达式匹配文本的范围. 
	      修饰符包含星号, 括号, 和反斜杠. 
	      </para>
	  </listitem>

        </itemizedlist>


		<para>正则表达式最主要的目的就是用于(<firstterm>RE</firstterm>)文本搜索与字符串操作. 
			(译者注: 以下正则表达式也会被简称为<emphasis>RE</emphasis>.)
			RE能够<firstterm>匹配</firstterm>单个字符或者一个字符集 -- 
		  即, 一个字符串, 或者一个字符串的一部分. 
	  </para>

	<itemizedlist>
	  <listitem>
	    <indexterm>
	      <primary>*</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>*</secondary>
	    </indexterm>

		<para>星号 -- <token>*</token> -- 用来匹配它前面字符的任意多次, 
	      <emphasis>包括0次</emphasis>. </para>

	    <para><quote>1133*</quote>匹配<replaceable>11 +
	      一个或多个3 + 也允许后边还有其他字符</replaceable>:
	      <replaceable>113</replaceable>, <replaceable>1133</replaceable>,
	      <replaceable>111312</replaceable>, 等等.</para>

	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>.</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>.</secondary>
	    </indexterm>

		<para><anchor id="regexdot">点 -- <token>.</token> -- 
				用于匹配任意一个字符, 除了换行符. 
	        <footnote><para>因为<link linkend="sedref">sed</link>, <link
		  linkend="awkref">awk</link>, 和<link
		  linkend="grepref">grep</link>通常用于处理单行, 
	  但是不能匹配一个换行符. 如果你想处理多行输入的话, 
		  那么你可以使用"点"来匹配换行符. 
	            <programlisting>#!/bin/bash

sed -e 'N;s/.*/[&]/' &lt;&lt; EOF   # Here Document
line1
line2
EOF
# 输出:
# [line1
# line2]



echo

awk '{ $0=$1 "\n" $2; if (/line.1/) {print}}' &lt;&lt; EOF
line 1
line 2
EOF
# 输出:
# line
# 1


# 感谢, S.C.

exit 0</programlisting></para></footnote>  
	    </para>

		<para><quote>13.</quote> 匹配<replaceable>13 + 
				至少一个任意字符(包括空格)</replaceable>: 
			<replaceable>1133</replaceable>,
			<replaceable>11333</replaceable>, 
			但不能匹配<replaceable>13</replaceable> 
			(因为缺少"."所能匹配的至少一个任意字符). </para>
	  </listitem>


	  <listitem>
	    <indexterm>
	      <primary>^</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>^</secondary>
	    </indexterm>
		<para>脱字符号 -- <token>^</token> -- 
			匹配行首, 但是某些时候需要依赖上下文环境, 
		在RE中, 有时候也表示对一个字符集取反. 
	    </para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>$</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>$</secondary>
	    </indexterm>
	    <para><anchor id="dollarsignref"></para>
	    <para>美元符 -- <token>$</token> -- 在RE中用来匹配行尾. </para>
	    <para><quote>XXX$</quote> 匹配行尾的<emphasis>XXX</emphasis>. </para>
	    <para><quote>^$</quote> 匹配空行. </para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>[...]</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>[...]</secondary>
	    </indexterm>

	    <para><anchor id="bracketsref"></para>
	    <para>中括号 -- <token>[...]</token> -- 在RE中, 将匹配中括号字符集中的某一个字符. </para>

		<para><quote>[xyz]</quote> 
			将会匹配字符<replaceable>x</replaceable>, 
			<replaceable>y</replaceable>,
	      或<replaceable>z</replaceable>. </para>

	  <para><quote>[c-n]</quote> 
		  匹配字符<replaceable>c</replaceable>到字符<replaceable>n</replaceable>之间的任意一个字符. </para>

	  <para><quote>[B-Pk-y]</quote> 
		  匹配从<replaceable>B</replaceable>到<replaceable>P</replaceable>, 
	      或者从<replaceable>k</replaceable>到<replaceable>y</replaceable>之间的任意一个字符. </para>

	    <para><quote>[a-z0-9]</quote> 匹配任意小写字母或数字. </para>

		<para><quote>[^b-d]</quote> 
			将会匹配范围在<replaceable>b</replaceable>到<replaceable>d</replaceable><emphasis>之外的</emphasis>任意一个字符. 
			这就是使用<token>^</token>对字符集取反的一个实例. 
	      (就好像在某些情况下, <token>!</token>所表达的含义). </para>

	    <para>将多个中括号字符集组合使用, 能够匹配一般的单词或数字. 
			<quote>[Yy][Ee][Ss]</quote>能够匹配<replaceable>yes</replaceable>, 
			<replaceable>Yes</replaceable>,
	      <replaceable>YES</replaceable>, <replaceable>yEs</replaceable>,
	      等等.
	      <quote>[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]</quote>
	      可以匹配社保码(Social Security number). </para>

	  </listitem>


	  <listitem>
	    <indexterm>
	      <primary>\</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>\</secondary>
	    </indexterm>

		<para>反斜杠 -- <token>\</token> -- 
			用来<link linkend="escp">转义</link>某个特殊含义的字符, 
			这意味着, 这个特殊字符将会被解释为字面含义. 
	      </para>

		  <para><quote>\$</quote>将会被解释成字符<quote>$</quote>, 
			  而不是RE中匹配行尾的特殊字符. 
	       相似的, <quote>\\</quote>将会被解释为字符<quote>\</quote>. </para>
	  </listitem>


	  <listitem>
	    <indexterm>
	      <primary>\&lt; \&gt;</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>\&lt; \&gt;</secondary>
	    </indexterm>

	    <para><anchor id="anglebrac"></para>
			<para><link linkend="escp">转义</link>的<quote>尖括号</quote> -- 
				<token>\&lt;...\&gt;</token> -- 用于匹配单词边界. </para>

	    <para>尖括号必须被转义才含有特殊的含义, 
	      否则它就表示尖括号的字面含义. </para>

	  <para><quote>\&lt;the\&gt;</quote> 
		  完整匹配单词<quote>the</quote>, 不会匹配<quote>them</quote>,
	      <quote>there</quote>, <quote>other</quote>, 等等. </para>

	    <para>
	      <screen>
<prompt>bash$ </prompt><userinput>cat textfile</userinput>
<computeroutput>This is line 1, of which there is only one instance.
 This is the only instance of line 2.
 This is line 3, another line.
 This is line 4.</computeroutput>


<prompt>bash$ </prompt><userinput>grep 'the' textfile</userinput>
<computeroutput>This is line 1, of which there is only one instance.
 This is the only instance of line 2.
 This is line 3, another line.</computeroutput>


<prompt>bash$ </prompt><userinput>grep '\&lt;the\&gt;' textfile</userinput>
<computeroutput>This is the only instance of line 2.</computeroutput>
	      </screen>
	    </para>

	  </listitem>

	</itemizedlist>

	<sidebar>
	  <para>要想确定一个RE能否正常工作, 唯一的办法就是测试它. </para>

          <para><programlisting>TEST FILE: tstfile                          # 不匹配.
                                            # 不匹配.
Run   grep "1133*"  on this file.           # 匹配.
                                            # 不匹配.
                                            # 不匹配.
This line contains the number 113.          # 匹配.
This line contains the number 13.           # 不匹配.
This line contains the number 133.          # 不匹配.
This line contains the number 1133.         # 匹配.
This line contains the number 113312.       # 匹配.
This line contains the number 1112.         # 不匹配.
This line contains the number 113312312.    # 匹配.
This line contains no numbers at all.       # 不匹配. </programlisting></para>

	      <screen><prompt>bash$ </prompt><userinput>grep "1133*" tstfile</userinput>
<computeroutput>Run   grep "1133*"  on this file.           # 匹配.
 This line contains the number 113.          # 匹配.
 This line contains the number 1133.         # 匹配.
 This line contains the number 113312.       # 匹配.
 This line contains the number 113312312.    # 匹配. </computeroutput>
	      </screen>

	</sidebar>

	<itemizedlist>

	  <listitem override="square">
	    <formalpara>
	      <title><anchor id="extregex">扩展的正则表达式</title>

	      <para>添加了一些额外的匹配字符到基本集合中. 
		用于<link linkend="egrepref">egrep</link>,
		<link linkend="awkref">awk</link>, 和<link
		linkend="perlref">Perl</link>.</para>

	      </formalpara>
	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>?</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>?</secondary>
	    </indexterm>

	    <para><anchor id="quexregex"></para>
	    <para>问号 -- <token>?</token> -- 匹配它前面的字符, 
	      但是只能匹配1次或0次. 通常用来匹配单个字符. </para>

	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>+</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>+</secondary>
	    </indexterm>

	    <para><anchor id="plusref"></para>
	    <para>加号 -- <token>+</token> -- 匹配它前面的字符, 
			能够匹配一次或多次. 与前面讲的<token>*</token>号作用类似, 
			但是<emphasis>不能</emphasis>匹配0个字符的情况. </para>

	    <para><programlisting># GNU版本的sed和awk能够使用"+",
# 但是它需要被转义一下. 

echo a111b | sed -ne '/a1\+b/p'
echo a111b | grep 'a1\+b'
echo a111b | gawk '/a1+b/'
# 上边3句的作用相同. 

# 感谢, S.C.</programlisting></para>

	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>\{ \}</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>\{ \}</secondary>
	    </indexterm>

		<para><link linkend="escp">转义</link><quote>大括号</quote> -- 
			<token>\{ \}</token> -- 在转义后的大括号中加上一个数字, 
			这个数字就是它前面的RE所能匹配的次数. 
	      </para>


	    <para>大括号必须经过转义, 否则, 大括号仅仅表示字面含意. 
	      这种用法并不是基本RE集合中的一部分, 仅仅是个技巧而以. 
	      </para>

	    <para><quote>[0-9]\{5\}</quote> 精确匹配5个数字
	      (所匹配的字符范围是0到9). </para>

	    <note>
			<para>使用大括号形式的RE是不能够在<quote>经典</quote>(非POSIX兼容)的<link linkend="awkref">awk</link>版本中正常运行的. 
				然而, <command>gawk</command>命令中有一个<option>--re-interval</option>选项, 
				使用这个选项就允许使用大括号形式的RE了(无需转义). </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>echo 2222 | gawk --re-interval '/2{3}/'</userinput>
<computeroutput>2222</computeroutput>
	      </screen>
	    </para>

	    <para><command>Perl</command>与某些版本的<command>egrep</command>不需要转义大括号. </para>

	      </note>

	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>()</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>()</secondary>
	    </indexterm>

		<para>圆括号 -- <command>( )</command> -- 
			括起一组正则表达式. 
			当你想使用<link linkend="exprref">expr</link>进行<link
				linkend="exprparen">子字符串提取(substring extraction)</link>的时候, 
			圆括号就有用了. 
			如果和下面要讲的<quote><token>|</token></quote>操作符结合使用, 
		   也非常有用. 
	      </para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>|</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>|</secondary>
	    </indexterm>

	    <para>竖线 -- <command>|</command> -- 就是RE中的<quote>或</quote>操作符, 
	      使用它能够匹配一组可选字符中的任意一个. </para>
	      <para>
	      <screen><prompt>bash$ </prompt><userinput>egrep 're(a|e)d' misc.txt</userinput>
<computeroutput>People who read seem to be better informed than those who do not.
 The clarinet produces sound by the vibration of its reed.</computeroutput>
	      </screen>
	      </para>
	  </listitem>

	</itemizedlist>

	    <note><para>与GNU工具一样, 某些版本的<command>sed</command>,
	      <command>ed</command>, 和<command>ex</command>一样能够支持扩展正则表达式, 
	      上边这部分就描述了扩展正则表达式. 
	      </para></note>


	<itemizedlist>

	  <listitem override="square">

	    <formalpara><title><anchor id="posixref">POSIX字符类</title>
	      <para><userinput>[:class:]</userinput></para></formalpara>

	    <indexterm>
	      <primary>[:</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>:]</secondary>
	    </indexterm>

	    <para>这是另外一种, 用于指定匹配字符范围的方法. 
	      </para>

	  </listitem>


	  <listitem>

	    <indexterm>
	      <primary>alnum</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>alphabetic numeric</secondary>
	    </indexterm>

		<para><userinput>[:alnum:]</userinput> 匹配字母和数字. 
			等价于<userinput>A-Za-z0-9</userinput>. </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>alpha</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>alphabetic</secondary>
	    </indexterm>

		<para><userinput>[:alpha:]</userinput> 匹配字母. 
	      等价于<userinput>A-Za-z</userinput>. </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>blank</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>space tab</secondary>
	    </indexterm>

	    <para><userinput>[:blank:]</userinput> 匹配一个空格或是一个制表符(tab). </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>cntrl</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>control</secondary>
	    </indexterm>

	    <para><userinput>[:cntrl:]</userinput> 匹配控制字符. </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>digit</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>decimal digit</secondary>
	    </indexterm>

	    <para><userinput>[:digit:]</userinput> 匹配(十进制)数字. 
	      等价于<userinput>0-9</userinput>. </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>graph</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>graph</secondary>
	    </indexterm>

		<para><userinput>[:graph:]</userinput> (可打印的图形字符). 
			匹配ASCII码值范围在33 - 126之间的字符. 
			与下面所提到的<userinput>[:print:]</userinput>类似, 
	      但是不包括空格字符(空格字符的ASCII码是32). </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>lower</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>lowercase</secondary>
	    </indexterm>

		<para><userinput>[:lower:]</userinput> 匹配小写字母. 
			等价于<userinput>a-z</userinput>. </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>print</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>printable</secondary>
	    </indexterm>

		<para><userinput>[:print:]</userinput> (可打印的图形字符). 
			匹配ASCII码值范围在32 - 126之间的字符.
	      与上边的<userinput>[:graph:]</userinput>类似, 
	      但是包含空格. </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>space</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>whitespace</secondary>
	    </indexterm>

	    <para><userinput>[:space:]</userinput> 匹配空白字符(空格和水平制表符). </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>upper</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>uppercase</secondary>
	    </indexterm>

		<para><userinput>[:upper:]</userinput> 匹配大写字母. 
			等价于<userinput>A-Z</userinput>. </para>

	  </listitem>

	  <listitem>

	    <indexterm>
	      <primary>xdigit</primary>
	    </indexterm>
	    <indexterm>
	      <primary>character range</primary>
	      <secondary>hexadecimal</secondary>
	    </indexterm>

	    <para><userinput>[:xdigit:]</userinput> 匹配16进制数字. 
	      等价于<userinput>0-9A-Fa-f</userinput>. </para>

            <important>

	    <para>POSIX字符类通常都要用引号或<link linkend="dblbrackets">双中括号</link>([[ ]])引起来. </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>grep [[:digit:]] test.file</userinput>
<computeroutput>abc=723</computeroutput>
	      </screen>
	    </para>

		<para>如果在一个受限的范围内, 
			这些字符类甚至可以用在<link
	      linkend="globbingref">通配(globbing)</link>中. 
	      </para>

	    <para>
	      <screen><prompt>bash$ </prompt><userinput>ls -l ?[[:digit:]][[:digit:]]?</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug 21 14:47 a33b</computeroutput>
	      </screen>
	    </para>

		<para>如果想了解POSIX字符类在脚本中的使用情况, 
	      请参考<xref linkend="ex49">和<xref linkend="lowercase">. </para>

	    </important>  

	  </listitem>

	</itemizedlist>


	<para><link linkend="sedref">Sed</link>, <link
	  linkend="awkref">awk</link>, 和<link
	  linkend="perlref">Perl</link>在脚本中一般都被用作过滤器, 
  这些过滤器将会以RE为参数, 对文件或者I/O流进行"过滤"或转换. 
	  请参考<xref linkend="behead">和<xref linkend="tree">, 
	  来详细了解这种用法. </para>

  <para>对于RE这个复杂的主题, 
	  标准的参考材料是Friedl的<citetitle 
		  pubwork="book">Mastering Regular Expressions</citetitle>. 
	  由Dougherty和Robbins所编写的<citetitle pubwork="book">Sed &
	  Awk</citetitle>这本书, 也对RE进行了清晰的论述. 
	  如果想获得这些书的更多信息, 请察看<xref linkend="biblio">. </para>

      </sect1> <!-- A Brief Introduction to Regular Expressions -->




      <sect1 id="globbingref">
	<title>通配(globbing)</title>

	<para>Bash本身并不会识别正则表达式. 
		在脚本中, 使用RE的是命令和工具 -- 
		比如<link linkend="sedref">sed</link>和<link
	  linkend="awkref">awk</link> -- 这些工具能够解释RE. </para>


	<para>Bash<emphasis>仅仅</emphasis>做的一件事是<firstterm>文件名扩展</firstterm>(译者注: 
		作者在前面使用的名词是filename globbing, 这里又使用filename expansion, 
		造成术语不统一, 希望读者不要产生误解.)

	    <footnote><para><firstterm>文件名扩展</firstterm>意味着扩展包含有特殊字符的文件名模式或模版. 
	    比如, <filename>example.???</filename>可能会被扩展成<filename>example.001</filename>或(和)<filename>example.txt</filename>. </para></footnote>
	  
		-- 这就是所谓的<firstterm>通配(globbing)</firstterm> -- 
		但是这里所使用的并<emphasis>不是</emphasis>标准的RE, 而是使用通配符. 
		通配(globbing)解释标准通配符, 
		<token>*</token>, <token>?</token>, 中括号扩起来的字符, 
		还有其他一些特殊字符(比如<token>^</token>用来表示取反匹配). 
		然而通配(globbing)所使用的通配符有很大的局限性. 
		包含<replaceable>*</replaceable>的字符串不能匹配以<quote>点</quote>开头的文件, 
	  比如, <filename>.bashrc</filename>. 

	    <footnote>
	    <para>
			文件名扩展<emphasis>能够</emphasis>匹配以<quote>点</quote>开头的文件, 
			但是, 你必须在模式字符串中明确的写上<quote>点</quote>(.), 才能够扩展. 
	        <programlisting>~/[.]bashrc    #  不能扩展成~/.bashrc
~/?bashrc      #  也不能扩展. 
               #  通配(globbing)中所使用的通配符
               #+ 和匹配字符串"不能"扩展"点". 

~/.[b]ashrc    #  可以扩展成~/.bashrc
~/.ba?hrc      #  也可以扩展.
~/.bashr*      #  也可以扩展.

# 可以设置"dotglob"选项, 把这个特性关闭. 

# 感谢, S.C.</programlisting>
	    </para>
	    </footnote>
	  
		另外, RE中所使用的<replaceable>?</replaceable>, 
		与通配(globbing)中所使用的<replaceable>?</replaceable>, 含义并不相同. </para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>ls -l</userinput>
<computeroutput>total 2
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l t?.sh</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l [ab]*</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l [a-c]*</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l [^ab]*</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</computeroutput>

<prompt>bash$ </prompt><userinput>ls -l {b*,c*,*est*}</userinput>
<computeroutput>-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</computeroutput>
	      </screen>
	      </para>



	  <para>Bash只能对未用引号引用起来的命令行参数进行文件名扩展. 
	    <link linkend="echoref">echo</link>命令可以印证这一点. </para>

	   <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo *</userinput>
<computeroutput>a.1 b.1 c.1 t2.sh test1.txt</computeroutput>

<prompt>bash$ </prompt><userinput>echo t*</userinput>
<computeroutput>t2.sh test1.txt</computeroutput>
	      </screen>
	   </para>

	  <note><para>Bash在通配(globbing)中解释特殊字符的行为是可以修改的. 
	    <command>set -f</command>命令可以禁用通配(globbing), 
	    而且<link linkend="shoptref">shopt</link>命令的选项<option>nocaseglob</option>和<option>nullglob</option>可以修改通配(globbing)的行为. 
	    </para></note>

	  <para>请参考<xref linkend="listglob">. </para>

      </sect1> <!-- Globbing -->


  </chapter> <!-- Regular Expressions -->



  <chapter id="subshells">
    <title>子shell</title>

      <para><anchor id="subshellsref"></para>

      <para>运行一个shell脚本的时候, 会启动命令解释器的另一个实例. 
        就好像你的命令是在命令行提示下被解释的一样, 
        类似于批处理文件中的一系列命令. 
        每个shell脚本都有效地运行在<link linkend="forkref">父</link>shell的一个子进程中. 
        这个<link linkend="forkref">父</link>shell指的是在一个控制终端或在一个<firstterm>xterm</firstterm>窗口中给出命令提示符的那个进程. </para>
	
      <para>shell脚本也能启动它自已的子进程. 
        这些<emphasis>子shell</emphasis>能够使脚本并行的, 
        有效的, 同时运行多个子任务. 
        </para>

      <sidebar>
		  <para>一般来说, 脚本中的<link linkend="externalref">外部命令</link>能够<link 
				  linkend="forkref">生成(fork)</link>一个子进程, 
			  然而Bash的<link linkend="builtinref">内建命令</link>却不会这么做. 
			  也正是由于这个原因, 内建命令比等价的外部命令要执行的快. 
		</para>
      </sidebar>

      <variablelist id="subshellparens">
	<title><anchor id="subshellparens1">圆括号中的命令列表</title>

	<varlistentry>
	  <term>( command1; command2; command3; ... )</term>
	<listitem>
		<para><replaceable>圆括号</replaceable>中命令列表的命令将会运行在一个子shell中. </para>
	</listitem>
	</varlistentry>
      </variablelist>

	  <note><para><anchor id="parvis">子shell中的变量对于子shell之外的代码块来说, 
				  是<emphasis>不</emphasis>可见的. 
          当然, <link linkend="forkref">父进程</link>也不能访问这些变量, 
          父进程指的是产生这个子shell的shell. 
          事实上, 这些变量都是<link linkend="localref">局部变量</link>. </para></note>

      <example id="subshell">
	<title>子shell中的变量作用域</title>
	<programlisting>&subshell;</programlisting>
      </example>
      <para>请参考<xref linkend="subpit">. </para>

      <para>+</para>

      <para>子shell中的目录更改不会影响到父shell. </para>

      <example id="allprofs">
	<title>列出用户的配置文件</title>
	<programlisting>&allprofs;</programlisting>
      </example>


      <para>子shell可用于为一组命令设置一个<quote>独立的临时环境</quote>. 
	      <programlisting>COMMAND1
COMMAND2
COMMAND3
(
  IFS=:
  PATH=/bin
  unset TERMINFO
  set -C
  shift 5
  COMMAND4
  COMMAND5
  exit 3 # 只是从子shell退出. 
)
# 父shell不受任何影响, 并且父shell的环境也没有被更改. 
COMMAND6
COMMAND7</programlisting>

            子shell的另一个应用, 是可以用来检测一个变量是否被定义. 
              <programlisting>if (set -u; : $variable) 2&gt; /dev/null
then
  echo "Variable is set."
fi     #  变量已经在当前脚本中被设置, 
       #+ 或者是一个Bash的内建变量, 
       #+ 或者是在当前环境下的一个可见变量(指已经被export的环境变量). 

# 也可以写成            [[ ${variable-x} != x || ${variable-y} != y ]]
# 或                    [[ ${variable-x} != x$variable ]]
# 或                    [[ ${variable+x} = x ]]
# 或                    [[ ${variable-x} != x ]]</programlisting>

            子shell还可以用来检测一个加锁的文件: 
	      <programlisting>if (set -C; : &gt; lock_file) 2&gt; /dev/null
then
  :   # lock_file不存在, 还没有用户运行这个脚本
else
  echo "Another user is already running that script."
exit 65
fi

#  这段程序由Stephane Chazelas所编写,
#+ Paulo Marcel Coelho Aragao做了一些修改. </programlisting>
      </para>   


      <para>进程在不同的子shell中可以并行地执行. 
        这样就可以把一个复杂的任务分成几个小的子问题来同时处理. 
        </para>

      <example id="parallel-processes">
	<title>在子shell中进行并行处理</title>
	<programlisting>
	(cat list1 list2 list3 | sort | uniq > list123) &
	(cat list4 list5 list6 | sort | uniq > list456) &
	# 列表的合并与排序同时进行. 
	# 放到后台运行可以确保能够并行执行. 
	#
	# 等效于
	#   cat list1 list2 list3 | sort | uniq > list123 &
	#   cat list4 list5 list6 | sort | uniq > list456 &
	
	wait   # 不再执行下面的命令, 直到子shell执行完毕. 
	
	diff list123 list456</programlisting>
	</example>

	<para>使用<quote>|</quote>管道操作符, 将I/O流重定向到一个子shell中, 
	  比如<userinput>ls -al | (command)</userinput>. </para>


	  <note><para>在<replaceable>大括号</replaceable>中的命令<emphasis>不会</emphasis>启动子shell. </para>
	  <para>{ command1; command2; command3; . . . commandN; }</para></note>


  </chapter> <!-- Subshells -->


    
  <chapter id="restricted-sh">
    <title>受限shell</title>

      <para><anchor id="restrictedshref"></para>

      <variablelist id="disabledcommref0">
        <title><anchor id="disabledcommref">在受限shell中禁用的命令</title>
	<varlistentry>
	  <term></term>
	  <listitem>
	  <formalpara><title></title>
		  <para>在<emphasis>受限</emphasis>模式下运行一个脚本或脚本片断, 
			  将会禁用某些命令, 这些命令在正常模式下都可以运行. 
			  这是一种安全策略, 目的是为了限制脚本用户的权限, 
			  并且能够让运行脚本所导致的危害降低到最小. 
      </para>
	  </formalpara>  
	  </listitem>
      </varlistentry>
        
      <varlistentry>
	  <term></term>
        <listitem>
	  <formalpara><title></title>

	  <para>使用<replaceable>cd</replaceable>命令更改工作目录. </para>
	  </formalpara>
	</listitem>
      </varlistentry>

      <varlistentry>
	  <term></term>
	<listitem>
	  <para>更改<link
	  linkend="envref">环境变量</link><replaceable>$PATH</replaceable>, 
	  <replaceable>$SHELL</replaceable>,
	  <replaceable>$BASH_ENV</replaceable>,
	  或<replaceable>$ENV</replaceable>的值. </para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	  <term></term>
	<listitem>
	  <para>读取或修改环境变量<replaceable>$SHELLOPTS</replaceable>的值. 
	  </para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	  <term></term>
	<listitem>
	  <para>输出重定向. </para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	  <term></term>
	<listitem>
	  <para>调用的命令路径中包括有一个或多个斜杠(<token>/</token>). </para>
	</listitem>
      </varlistentry>
	
	
      <varlistentry>
	  <term></term>
	<listitem>
		<para>调用<emphasis>exec</emphasis>, 
			把当前的受限shell替换成另外一个进程. 
	  </para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	  <term></term>
	<listitem>
	  <para>能够在无意中破坏脚本的命令. </para>
	</listitem>
      </varlistentry>
	
	
      <varlistentry>
	  <term></term>
	<listitem>
	  <para>在脚本中企图脱离受限模式的操作. </para>
	</listitem>  
      </varlistentry>

      </variablelist>	

      <example id="restricted">
	<title>在受限模式下运行脚本</title>
	<programlisting>&restricted;</programlisting>
      </example>

  </chapter> <!-- Restricted Shells -->




  <chapter id="process-sub">
    <title>进程替换</title>

      <para><anchor id="processsubref"><replaceable>进程替换</replaceable>与<link
				  linkend="commandsubref">命令替换</link>很相似. 
			  命令替换把一个命令的结果赋值给一个变量, 
	比如<command>dir_contents=`ls -al`</command>或<command>xref=$(
		grep word datafile)</command>. 
	进程替换把一个进程的输出提供给另一个进程(换句话说, 
	它把一个命令的结果发给了另一个命令). </para>

      <variablelist id="commandsparens">
        <title><anchor id="commandsparens1">命令替换的模版</title>

	<varlistentry>
	  <term>用圆括号扩起来的命令</term>

	<listitem>
	  <para><command>&gt;(command)</command></para>
	  <para><command>&lt;(command)</command></para>
	  <para>启动进程替换. 
		  它使用<filename>/dev/fd/&lt;n&gt;</filename>文件将圆括号中的进程处理结果发送给另一个进程. 
		  <footnote><para>这与<link linkend="namedpiperef">命名管道</link>(临时文件)具有相同的作用, 
		并且, 事实上, 命名管道也被同时使用在进程替换中. 
		</para></footnote>
		(译者注: 实际上现代的UNIX类操作系统提供的<filename>/dev/fd/n</filename>文件是与文件描述符相关的, 
		整数n指的就是进程运行时对应数字的文件描述符)
	  </para>

	  <note><para>在<quote><</quote>或<quote>></quote>与圆括号之间是<emphasis>没有</emphasis>空格的. 
            如果加了空格, 会产生错误. </para></note>

	</listitem>
	
	</varlistentry>
      </variablelist>


              <para>
	      <screen><prompt>bash$ </prompt><userinput>echo >(true)</userinput>
<computeroutput>/dev/fd/63</computeroutput>

<prompt>bash$ </prompt><userinput>echo <(true)</userinput>
<computeroutput>/dev/fd/63</computeroutput>
	      </screen>

		  Bash在两个<link linkend="fdref">文件描述符</link>之间创建了一个管道, 
		  <filename>--fIn</filename>和<filename>fOut--</filename>. 
		  <link linkend="trueref">true</link>命令的<filename>stdin</filename>被连接到<filename>fOut</filename> (dup2(fOut, 0)), 
		  然后Bash把<filename>/dev/fd/fIn</filename>作为参数传给<command>echo</command>. 
		  如果系统缺乏<filename>/dev/fd/&lt;n&gt;</filename>文件, 
		  Bash会使用临时文件. (感谢, S.C.)</para>


	  <para>进程替换可以比较两个不同命令的输出, 
		  甚至能够比较同一个命令不同选项情况下的输出. 
	       </para>

	 <screen><prompt>bash$ </prompt><userinput>comm <(ls -l) <(ls -al)</userinput>
<computeroutput>total 12
-rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
-rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
-rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh
        total 20
        drwxrwxrwx    2 bozo bozo     4096 Mar 10 18:10 .
        drwx------   72 bozo bozo     4096 Mar 10 17:58 ..
        -rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
        -rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
        -rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh</computeroutput></screen>

	      <para>
			  使用进程替换来比较两个不同目录的内容(可以查看哪些文件名相同, 
			  哪些文件名不同): 
		<programlisting>diff <(ls $first_directory) <(ls $second_directory)</programlisting>
              </para>

              <para>一些进程替换的其他用法与技巧: </para>

      <para><programlisting>cat <(ls -l)
# 等价于     ls -l | cat

sort -k 9 <(ls -l /bin) <(ls -l /usr/bin) <(ls -l /usr/X11R6/bin)
# 列出系统3个主要'bin'目录中的所有文件, 并且按文件名进行排序. 
# 注意是3个(查一下, 上面就3个圆括号)明显不同的命令输出传递给'sort'. 

 
diff <(command1) <(command2)    # 给出两个命令输出的不同之处. 

tar cf >(bzip2 -c > file.tar.bz2) $directory_name
# 调用"tar cf /dev/fd/?? $directory_name", 和"bzip2 -c > file.tar.bz2".
#
# 因为/dev/fd/&lt;n&gt;的系统属性, 
# 所以两个命令之间的管道不必被命名. 
#
# 这种效果可以被模拟出来. 
#
bzip2 -c < pipe > file.tar.bz2&
tar cf pipe $directory_name
rm pipe
#        或
exec 3>&1
tar cf /dev/fd/4 $directory_name 4>&1 >&3 3>&- | bzip2 -c > file.tar.bz2 3>&-
exec 3>&-


# 感谢, Stephane Chazelas</programlisting></para>


      <para>一个读者给我发了一个有趣的例子, 是关于进程替换的, 如下. 
        </para>

      <para><programlisting># 摘自SuSE发行版中的代码片断: 

while read  des what mask iface; do
# 这里省略了一些命令...
done < <(route -n)  


# 为了测试它, 我们让它做点事. 
while read  des what mask iface; do
  echo $des $what $mask $iface
done < <(route -n)  

# 输出: 
# Kernel IP routing table
# Destination Gateway Genmask Flags Metric Ref Use Iface
# 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo



# 就像Stephane Chazelas所给出的那样, 一个更容易理解的等价代码是: 
route -n |
  while read des what mask iface; do   # 管道的输出被赋值给了变量. 
    echo $des $what $mask $iface
  done  #  这将产生出与上边相同的输出. 
        #  然而, Ulrich Gayer指出 . . .
        #+ 这个简单的等价版本在while循环中使用了一个子shell, 
        #+ 因此当管道结束后, 变量就消失了. 
	

	
#  更进一步, Filip Moritz解释了上面两个例子之间存在一个细微的不同之处, 
#+ 如下所示. 

(
route -n | while read x; do ((y++)); done
echo $y # $y 仍然没有被声明或设置

while read x; do ((y++)); done < <(route -n)
echo $y # $y 的值为route -n的输出行数. 
)

# 一般来说, (译者注: 原书作者在这里并未加注释符号"#", 应该是笔误)
(
: | x=x
# 看上去是启动了一个子shell
: | ( x=x )
# 但
x=x < <(:)
# 其实不是
)

# 当你要解析csv或类似东西的时侯, 这非常有用. 
# 事实上, 这就是SuSE的这个代码片断所要实现的功能. </programlisting></para>



  </chapter> <!-- Process Substitution -->




  <chapter id="functions">
    <title>函数</title>

      <para><anchor id="functionref"></para>
      
      <para>与<quote>真正的</quote>编程语言一样, 
	Bash也有函数, 虽然在某些实现方面稍有限制. 
	一个函数就是一个子程序, 
	用于实现一系列操作的<link linkend="codeblockref">代码块</link>, 
	它是完成特定任务的<quote>黑盒子</quote>. 
	当存在重复代码的时候, 或者当一个任务只需要轻微修改就被重复使用的时候, 
	你就需要考虑使用函数了. 
	</para>

      <para><cmdsynopsis>
	  <command>function</command>
	  <arg choice="plain"><replaceable>function_name</replaceable></arg> 
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
	或
	<cmdsynopsis>
	  <arg choice="plain"><replaceable>function_name</replaceable></arg> 
	  <arg choice="plain">()</arg>
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
      </para>

      <para>C程序员肯定会更加喜欢第二中格式的写法(并且这种写法可移植性更好). </para>

      <para>在C中, 函数的左大括号也可以写在下一行中. </para>

      <para><cmdsynopsis>
	  <arg choice="plain"><replaceable>function_name</replaceable></arg> 
	  <arg choice="plain">()</arg><sbr>
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
      </para>

      <para>只需要简单的调用函数名, 函数就会被调用或<firstterm>触发</firstterm>. </para>

      <example id="ex59">
	<title>简单函数</title>
	<programlisting>&ex59;</programlisting>
      </example>

      <para>函数定义必须在第一次调用函数之前完成. 
	没有像C中函数<quote>声明</quote>的方法. 
	  <programlisting>f1
# 因为函数"f1"还没有被定义, 这会产生一个错误. 

declare -f f1      # 这样也没用. 
f1                 # 仍然会引起错误. 

# 然而...

	  
f1 ()
{
  echo "Calling function \"f2\" from within function \"f1\"."
  f2
}

f2 ()
{
  echo "Function \"f2\"."
}

f1  #  虽然在f2在定义前被引用过, 
    #+ 实际上f2到这儿才被调用. 
    #  所以这么做是正常的. 
    
    # 感谢, S.C.</programlisting>
      </para>

      <para>甚至可以在一个函数内嵌套另一个函数, 虽然这么做并没有多大用处. 
	  <programlisting>f1 ()
{

  f2 () # nested
  {
    echo "Function \"f2\", inside \"f1\"."
  }

}  

f2  #  产生一个错误. 
    #  即使你先写出"declare -f f2"也没用. 

echo    

f1  #  什么事都没干, 因为调用"f1"并不会自动调用"f2". 
f2  #  现在, 可以正确的调用"f2"了, 
    #+ 因为之前调用"f1"使"f2"在脚本中变得可见了. 

    # 感谢, S.C.</programlisting>
      </para>
      
	  <para>函数声明可以出现在看上去不可能出现的地方, 
		  比如说本应出现命令的地方, 也可以出现函数声明. 
          <programlisting>ls -l | foo() { echo "foo"; }  # 可以这么做, 但没什么用. 



if [ "$USER" = bozo ]
then
  bozo_greet ()   # 在if/then结构中定义了函数. 
  {
    echo "Hello, Bozo."
  }
fi  

bozo_greet        # 只能由Bozo运行, 其他用户使用的话, 会引起错误. 



# 在某些上下文中, 这样做可能会有用. 
NO_EXIT=1   # 将会打开下面的函数定义. 

[[ $NO_EXIT -eq 1 ]] && exit() { true; }     # 在"与列表"中定义函数. 
# 如果$NO_EXIT为1, 那就声明"exit ()". 
# 把"exit"化名为"true", 将会禁用内建的"exit"命令. 

exit  # 这里调用的是"exit ()"函数, 而不是"exit"内建命令. 

# 感谢, S.C.</programlisting>
      </para>


      <sect1 id="complexfunct">
        <title>复杂函数和函数复杂性</title>

		<para>函数可以处理传递给它的参数, 
			并且能返回它的<link linkend="exitstatusref">退出状态码</link>给脚本, 以便后续处理. </para>

      <programlisting>function_name $arg1 $arg2</programlisting>

	  <para>函数以位置来引用传递过来的参数(就好像它们是<link 
			  linkend="posparamref">位置参数</link>), 
	例如, <varname>$1</varname>, <varname>$2</varname>, 等等. </para>

      <example id="ex60">
	<title>带参数的函数</title>
	<programlisting>&ex60;</programlisting>
      </example>

      <important><para>也可以使用<link linkend="shiftref">shift</link>命令来处理传递给函数的参数(请参考<xref
	linkend="multiplication">). </para></important>

      <para>但是, 传给脚本的命令行参数怎么办? 
		  在函数内部, 这些传给脚本的命令行参数也可见么? 
		  好, 现在让我们弄清楚这个问题. </para>

      <example id="funccmdlinearg">
	<title>函数与传递给脚本的命令行参数</title>
	<programlisting>&funccmdlinearg;</programlisting>
      </example>


      <para>与别的编程语言相比, shell脚本一般只会传值给函数. 
		  如果把变量名(事实上就是指针)作为参数传递给函数的话, 
		  那将被解释为字面含义, 也就是被看作字符串. 
	<emphasis>函数只会以字面含义来解释函数参数. </emphasis></para>

	<para><link linkend="ivrref">变量的间接引用</link>(请参考<xref linkend="ex78">)提供了一种笨拙的机制, 来将变量指针传递给函数. 
	    </para>

	    <example id="indfunc">
	      <title>将一个间接引用传递给函数</title>
	      <programlisting>&indfunc;</programlisting>
	    </example>

		<para>接下来的一个逻辑问题就是, 
			将参数传递给函数<emphasis>之后</emphasis>, 
			参数能否被解除引用. 
	  </para>

	    <example id="dereferencecl">
	      <title>对一个传递给函数的参数进行解除引用的操作</title>
	      <programlisting>&dereferencecl;</programlisting>
	    </example>

	    <example id="refparams">
	      <title>再来一次, 对一个传递给函数的参数进行解除引用的操作</title>
	      <programlisting>&refparams;</programlisting>
	    </example>


      <variablelist id="exitreturn">
        <title><anchor id="exitreturn1">退出与返回</title>

	<varlistentry>
	  <term><command>退出状态码</command></term>
	  <listitem>
		  <para>函数返回一个值, 被称为<firstterm>退出状态码</firstterm>. 
			  退出状态码可以由<command>return</command>命令明确指定, 
	      也可以由函数中最后一条命令的退出状态码来指定(如果成功则返回<returnvalue>0</returnvalue>, 
		  否则返回非0值). 
		  可以在脚本中使用<link linkend="xstatvarref">$?</link>来引用<link linkend="exitstatusref">退出状态码</link>. 
		  因为有了这种机制, 
		  所以脚本函数也可以象C函数一样有<quote>返回值</quote>. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>return</command></term>
	  <indexterm>
	    <primary>return</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>return</secondary>
	  </indexterm>
	  <listitem>
            <para><anchor id="returnref"></para>
	    <para>终止一个函数. <command>return</command>命令
			<footnote><para><command>return</command>命令是Bash<link 
						linkend="builtinref">内建命令builtin</link>. 
			</para></footnote>
	      可选的允许带一个<emphasis>整型</emphasis>参数, 
		  这个整数将作为函数的<quote>退出状态码</quote>返回给调用这个函数的脚本, 
		  并且这个整数也被赋值给变量<link
	      linkend="xstatvarref">$?</link>. </para>

	    <example id="max">
	      <title>取两个数中的最大值</title>
	      <programlisting>&max;</programlisting>
	    </example>

	    <tip>
			<para>为了让函数可以返回字符串或是数组, 
				可以使用一个在函数外可见的专用全局变量. 
	        <programlisting>count_lines_in_etc_passwd()
{
  [[ -r /etc/passwd ]] && REPLY=$(echo $(wc -l < /etc/passwd))
  #  如果/etc/passwd是可读的, 那么就把REPLY设置为文件的行数. 
  #  这样就可以同时返回参数值与状态信息. 
  #  'echo'看上去没什么用, 可是 . . .
  #+ 它的作用是删除输出中的多余空白字符. 
}

if count_lines_in_etc_passwd
then
  echo "There are $REPLY lines in /etc/passwd."
else
  echo "Cannot count lines in /etc/passwd."
fi  

# 感谢, S.C.</programlisting>
	    </para>
	    </tip>




	    <example id="ex61">
	      <title>将阿拉伯数字转化为罗马数字</title>
	      <programlisting>&ex61;</programlisting>
	    </example>

	    <para>也请参考<xref linkend="isalpha">. </para>

	    <important>

			<para>函数所能返回最大的正整数是255. 
			<command>return</command>命令与<link linkend="exitstatusref">退出状态码</link>的概念被紧密联系在一起, 并且退出状态码的值受此限制. 
	      幸运的是, 如果想让函数返回大整数的话, 有好多种不同的<link
	      linkend="rvt">工作区</link>能够应付这个情况. 
	      </para>


	    <example id="returntest">
	      <title>测试函数最大的返回值</title>
	      <programlisting>&returntest;</programlisting>
	    </example>


		<para>如果你想获得大整数<quote>返回值</quote>的话, 
			其实最简单的办法就是将<quote>要返回的值</quote>保存到一个全局变量中.

	        <programlisting>Return_Val=   # 用于保存函数特大返回值的全局变量. 

alt_return_test ()
{
  fvar=$1
  Return_Val=$fvar
  return   # 返回0 (成功). 
}

alt_return_test 1
echo $?                              # 0
echo "return value = $Return_Val"    # 1

alt_return_test 256
echo "return value = $Return_Val"    # 256

alt_return_test 257
echo "return value = $Return_Val"    # 257

alt_return_test 25701
echo "return value = $Return_Val"    #25701</programlisting>
            </para>


			<para>一种更优雅的做法是在函数中使用<command>echo</command>命令将<quote>返回值输出到<filename>stdout</filename></quote>, 
			然后使用<link linkend="commandsubref">命令替换</link>来捕捉此值. 
			请参考<xref linkend="assortedtips">中<link linkend="rvt">关于这种用法的讨论</link>. </para>

	    <example id="max2">
	      <title>比较两个大整数</title>
	      <programlisting>&max2;</programlisting>
	    </example>

		<para>这是另一个能够捕捉函数<quote>返回值</quote>的例子. 
			要想搞明白这个例子, 需要一些<link 
				linkend="awkref">awk</link>的知识. 

	    <programlisting>month_length ()  # 把月份作为参数. 
{                # 返回该月包含的天数. 
monthD="31 28 31 30 31 30 31 31 30 31 30 31"  # 作为局部变量声明? 
echo "$monthD" | awk '{ print $'"${1}"' }'    # 小技巧. 
#                             ^^^^^^^^^
# 传递给函数的参数($1 -- 月份号), 然后传给awk. 
# Awk把参数解释为"print $1 . . . print $12"(这依赖于月份号)
# 这是一个模版, 用于将参数传递给内嵌awk的脚本: 
#                                 $'"${script_parameter}"'

#  需要做一些错误检查, 来保证月份号正确, 在范围(1-12)之间, 
#+ 别忘了检查闰年的二月. 
}

# ----------------------------------------------
# 用例:
month=4        # 以四月为例. 
days_in=$(month_length $month)
echo $days_in  # 30
# ----------------------------------------------</programlisting></para>


	    <para>也请参考<xref linkend="daysbetween">. </para>

	    <para><userinput>练习:</userinput> 使用目前我们已经学到的知识, 
	      来扩展之前的例子<link
			  linkend="ex61">将阿拉伯数字转化为罗马数字</link>, 
		 让它能够接受任意大的输入. </para>

	    </important>

	  </listitem>
	</varlistentry>
      </variablelist>


      <variablelist id="redstdinfunc">
        <title><anchor id="redstdinfunc1">重定向</title>

	<varlistentry>
	  <term><replaceable>重定向函数的stdin</replaceable></term>
	  <indexterm>
	    <primary>redirection</primary>
	    <secondary>stdin</secondary>
	  </indexterm>
	  <listitem>

	    <para>函数本质上其实就是一个<link
				linkend="codeblockref">代码块</link>, 
			这就意味着它的<filename>stdin</filename>可以被重定向(比如<xref
	      linkend="ex8">). </para>

	    <example id="realname">
	      <title>从username中取得用户的真名</title>
	      <programlisting>&realname;</programlisting>
	    </example>

		<para>还有一个办法, 或许能够更好的理解重定向函数的<filename>stdin</filename>. 
			它在函数内添加了一对大括号, 
			并且将重定向<filename>stdin</filename>的行为放在这对添加的大括号上. 

	       <programlisting># 用下面的方法来代替它:
Function ()
{
 ...
 } < file

# 试试这个: 
Function ()
{
  {
    ...
   } < file
}

# 同样的,

Function ()  # 没问题.
{
  {
   echo $*
  } | tr a b
}

Function ()  # 不行. 
{
  echo $*
} | tr a b   # 这儿的内嵌代码块是被强制的. 


# 感谢, S.C.</programlisting>
           </para>

	  </listitem>
	</varlistentry>

      </variablelist>

      </sect1> <!-- Complex Functions and Function Complexities -->



      <sect1 id="localvar">
        <title>局部变量</title>

      <variablelist id="localref">
		  <title><anchor id="localref1">怎样使一个变量变成<quote>局部</quote>变量? </title>

	<varlistentry>
	  <term>局部变量</term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>local</secondary>
	  </indexterm>
	  <listitem>
	    <para>如果变量用<firstterm>local</firstterm>来声明, 
	      那么它就只能够在该变量被声明的<link
	      linkend="codeblockref">代码块</link>中可见. 
		  这个代码块就是局部<quote>范围</quote>. 
		  在一个函数中, 一个<emphasis>局部变量</emphasis>只有在函数代码块中才有意义. 
	      </para>

	    <example id="ex62">
	      <title>局部变量的可见范围</title>
	      <programlisting>&ex62;</programlisting>
	    </example>

	    <caution>
			<para>在函数被调用之前, <emphasis>所有</emphasis>在函数中声明的变量, 
				在函数体外都是不可见的, 当然也包括那些被明确声明为<emphasis>local</emphasis>的变量. 
	        <programlisting>#!/bin/bash

func ()
{
global_var=37    #  在函数被调用之前, 
                 #+ 变量只在函数体内可见.  
}                #  函数结束

echo "global_var = $global_var"  # global_var =
                                 #  函数"func"还没被调用, 
                                 #+ 所以$global_var还不能被访问. 

func
echo "global_var = $global_var"  # global_var = 37
                                 # 已经在函数调用的时候设置了变量的值. </programlisting>
            </para>
	    </caution>

	  </listitem>
	</varlistentry>

      </variablelist>

      <sect2 id="locvarrecur">
        <title>局部变量使递归变为可能. </title>

	    <para>局部变量允许递归, 

	      <footnote>
	      <para><anchor id="recursionref">
	        <link linkend="mayerref">Herbert Mayer</link>
		给<emphasis>递归</emphasis>下的定义为: 
		<quote>. . . expressing an algorithm by using a simpler
			version of that same algorithm(使用相同算法的一个简单版本来表达这个算法) . . .</quote> 
		一个递归函数就是调用自身的函数. 
		</para></footnote>

		但是这种方法会产生大量的计算, 因此在shell脚本中, 
		非常明确的<emphasis>不</emphasis>推荐这种做法. 

	         <footnote><para>过多层次的递归可能会产生段错误, 继而导致脚本崩溃. 
		   <programlisting>#!/bin/bash

#  警告: 运行这个脚本可能使你的系统失去响应! 
#  如果你运气不错, 在它用光所有可用内存之前会因为段错误而退出. 

recursive_function ()		   
{
echo "$1"     # 让这个函数做点事, 以便于加速段错误. 
(( $1 < $2 )) && recursive_function $(( $1 + 1 )) $2;
#  当第一个参数比第二个参数少时, 
#+ 将第一个参数加1, 然后再递归. 
}

recursive_function 1 50000  # Recurse 50,000 levels!
#  极有可能产生段错误(这依赖于栈尺寸, 可以用ulimit -m来设置). 

#  这种深度递归可能会产生C程序的段错误, 
#+ 这是由于耗光所有的栈内存所引起的. 


echo "This will probably not print."
exit 0  # 这个脚本是不会在这里正常退出的. 

#  感谢, Stephane Chazelas.</programlisting>
</para></footnote>
	      
	      </para>

	    <example id="ex63">
	      <title>使用局部变量的递归</title>
	      <programlisting>&ex63;</programlisting>
	    </example>

		<para>也可以参考<xref linkend="primes">, 
			这是一个脚本中递归的例子. 
	      必须认识到递归同时也意味着巨大的资源消耗和缓慢的运行速度, 
	      因此它并不适合在脚本中使用. 
	      </para>

      </sect2>
      </sect1> <!-- Local Variables -->



      <sect1 id="recurnolocvar">
        <title>不使用局部变量的递归</title>

            <para>即使不使用局部变量, 函数也可以递归的调用自身. 
	      </para>

	    <example id="hanoi">
	      <title>汉诺塔</title>
	      <programlisting>&hanoi;</programlisting>
	    </example>

      </sect1> <!-- Recursion Without Local Variables -->



  </chapter> <!-- Functions -->



  <chapter id="aliases">
    <title>别名</title>

      <para><anchor id="aliasref"></para>

      <indexterm>
        <primary>alias</primary>
      </indexterm>

      <para>Bash<emphasis>别名</emphasis>本质上来说不过就是个简称, 缩写, 
	是一种避免输入长命令序列的手段. 
	举个例子, 如果我们添加<command>alias lm="ls -l | more"</command>到文件<link 
		linkend="filesref1"><filename>~/.bashrc</filename></link>中, 
	那么每次在命令行中键入<userinput>lm</userinput>就可以自动转换为 <command>ls -l | more</command>. 
	这可以让你在命令行上少敲好多次, 
	而且也可以避免记忆复杂的命令和繁多的选项. 
	设置<command>alias rm="rm -i"</command>(删除的时候提示), 
	可以让你在犯了错误之后也不用悲伤, 
	因为它可以让你避免意外删除重要文件. </para>

      <para>在脚本中, 别名就没那么重要了. 
	如果把别名机制想象成C预处理器的某些功能的话, 就很形象, 比如说宏扩展, 
	但不幸的是, Bash不能在别名中扩展参数. 
	  <footnote><para>然而, 别名好像能够扩展位置参数. </para></footnote>
	  而且在脚本中, 别名不能够用在<quote>混合型结构</quote>中, 
	  比如<link linkend="ifthen">if/then</link>结构, 循环, 
	  和函数. 还有一个限制, 别名不能递归扩展. 
	绝大多数情况下, 我们期望别名能够完成的工作, 
	都能够用<link linkend="functionref">函数</link>更高效的完成. </para>

    <example id="al">
      <title>用在脚本中的别名</title>
      <programlisting>&al;</programlisting>
    </example>

    <para><command>unalias</command>命令用来删除之前设置的<emphasis>别名</emphasis>. </para>

    <example id="unal">
      <title><command>unalias</command>: 设置与删除别名</title>
      <programlisting>&unal;</programlisting>
    </example>

	    <screen><prompt>bash$ </prompt><userinput>./unalias.sh</userinput>
<computeroutput>
total 6
drwxrwxr-x    2 bozo     bozo         3072 Feb  6 14:04 .
drwxr-xr-x   40 bozo     bozo         2048 Feb  6 14:04 ..
-rwxr-xr-x    1 bozo     bozo          199 Feb  6 14:04 unalias.sh

./unalias.sh: llm: command not found
</computeroutput></screen>


  </chapter> <!-- Aliases -->




  <chapter id="list-cons">
    <title>列表结构</title>

      <para><anchor id="listconsref"></para>

      <indexterm>
	<primary>&&</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>&&</secondary>
      </indexterm>
      <indexterm>
	<primary>AND</primary>
	<secondary>list</secondary>
      </indexterm>
      <indexterm>
	<primary>||</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>||</secondary>
      </indexterm>
      <indexterm>
	<primary>OR</primary>
	<secondary>list</secondary>
      </indexterm>

      <para><quote>与列表</quote>和<quote>或列表</quote>结构能够提供一种手段, 
	这种手段能够用来处理一串连续的命令. 
	这样就可以有效的替换掉嵌套的<command>if</command>/<command>then</command>结构, 
	甚至能够替换掉<command>case</command>语句. </para>
	

      <variablelist id="lcons">
        <title><anchor id="lcons1">把命令连接到一起</title>

	<varlistentry>
	  <term>与列表</term>
	  <listitem>
	    <para><programlisting>command-1 && command-2 && command-3 && ... command-n</programlisting>
			如果每个命令执行后都返回<returnvalue>true</returnvalue>(0)的话, 
			那么命令将会依次执行下去. 
			如果其中的某个命令返回<returnvalue>false</returnvalue>(非零值)的话, 
			那么这个命令链就会被打断, 也就是结束执行, 
			(那么第一个返回<returnvalue>false</returnvalue>的命令, 
		   就是最后一个执行的命令, 其后的命令都不会执行). </para>



	    <example id="ex64">
	      <title>使用<quote>与列表</quote>来测试命令行参数</title>
	      <programlisting>&ex64;</programlisting>
	    </example>

	    <example id="andlist2">
	      <title>使用<quote>与列表</quote>来测试命令行参数的另一个例子</title>
	      <programlisting>&andlist2;</programlisting>
	    </example>

            <para><anchor id="anddefault"></para>
            <para>
	      当然, <emphasis>与列表</emphasis>也可以给变量<emphasis>设置</emphasis>默认值. 
	        <programlisting>arg1=$@       # 不管怎样, 将$arg1设置为命令行参数. 

[ -z "$arg1" ] && arg1=DEFAULT
              # 如果没有指定命令行参数, 则把$arg1设置为DEFAULT. </programlisting>
            </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>或列表</term>
	  <listitem>
	    <para><programlisting>command-1 || command-2 || command-3 || ... command-n</programlisting>
			如果每个命令都返回<returnvalue>false</returnvalue>, 
			那么命令链就会执行下去. 
			一旦有一个命令返回<returnvalue>true</returnvalue>, 
			命令链就会被打断, 也就是结束执行, 
			(第一个返回<returnvalue>true</returnvalue>的命令将会是最后一个执行的命令). 
			显然, 这和<quote>与列表</quote>完全相反. </para>

	    <example id="ex65">
	      <title>将<quote>或列表</quote>和<quote>与列表</quote>结合使用</title>
	      <programlisting>&ex65;</programlisting>
	    </example>

		<caution><para>如果<quote>或列表</quote>中的第一个命令返回<returnvalue>true</returnvalue>, 
				那么, <quote>或列表</quote>中的第一个命令还是<replaceable>会</replaceable>执行. </para></caution>

	  </listitem>
	</varlistentry>

	</variablelist>


	    <para><programlisting># ==> 下面的片断摘自于脚本/etc/rc.d/init.d/single, 这个脚本由Miquel van Smoorenburg所编写. 
#+==> 用于展示"与"/"或"列表的使用. 
# ==> "箭头"注释是由本书作者添加的. 

[ -x /usr/bin/clear ] && /usr/bin/clear
  # ==> 如果/usr/bin/clear存在, 那么就调用它. 
  # ==> 在调用一个命令前, 检查一下它是否存在. 
  #+==> 这样可以避免错误信息, 和其他愚蠢的结果. 

  # ==> . . .

# 如果他们想在单用户模式下运行某些程序, 可能也会运行它...
for i in /etc/rc1.d/S[0-9][0-9]* ; do
        # 检查一下脚本是否在那里. 
        [ -x "$i" ] || continue
  # ==> 如果在$PWD中没发现相应的文件, 
  #+==> 则会使用"continue"跳过本次循环. 

        # 不接受备份文件, 也不接受由rpm产生的文件. 
        case "$1" in
                *.rpmsave|*.rpmorig|*.rpmnew|*~|*.orig)
                        continue;;
        esac
        [ "$i" = "/etc/rc1.d/S00single" ] && continue
  # ==> 设置脚本名, 但现在还不执行它. 
        $i start
done

  # ==> . . .</programlisting></para>


	<important><para><userinput>与列表</userinput>和<userinput>或列表</userinput>的<link 
		linkend="exitstatusref">退出状态码</link>由最后一个命令的退出状态所决定. 
	  </para></important>

	  <para>可以灵活的将<quote>与</quote>/<quote>或</quote>列表组合在一起, 
	但是这么做的话, 会使得逻辑变得很复杂, 并且需要经过仔细的测试. 
	  <programlisting>false && true || echo false         # false

# 与下面的结果相同
( false && true ) || echo false     # false
# But *not*
false && ( true || echo false )     # (没有输出)

#  注意, 以从做到右的顺序进行分组与求值, 
#+ 这是因为逻辑操作符"&&"和"||"具有相同的优先级. 

#  最好避免这么复杂的情况, 除非你非常了解你到底在做什么. 

#  感谢, S.C.</programlisting>
	</para>

	<para>也请参考<xref linkend="daysbetween">和<xref linkend="brokenlink">, 
	这两个例子展示了如何使用<userinput>与/或列表</userinput>来测试变量. </para>


  </chapter> <!-- List Constructs -->




  <chapter id="arrays">
    <title>数组</title>

      <para><anchor id="arrayref"></para>

      <para>新版本的Bash支持一维数组. 
	数组元素可以使用符号<userinput>variable[xx]</userinput>来初始化. 
	另外, 脚本可以使用<userinput>declare -a variable</userinput>语句来指定一个数组. 
	如果想解引用一个数组元素(也就是取值), 
	可以使用<firstterm>大括号</firstterm>, 
	访问形式为<userinput>${variable[xx]}</userinput>. </para>

      <example id="ex66">
	<title>简单的数组使用</title>
	<programlisting>&ex66;</programlisting>
      </example>


	  <note><para>Bash允许把变量当成数组来操作, 
		即使这个变量没有明确地被声明为数组. 
	  <programlisting>string=abcABC123ABCabc
echo ${string[@]}               # abcABC123ABCabc
echo ${string[*]}               # abcABC123ABCabc 
echo ${string[0]}               # abcABC123ABCabc
echo ${string[1]}               # 没有输出! 
                                # 为什么? 
echo ${#string[@]}              # 1
                                # 数组中只有一个元素. 
                                # 就是这个字符串本身. 

# 感谢, Michael Zick, 指出这一点. </programlisting>
      类似的示范可以参考<link linkend="bvuntyped">Bash变量是无类型的</link>. 
      </para></note>


      <example id="poem">
	<title>格式化一首诗</title>
	<programlisting>&poem;</programlisting>
      </example>

      <para>数组元素有它们独特的语法, 
	甚至标准Bash命令和操作符, 都有特殊的选项用以配合数组操作. 
	</para>

      <example id="arrayops">
	<title>多种数组操作</title>
	<programlisting>&arrayops;</programlisting>
      </example>

      <para>大部分标准<link linkend="stringmanip">字符串操作</link>都可以用于数组中. </para>

      <example id="arraystrops">
	<title>用于数组的字符串操作</title>
	<programlisting>&arraystrops;</programlisting>
      </example>


	  <para><link linkend="commandsubref">命令替换</link>可以构造数组的独立元素. 
		  (译者注: 换句话说, 就是命令替换也能够给数组赋值.) </para>
      
      <example id="scriptarray">
	<title>将脚本的内容赋值给数组</title>
	<programlisting>&scriptarray;</programlisting>
      </example>

      <para>在数组环境中, 某些Bash<link
	linkend="builtinref">内建命令</link>的含义可能会有些轻微的改变. 
	比如, <link linkend="unsetref">unset</link>命令可以删除数组元素, 
	甚至能够删除整个数组. </para>

      <example id="ex67">
	<title>一些数组专用的小道具</title>
	<programlisting>&ex67;</programlisting>
      </example>

      <para>正如我们在前面例子中所看到的, 
	<command>${array_name[@]}</command>或<command>${array_name[*]}</command>都与数组中的<emphasis>所有</emphasis>元素相关. 
	同样的, 为了计算数组的元素个数, 
	可以使用<command>${#array_name[@]}</command>或<command>${#array_name[*]}</command>. 
	<command>${#array_name}</command>是数组第一个元素的长度, 
	也就是<command>${array_name[0]}</command>的长度(字符个数). 
	</para>

      <example id="emptyarray">
	<title>空数组与包含空元素的数组</title>
	<programlisting>&emptyarray;</programlisting>
      </example>

	  <para><command>${array_name[@]}</command>和<command>${array_name[*]}</command>的关系非常类似于<link linkend="appref">$@ and $*</link>. 
		 这种数组用法用处非常广泛. </para>

      <para>
      <programlisting># 复制一个数组. 
array2=( "${array1[@]}" )
# 或
array2="${array1[@]}"
#
#  然而, 如果在"缺项"数组中使用的话, 将会失败, 
#+ 也就是说数组中存在空洞(中间的某个元素没赋值), 
#+ 这个问题由Jochen DeSmet指出. 
# ------------------------------------------
  array1[0]=0
# array1[1]没赋值
  array1[2]=2
  array2=( "${array1[@]}" )       # 拷贝它? 

echo ${array2[0]}      # 0
echo ${array2[2]}      # (null), 应该是2
# ------------------------------------------



# 添加一个元素到数组. 
array=( "${array[@]}" "new element" )
# 或
array[${#array[*]}]="new element"

# 感谢, S.C.</programlisting>
      </para>


      <tip>
		  <para><command>array=( element1 element2 ... elementN 
				  )</command>初始化操作, 
			  如果有<link linkend="commandsubref">命令替换</link>的帮助, 
			  就可以将一个文本文件的内容加载到数组. 
		  </para>

      <para>  	
      <programlisting>#!/bin/bash

filename=sample_file

#            cat sample_file
#
#            1 a b c
#            2 d e fg


declare -a array1

array1=( `cat "$filename"`)                #  将$filename的内容
#         List file to stdout              #+ 加载到数组array1. 
#
#  array1=( `cat "$filename" | tr '\n' ' '`)
#                            把文件中的换行替换为空格. 
#  其实这么做是没必要的, Not necessary because Bash does word splitting,
#+ 因为Bash在做单词分割(word splitting)的时候, 将会把换行转换为空格. 

echo ${array1[@]}            # 打印数组. 
#                              1 a b c 2 d e fg
#
#  文件中每个被空白符分隔的"单词"
#+ 都被保存到数组的一个元素中. 

element_count=${#array1[*]}
echo $element_count          # 8</programlisting>
      </para>  	
      </tip>
      
      <para>出色的技巧使得数组的操作技术又多了一种. </para>

      <example id="arrayassign">
        <title>初始化数组</title>
	<programlisting>&arrayassign;</programlisting>
      </example>

	  <note><para>在数组声明的时候添加一个额外的<command>declare -a</command>语句, 
		能够加速后续的数组操作速度. 
	</para></note>

      <example id="copyarray">
        <title>拷贝和连接数组</title>
	<programlisting>&copyarray;</programlisting>
      </example>

      <example id="arrayappend">
        <title>关于串联数组的更多信息</title>
	<programlisting>&arrayappend;</programlisting>
      </example>


      <para>--</para>

      <para>有了数组, 我们就可以在脚本中实现一些比较熟悉的算法. 
        这么做, 到底是不是一个好主意, 我们在这里不做讨论, 还是留给读者决定吧. </para>

      <example id="bubble">
	<title>一位老朋友: 
             <emphasis>冒泡排序</emphasis></title>
	<programlisting>&bubble;</programlisting>
      </example>
      
      <para>--</para>

      <para>我们可以在数组中嵌套数组么? </para>
      <para><programlisting>#!/bin/bash
# "嵌套"数组. 

#  Michael Zick提供了这个用例, 
#+ William Park做了一些修正和说明. 

AnArray=( $(ls --inode --ignore-backups --almost-all \
	--directory --full-time --color=none --time=status \
	--sort=time -l ${PWD} ) )  # 命令及选项. 

# 空格是有意义的 . . . 并且不要在上边用引号引用任何东西. 

SubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )
#  这个数组有六个元素: 
#+     SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}
#      [3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )
#
#  Bash数组是字符串(char *)类型
#+ 的(循环)链表. 
#  因此, 这不是真正意义上的嵌套数组, 
#+ 只不过功能很相似而已. 

echo "Current directory and date of last status change:"
echo "${SubArray[@]}"

exit 0</programlisting></para>

      <para>--</para>

	  <para>如果将<quote>嵌套数组</quote>与<link
			  linkend="varrefnew">间接引用</link>组合起来使用的话, 
		 将会产生一些非常有趣的用法. 
	</para>

      <example id="embarr">
	<title>嵌套数组与间接引用</title>
	<programlisting>&embarr;</programlisting>
      </example>
      
      <para>--</para>

	  <para>数组使得<emphasis>埃拉托色尼素数筛子</emphasis>有了shell版本的实现. 
		  当然, 如果你需要的是追求效率的应用, 那么就应该使用编译行语言来实现, 
		  比如C语言. 因为脚本运行的太慢了. 
	</para>

      <example id="ex68">
	<title>复杂的数组应用: 
             <emphasis>埃拉托色尼素数筛子</emphasis></title>
	<programlisting>&ex68;</programlisting>
      </example>

	  <para>上边的这个例子是基于数组的素数产生器, 
		  还有不使用数组的素数产生器<xref linkend="primes">, 
		让我们来比较一番. </para>

      <para>--</para>

	  <para>数组可以进行一定程度上的扩展, 
		  这样就可以模拟一些Bash原本不支持的数据结构. 
        </para>

	    <example id="stackex">
	      <title>模拟一个下推堆栈</title>
	      <programlisting>&stackex;</programlisting>
	    </example>

      <para>--</para>

	  <para>如果想对数组<quote>下标</quote>做一些比较诡异的操作, 
		  可能需要使用中间变量. 
		  对于那些有这种需求的项目来说, 还是应该考虑使用功能更加强大的编程语言, 
		  比如Perl或C. </para>

      <example id="qfunction">
	<title>复杂的数组应用: 
             <emphasis>探索一个神秘的数学序列</emphasis></title>
	<programlisting>&qfunction;</programlisting>
      </example>

      <para>--</para>

      <para>Bash仅仅支持一维数组, 但是我们可以使用一个小手段, 
        这样就可以模拟多维数组了. </para>

      <example id="twodim">
	<title>模拟一个二维数组, 并使他倾斜</title>
	<programlisting>&twodim;</programlisting>
      </example>

      <para>二维数组本质上其实就是一个一维数组, 
		  只不过是添加了<emphasis>行</emphasis>和<emphasis>列</emphasis>的寻址方式, 
		  来引用和操作数组的元素而已. 
	</para>

	<para>这里有一个精心制作的模拟二维数组的例子, 
		请参考<xref linkend="lifeslow">. </para>

     <para>--</para>

	 <para>还有两个使用脚本的更有趣的例子, 
		 请参考: 
       <itemizedlist>
	 <listitem><para><xref linkend="agram2">和<xref
	 linkend="hashex2"></para></listitem>
       </itemizedlist>
     </para>

  </chapter> <!-- Arrays -->


  <chapter id="devproc">
    <title>/dev和/proc</title>

      <para><anchor id="devprocref"></para>

		  <para>Linux或者UNIX机器典型地都带有<filename 
				  class="directory">/dev</filename>和<filename 
				  class="directory">/proc</filename>目录, 用于特殊目的. 
	</para>



      <sect1 id="devref1">
	<title><filename class="directory">/dev</filename></title>

      <para><filename class="directory">/dev</filename>目录包含物理<emphasis>设备</emphasis>的条目, 
	这些设备可能会以硬件的形式出现, 也可能不会. 
	   <footnote>
	   <para><filename class="directory">/dev</filename>目录中的条目为各种物理设备和虚拟设备提供挂载点. 
	     这些条目占用非常少的硬盘空间. </para>
	 <para>某些设备, 比如<filename>/dev/null</filename>,
	   <filename>/dev/zero</filename>,
	   和<filename>/dev/urandom</filename>都是虚拟的. 
	   它们都不是真实的物理设备, 它们仅仅存在于软件中. 
	   </para>
	   </footnote>
	   包含有挂载文件系统的硬驱动器分区, 
	   在<filename class="directory">/dev</filename>目录中都有对应的条目, 
	就像<link linkend="dfref">df</link>命令所展示的那样. 
	      <screen><prompt>bash$ </prompt><userinput>df</userinput>
<computeroutput>Filesystem           1k-blocks      Used Available Use%
 Mounted on
 /dev/hda6               495876    222748    247527  48% /
 /dev/hda1                50755      3887     44248   9% /boot
 /dev/hda8               367013     13262    334803   4% /home
 /dev/hda5              1714416   1123624    503704  70% /usr</computeroutput>
	      </screen>
        </para>	     

      <para><anchor id="loopbackref">在其他方面, <filename
        class="directory">/dev</filename>目录也包含<emphasis>环回</emphasis>设备, 
	比如<filename>/dev/loop0</filename>. 
	一个环回设备就是一种机制, 可以让一般文件访问起来就像块设备那样. 

	  <footnote><para><emphasis>块设备</emphasis>都是以块为单位进行读写的, 
	    与之相对应的<emphasis>字符设备</emphasis>都是以字符为单位进行访问的. 
		典型的块设备比如硬盘和CD ROM驱动器. 
		典型的字符设备例如键盘. 
	</para></footnote>

	这使得我们可以挂载一个完整的文件系统, 这个文件系统是在一个大文件中所创建的. 
	参考<xref linkend="createfs">和<xref
	linkend="isomountref">. </para>

       <para><filename class="directory">/dev</filename>中还有少量的伪设备用于其它特殊目的, 
	 比如<link linkend="zerosref"><filename>/dev/null</filename></link>, <link
	 linkend="zerosref1"><filename>/dev/zero</filename></link>, <link
	 linkend="urandomref"><filename>/dev/urandom</filename></link>,
	 <filename>/dev/sda1</filename>, <filename>/dev/udp</filename>,
	 和<filename>/dev/tcp</filename>. </para>
	 
       <para>举个例子: </para>

       <para>为了<link linkend="mountref">挂载(mount)</link>一个USB闪存驱动器, 
         将下边一行附加到<filename>/etc/fstab</filename>中. 

	      <footnote>
			  <para>当然, 挂载点<filename>/mnt/flashdrive</filename>必须存在. 
				  如果不存在, 
				  请使用root用户来执行<command>mkdir /mnt/flashdrive</command>. </para>
             <para>为了能够真正的挂载驱动器, 请使用下面的命令: 
	       <command>mount /mnt/flashdrive</command></para>
	   <para>对于现在比较新的Linux发行版来说, 
		   都会自动把闪存驱动器设备挂载到<filename 
			   class="directory">/media</filename>目录上. </para>
	      </footnote>

	   <programlisting>/dev/sda1    /mnt/flashdrive    auto    noauto,user,noatime    0 0</programlisting>

         (也请参考<xref linkend="usbinst">.)</para>

       <para><anchor id="socketref"></para>

		   <para>当在<filename>/dev/tcp/$host/$port</filename>伪设备文件上执行一个命令的时候, 
			Bash会打开一个TCP连接, 也就是打开相关的<emphasis>socket</emphasis>. 
	    
			<footnote><para><emphasis>socket</emphasis>是一个通讯节点, 
			这个通讯节点与一个特殊的I/O端口相关联. 
	      它允许数据传输, 可以在同一台机器的不同硬件设备间传输, 
		  可以在同一个网络中的不同主机之间传输, 
		  可以在不同网络的不同主机间传输, 
		  当然, 也可以在Internet上的不同地区之间的不同主机之间传输. 
	      </para></footnote>

	 </para>


       <para>从<filename>nist.gov</filename>上获取时间: </para>
	      <screen><prompt>bash$ </prompt><userinput>cat &lt;/dev/tcp/time.nist.gov/13</userinput>
<computeroutput>53082 04-03-18 04:26:54 68 0 0 502.3 UTC(NIST) *</computeroutput>
	      </screen>

       <para>[Mark贡献了上面的例子.]</para>

       <para>下载一个URL: </para>
	      <screen><prompt>bash$ </prompt><userinput>exec 5&lt;&gt;/dev/tcp/www.net.cn/80</userinput>
<prompt>bash$ </prompt><userinput>echo -e "GET / HTTP/1.0\n" >&5</userinput>
<prompt>bash$ </prompt><userinput>cat &lt;&5</userinput>
	      </screen>

       <para>[感谢, Mark和Mihai Maties.]</para>




	    <example id="devtcp">
	      <title>利用<filename>/dev/tcp</filename>来检修故障</title>
	      <programlisting>&devtcp;</programlisting>
	    </example>
		<para>译者注: 由于上边例子的输出大部分都是英文, 
			所以译者补充一下脚本输出的译文. 
		</para>
		<para>如果bash以--enable-net-redirections选项来编译, 
			那么它就拥有了使用一个特殊字符设备的能力, 
			这个特殊字符设备用于TCP和UDP重定向. 
			这种重定向的能力就像STDIN/STDOUT/STDERR一样被使用. 
			该设备/dev/tcp的主次设备号是30, 36: 
		</para>
		<para>
		<programlisting>mknod /dev/tcp c 30 36</programlisting>
		</para>
		<para>&gt;摘自bash参考手册: </para>
		<para>/dev/tcp/host/port</para>
		<para>如果host是一个有效的主机名或Internet地址, 
			并且port是一个整数端口号或者是服务器名称, 
			Bash将会打开一个TCP连接, 到相应的socket上. 
		</para>

      </sect1> <!-- /dev -->



      <sect1 id="procref1">
        <title><filename class="directory">/proc</filename></title>


      <para><filename class="directory">/proc</filename>目录实际上是一个伪文件系统. 
		  <filename class="directory">/proc</filename>目录中的文件用来映射当前运行的系统, 
		  内核<emphasis>进程</emphasis>以及与它们相关的状态与统计信息. 
	</para>

       <para>
         <screen><prompt>bash$ </prompt><userinput>cat /proc/devices</userinput>
<computeroutput>Character devices:
   1 mem
   2 pty
   3 ttyp
   4 ttyS
   5 cua
   7 vcs
  10 misc
  14 sound
  29 fb
  36 netlink
 128 ptm
 136 pts
 162 raw
 254 pcmcia

 Block devices:
   1 ramdisk
   2 fd
   3 ide0
   9 md</computeroutput>



<prompt>bash$ </prompt><userinput>cat /proc/interrupts</userinput>
<computeroutput>           CPU0       
   0:      84505          XT-PIC  timer
   1:       3375          XT-PIC  keyboard
   2:          0          XT-PIC  cascade
   5:          1          XT-PIC  soundblaster
   8:          1          XT-PIC  rtc
  12:       4231          XT-PIC  PS/2 Mouse
  14:     109373          XT-PIC  ide0
 NMI:          0 
 ERR:          0</computeroutput>


<prompt>bash$ </prompt><userinput>cat /proc/partitions</userinput>
<computeroutput>major minor  #blocks  name     rio rmerge rsect ruse wio wmerge wsect wuse running use aveq

    3     0    3007872 hda 4472 22260 114520 94240 3551 18703 50384 549710 0 111550 644030
    3     1      52416 hda1 27 395 844 960 4 2 14 180 0 800 1140
    3     2          1 hda2 0 0 0 0 0 0 0 0 0 0 0
    3     4     165280 hda4 10 0 20 210 0 0 0 0 0 210 210
    ...</computeroutput>



<prompt>bash$ </prompt><userinput>cat /proc/loadavg</userinput>
<computeroutput>0.13 0.42 0.27 2/44 1119</computeroutput>



<prompt>bash$ </prompt><userinput>cat /proc/apm</userinput>
<computeroutput>1.16 1.2 0x03 0x01 0xff 0x80 -1% -1 ?</computeroutput>
         </screen>
      </para>

       <para>Shell脚本可以从<filename class="directory">/proc</filename>目录下的某些特定文件中提取数据. 

		   <footnote><para>某些系统命令也可做类似的事情, 
				   比如<link linkend="procinforef">procinfo</link>, 
	     <link linkend="freeref">free</link>, 
	     <link linkend="vmstatref">vmstat</link>, 
	     <link linkend="lsdevref">lsdev</link>, 
	     和<link linkend="uptimeref">uptime</link>. 
	     </para></footnote></para>

	  <para><programlisting>FS=iso                       # 内核是否支持ISO文件系统? 

grep $FS /proc/filesystems   # iso9660</programlisting></para>


       <para><programlisting>kernel_version=$( awk '{ print $3 }' /proc/version )</programlisting></para>

       <para><programlisting>CPU=$( awk '/model name/ {print $4}' < /proc/cpuinfo )

if [ $CPU = Pentium ]
then
  run_some_commands
  ...
else
  run_different_commands
  ...
fi</programlisting></para>  

       <para><programlisting>devfile="/proc/bus/usb/devices"
USB1="Spd=12"
USB2="Spd=480"


bus_speed=$(grep Spd $devfile | awk '{print $9}')

if [ "$bus_speed" = "$USB1" ]
then
  echo "USB 1.1 port found."
  # 可以在这里添加操作USB 1.1的相关动作. 
fi</programlisting></para>


	<para><filename class="directory">/proc</filename>目录下包含有许多以不同数字命名的子目录. 
	   这些作为子目录名字的数字, 代表的是当前正在运行进程的<link
		   linkend="ppidref">进程ID</link>. 
	   在这些以数字命名的子目录中, 
	   每一个子目录都有许多文件用来保存对应进程的可用信息. 
	   文件<filename>stat</filename>和<filename>status</filename>保存着进程运行时的各项统计信息,  
	   文件<filename>cmdline</filename>保存着进程被调用时的命令行参数, 
	   而文件<filename>exe</filename>是一个符号链接, 
	   这个符号链接指向这个运行进程的完整路径. 
	   还有许多类似这样的文件, 
	   如果从脚本的视角来看它们的话, 这些文件都非常的有意思. 
	   </para>

	    <example id="pidid">
	      <title>找出与给定PID相关联的进程</title>
	      <programlisting>&pidid;</programlisting>
	    </example>

	    <example id="constat">
	      <title>网络连接状态</title>
	      <programlisting>&constat;</programlisting>
	    </example>


		<warning><para>一般来说, 
		在<filename class="directory">/proc</filename>目录中, 
		进行<emphasis>写</emphasis>文件操作是非常危险的, 
	 因为这么做可能会破坏文件系统, 甚至于摧毁整个机器. 
	 </para></warning>

      </sect1> <!-- /proc -->

  </chapter> <!-- /dev and /proc -->

    

  <chapter id="zeros">
    <title>Zero与Null</title>

      <para><anchor id="zerosref"></para>

      <variablelist id="zeronull">
		  <title><anchor id="zeronull1"><filename>/dev/zero</filename>与<filename>/dev/null</filename></title>
	<varlistentry>
	  <term>使用<filename>/dev/null</filename></term>
	  <listitem>
		  <para>可以把<filename>/dev/null</filename>想象为一个<quote>黑洞</quote>. 
		它非常接近于一个只写文件. 
		所有写入它的内容都会永远丢失. 
		而如果想从它那读取内容, 则什么也读不到. 
		但是, 对于命令行和脚本来说, 
		<filename>/dev/null</filename>却非常的有用. 
		</para>

	    <para>禁用<filename>stdout</filename>. 
	      <programlisting>cat $filename >/dev/null
# 文件的内容不会输出到stdout. </programlisting>
            </para>

	    <para>禁用<filename>stderr</filename>
	      (来自于<xref linkend="ex57">).
	      <programlisting>rm $badname 2>/dev/null
#           错误消息[stderr]就这么被丢到太平洋去了. </programlisting>
	    </para>

	    <para>禁用<filename>stdout</filename>和<filename>stderr</filename>. 
	      <programlisting>cat $filename 2>/dev/null >/dev/null
# 如果"$filename"不存在, 将不会有错误消息输出. 
# 如果"$filename"存在, 文件内容不会输出到stdout. 
# 因此, 上边的代码根本不会产生任何输出. 
#
#  如果你只想测试一下命令的返回码, 而不想要任何输出时, 
#+ 这么做就非常有用了. 
#
# cat $filename &>/dev/null
#     也可以, 由Baris Cicek指出. </programlisting>
	    </para>

	    <para>删除一个文件的内容, 但是保留文件本身, 
	      并且保留所有的文件访问权限(来自于<xref linkend="ex1">和<xref linkend="ex2">): 
	      <programlisting>cat /dev/null > /var/log/messages
#  : > /var/log/messages   具有同样的效果, 但是不会产生新进程.(译者注: 因为是内建的)

cat /dev/null > /var/log/wtmp</programlisting>
	      </para>

		  <para>自动清空日志文件的内容(特别适用于处理那些由商业站点发送的, 
			  令人厌恶的<quote>cookie</quote>):</para>

	    <example id="cookies">  
	      <title>隐藏令人厌恶的cookie</title>
	      <programlisting>if [ -f ~/.netscape/cookies ]  # 如果存在, 就删除. 
then
  rm -f ~/.netscape/cookies
fi

ln -s /dev/null ~/.netscape/cookies
# 现在所有的cookie都被扔到黑洞里去了, 这样就不会保存在我们的磁盘中了. </programlisting>
            </example> 

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><anchor id="zerosref1">使用<filename>/dev/zero</filename></term>
	  <listitem>
	    <para>类似于<filename>/dev/null</filename>, 
	      <filename>/dev/zero</filename>也是一个伪文件, 
	      但事实上它会产生一个null流(二进制的0流, 
		  而不是ASCII类型). 如果你想把其他命令的输出写入它的话, 
		  那么写入的内容会消失, 
		  而且如果你想从<filename>/dev/zero</filename>中读取一连串null的话, 
		  也非常的困难, 虽然可以使用<link 
		linkend="odref">od</link>或者一个16进制编辑器来达到这个目的. 
	<filename>/dev/zero</filename>的主要用途就是用来创建一个指定长度, 
	并且初始化为空的文件, 这种文件一般都用作临时交换文件. 
	      </para>

	    <example id="ex73">
	      <title>使用<filename>/dev/zero</filename>来建立一个交换文件</title>
	      <programlisting>&ex73;</programlisting>
	    </example>

	    <para><filename>/dev/zero</filename>还有其他的应用场合, 
	      比如当你出于特殊目的, 需要<quote>用0填充</quote>一个指定大小的文件时, 就可以使用它. 
		  举个例子, 比如要将一个文件系统挂载到<link linkend="loopbackref">环回设备(loopback device)</link>上(请参考<xref linkend="createfs">), 
		 或者想<quote>安全</quote>的删除一个文件(请参考<xref linkend="blotout">). </para>

	    <example id="ramdisk">
	      <title>创建一个ramdisk</title>
	      <programlisting>&ramdisk;</programlisting>
	    </example>

	    <para>最后值得一提的是, 
	      ELF二进制文件需要使用<filename>/dev/zero</filename>. </para>

	  </listitem>
	</varlistentry>

      </variablelist>

  </chapter> <!-- Zeros and Nulls -->



  <chapter id="debugging">
    <title>调试</title>

    <epigraph>
      <attribution>Brian Kernighan</attribution>
      <para>首先, 调试要比编写代码困难得多, 
		  因此, 如果你尽可能聪明的编写代码, 
		  你就不会在调试的时候花费很多精力. 
        </para>
    </epigraph>

	<para>Bash并不包含调试器, 
		甚至都没有包含任何用于调试目的的命令和结构. 
	 
	   <footnote><para>事实上, Rocky Bernstein的<ulink
	   url="http://bashdb.sourceforge.net">Bash debugger</ulink>填补了这项空白. </para></footnote>
	
	脚本中的语法错误, 或者拼写错误只会产生模糊的错误信息, 
	当你调试一些非功能性脚本的时候, 
	这些错误信息通常都不会提供有意义的帮助. 
	</para>

      <example id="ex74">
	<title>一个错误脚本</title>
	<programlisting>&ex74;</programlisting>
      </example>

      <para>脚本的输出: 
	<screen><computeroutput>./ex74.sh: [37: command not found</computeroutput></screen>
        上边的脚本究竟哪错了(提示: 注意<command>if</command>的后边)? </para>

      <example id="missingkeyword">
	<title>缺少<link linkend="keywordref">关键字</link></title>
	<programlisting>&missingkeyword;</programlisting>
      </example>

      <para>脚本的输出: 
	<screen>
<computeroutput>missing-keyword.sh: line 10: syntax error: unexpected end of file</computeroutput>
	</screen>
	注意, 其实<emphasis>不</emphasis>必参考错误信息中指出的错误行号. 
	这行只不过是Bash解释器最终认定错误的地方. 
	</para>

	<para>出错信息在报告产生语法错误的行号时, 
		可能会忽略脚本的注释行. 
        </para>

      <para>如果脚本可以执行, 但并不如你所期望的那样工作, 怎么办? 
	通常情况下, 这都是由常见的逻辑错误所产生的. </para>

      <example id="ex75">
	<title>test24, 另一个错误脚本</title>
	<programlisting>&ex75;</programlisting>
      </example>

      <para>为了找出<xref linkend="ex75">中的错误, 
		我们可以把<userinput>echo "$badname"</userinput>行的注释符去掉. 
		echo出来的信息能够帮助你判断脚本是否按你期望的方式运行. 
	</para>

	<para>在这个特定的例子里, 
	<userinput>rm "$badname"</userinput>之所以没有给出期望的结果, 
	是因为<varname>$badname</varname>不应该被引用起来. 
	加上引号会保证<command>rm</command>只有一个参数(这就只能匹配一个文件名). 
	一种不完善的解决办法是去掉<varname>$badname</varname>外面的引号, 
	并且重新设置<varname>$IFS</varname>, 
	让<varname>$IFS</varname>只包含一个换行符, 
	<userinput>IFS=$'\n'</userinput>. 
	但是, 下面这个方法更简单. 
	<programlisting># 删除文件名中包含空格的文件, 下面这才是正确的方法. 
rm *\ *
rm *" "*
rm *' '*
# 感谢. S.C.</programlisting>
	
	</para>

      <para>总结一下这个脚本的症状, 
	<orderedlist>
	  <listitem>
	    <para>由于<quote><errorname>syntax error</errorname></quote>(语法错误)使得脚本停止运行, </para>
	  </listitem>
	  <listitem>
		  <para>或者脚本能够运行, 
		但是并不是按照我们所期望的那样运行(<errorname>逻辑错误</errorname>). </para> 
	  </listitem>
	  <listitem>
		  <para>脚本能够按照我们所期望的那样运行, 
		但是有烦人的副作用(<errorname>逻辑炸弹</errorname>). </para> 
	  </listitem>
	</orderedlist>
      </para>
	
      <para>如果想调试不工作的脚本, 有如下工具可用: 
	<orderedlist>
	  <listitem>

		  <para><link linkend="echoref">echo</link>语句可以放在脚本中存在疑问的位置上, 
		来观察变量的值, 
	    也可以了解脚本后续的动作. </para>

            <tip>
	    <para>最好只在<emphasis>调试</emphasis>的时候才使用<command>echo</command>语句. 

	        <programlisting>### debecho (debug-echo), 由Stefano Falsetto编写 ###
### 只有在DEBUG变量被赋值的情况下, 才会打印传递进来的参数. ###
debecho () {
  if [ ! -z "$DEBUG" ]; then
     echo "$1" >&2
     #         ^^^ 打印到stderr
  fi
}

DEBUG=on
Whatever=whatnot
debecho $Whatever   # whatnot

DEBUG=
Whatever=notwhat
debecho $Whatever   # (这里就不会打印.)</programlisting>

            </para>
	    </tip>

	  </listitem>
	  <listitem>
	    <para>使用过滤器<link linkend="teeref">tee</link>来检查临界点上的进程或数据流. 
	      </para>
	  </listitem>
	  <listitem>
	    <para>设置选项<option>-n -v -x</option></para>

	    <para><userinput>sh -n scriptname</userinput>不会运行脚本, 只会检查脚本的语法错误. 
		这等价于把<userinput>set -n</userinput>或<userinput>set -o noexec</userinput>插入脚本中. 
			注意, 某些类型的语法错误不会被这种方式检查出来. 
	      </para>

		 <para><userinput>sh -v scriptname</userinput>将会在运行脚本之前, 
			 打印出每一个命令. 
	      这等价于把<userinput>set -v</userinput>或<userinput>set
	      -o verbose</userinput>插入到脚本中. </para>
	    
	    <para>选项<option>-n</option>和<option>-v</option>可以同时使用. 
		<userinput>sh -nv scriptname</userinput>将会给出详细的语法检查.  
		</para>

	    <para><userinput>sh -x scriptname</userinput>会打印出每个命令执行的结果, 
			但只使用缩写形式. 
			这等价于在脚本中插入<userinput>set -x</userinput>或<userinput>set -o xtrace</userinput>. </para>

		<para>把<userinput>set -u</userinput>或<userinput>set 
				-o nounset</userinput>插入到脚本中, 并运行它, 
		就会在每个试图使用未声明变量的地方给出一个<errorname>unbound variable</errorname>错误信息. 
		</para>
	  </listitem>

	  <listitem>
	    
	    <para>使用<quote>assert</quote>(断言)函数在脚本的临界点上测试变量或条件. (这是从C语言中引入的.)</para>

	    <example id="assert">
	      <title>使用<quote>assert</quote>来测试条件</title>
	      <programlisting>&assert;</programlisting>
	    </example>	    

	  </listitem>

	  <listitem>

	    <para>使用变量<link linkend="linenoref">$LINENO</link>和内建命令<link linkend="callerref">caller</link>. 
	      </para>

	  </listitem>


	  <listitem>

	    <para>捕获exit. </para>

		<para>脚本中的<command>exit</command>命令会触发一个信号<returnvalue>0</returnvalue>, 
			这个信号终止进程, 也就是终止脚本本身. 

			<footnote><para>根据惯例, 
			<replaceable>信号0</replaceable>被指定为<link
		linkend="exitcommandref">exit</link>.  </para></footnote>

		  捕获<command>exit</command>在某些情况下很有用, 
		  比如说强制<quote>打印</quote>变量值. 
	      <command>trap</command>命令必须放在脚本中第一个命令的位置上. 
	      </para>

	  </listitem>
	</orderedlist>
      </para>

	<variablelist id="trapref">
	  <title><anchor id="trapref1">捕获信号</title>

	  <varlistentry>
	    <term><command>trap</command></term>
	    <listitem>
			<para>可以在收到一个信号的时候指定一个处理动作; 
				在调试的时候, 这一点也非常有用. 

	      <note><para><anchor id="signald">A
			 <emphasis>signal</emphasis>就是发往进程的一个简单消息, 
		这个消息即可以由内核发出, 也可以由另一个进程发出, 
		发送这个消息的目的是为了通知目的进程采取一些指定动作(通常都是终止动作). 
		比如说, 按下<keycombo><keycap>Control</keycap><keycap>C</keycap></keycombo>,
		就会发送一个用户中断(即INT信号)到运行中的进程. </para></note>

		<programlisting>trap '' 2
# 忽略中断2(Control-C), 没有指定处理动作. 

trap 'echo "Control-C disabled."' 2
# 当Control-C按下时, 显示一行信息. </programlisting>
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

      <example id="ex76">
	<title>捕获exit</title>
	<programlisting>&ex76;</programlisting>
      </example>
	
      <example id="online">
	<title>Control-C之后, 清除垃圾</title>
	<programlisting>&online;</programlisting>
      </example>

      <note>
      <para>如果使用<command>trap</command>命令的<option>DEBUG</option>参数, 
	那么当脚本中每个命令执行完毕后, 都会执行指定的动作. 
	比方说, 你可以跟踪某个变量的值. 

      <example id="vartrace">
	<title>跟踪一个变量</title>
	<programlisting>&vartrace;</programlisting>
      </example>

      </para>
      </note>


	  <para>当然, 除了调试之外, 
		  <command>trap</command>命令还有其他的用途. 
        </para>

      <example id="multipleproc">
	<title>运行多进程(在对称多处理器(SMP box)的机器上)</title>
	<programlisting>&multipleproc;</programlisting>
      </example>


	  <note><para><userinput>trap '' SIGNAL</userinput>(两个引号之间为空)在剩余的脚本中禁用了SIGNAL信号的动作. 
	<userinput>trap SIGNAL</userinput>则会恢复处理SIGNAL的动作. 
	当你想保护脚本的临界部分不受意外的中断骚扰, 
	那么上面讲的这种办法就非常有用了. 
	</para></note>

	<para><programlisting>
	trap '' 2  # 信号2就是Control-C, 现在被禁用了. 
	command
	command
	command
	trap 2     # 重新恢复Control-C
	</programlisting></para>

      <sidebar>
        <para>Bash<link linkend="bash3ref">3.0</link>之后增加了如下这些特殊变量用于调试. 

       <orderedlist>
         <listitem><para>$BASH_ARGC</para></listitem>
         <listitem><para>$BASH_ARGV</para></listitem>
         <listitem><para>$BASH_COMMAND</para></listitem>
         <listitem><para>$BASH_EXECUTION_STRING</para></listitem>
         <listitem><para>$BASH_LINENO</para></listitem>
         <listitem><para>$BASH_SOURCE</para></listitem>
         <listitem><para><link linkend="bashsubshellref">$BASH_SUBSHELL</link></para></listitem>
       </orderedlist></para>
      </sidebar>

  </chapter> <!-- Debugging -->



  <chapter id="options">
    <title>选项</title>

      <para><anchor id="optionsref"></para>

      <para>选项用来更改shell和脚本的行为. </para> 
	
      <para><link linkend="setref">set</link>命令用来打开脚本中的选项. 
	你可以在脚本中任何你想让选项生效的地方插入<command>set
	-o option-name</command>, 或者使用更简单的形式, <command>set
	-option-abbrev</command>. 
	这两种形式是等价的. </para>

      <para><programlisting>
      #!/bin/bash

      set -o verbose
      # 打印出所有执行前的命令. 
      </programlisting></para>

      <para><programlisting>
      #!/bin/bash

      set -v
      # 与上边的例子具有相同的效果. 
      </programlisting></para>

      <note><para>如果你想在脚本中<emphasis>禁用</emphasis>某个选项, 
	可以使用<command>set +o option-name</command>或<command>set
	+option-abbrev</command>. </para></note>

      <para><programlisting>
      #!/bin/bash

      set -o verbose
      # 激活命令回显. 
      command
      ...
      command

      set +o verbose
      # 禁用命令回显. 
      command
      # 没有命令回显了. 


      set -v
      # 激活命令回显. 
      command
      ...
      command

      set +v
      # 禁用命令回显. 
      command

      exit 0
      </programlisting></para>


      <para>还有另一种可以在脚本中启用选项的方法, 
	那就是在脚本头部, 
	<replaceable>#!</replaceable>的后边直接指定选项. </para>

      <para><programlisting>
      #!/bin/bash -x
      #
      # 下边是脚本的主要内容. 
      </programlisting></para>


      <para><anchor id="invocationoptionsref"></para>
      <para>也可以从命令行中打开脚本的选项. 
	某些不能与<command>set</command>命令一起用的选项就可以使用这种方法来打开. 
	<replaceable>-i</replaceable>就是其中之一, 
	这个选项用来强制脚本以交互的方式运行. 
	</para>

      <para><userinput>bash -v script-name</userinput></para>
      
      <para><userinput>bash -o verbose script-name</userinput></para>


      <para>下表列出了一些有用的选项. 
	它们都可以使用缩写的形式来指定(开头加一个破折号), 
	也可以使用完整名字来指定(开头加上<emphasis>双</emphasis>破折号, 
	或者使用<option>-o</option>选项来指定). </para>

      <table>
	<title>Bash选项</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>缩写</entry>
	      <entry>名称</entry>
	      <entry>作用</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><anchor id="noclobberref"><option>-C</option></entry>
	      <entry>noclobber</entry>
	      <entry>防止重定向时覆盖文件(可能会被<token>>|</token>覆盖)</entry> 
	    </row>
	    <row>
	      <entry><option>-D</option></entry>
	      <entry>(none)</entry>
	      <entry>列出用双引号引用起来的, 以<token>$</token>为前缀的字符串, 
	      但是不执行脚本中的命令</entry>
	    </row>
	    <row>
	      <entry><option>-a</option></entry>
	      <entry>allexport</entry>
	      <entry>export(导出)所有定义过的变量</entry>
	    </row>
	    <row>
	      <entry><option>-b</option></entry>
	      <entry>notify</entry>
	      <entry>当后台运行的作业终止时, 给出通知(脚本中并不常见)</entry>
	    </row>
	    <row>
	      <entry><option>-c ...</option></entry>
	      <entry>(none)</entry>
	      <entry>从<command>...</command>中读取命令</entry>
	    </row>
	    <row>
	      <entry><option>-e</option></entry>
	      <entry>errexit</entry>
		  <entry>当脚本发生第一个错误时, 就退出脚本, 
			  换种说法就是, 当一个命令返回非零值时, 
			  就退出脚本(除了<link
		linkend="untilloopref">until</link>或<link
		linkend="whileloopref">while loops</link>, <link
		linkend="testconstructs1">if-tests</link>, <link
		linkend="lcons1">list constructs</link>)</entry>
	    </row>
	    <row>
	      <entry><option>-f</option></entry>
	      <entry>noglob</entry>
	      <entry>禁用文件名扩展(就是禁用globbing)</entry>
	    </row>
	    <row>
	      <entry><option>-i</option></entry>
	      <entry>interactive</entry>
	      <entry>让脚本以<emphasis>交互</emphasis>模式运行</entry>
	    </row>
	    <row>
	      <entry><option>-n</option></entry>
	      <entry>noexec</entry>
	      <entry>从脚本中读取命令, 但是不执行它们(做语法检查)</entry>
	    </row>
	    <row>
	      <entry><option>-o Option-Name</option></entry>
	      <entry>(none)</entry>
	      <entry>调用<emphasis>Option-Name</emphasis>选项</entry>
	    </row>
	    <row>
	      <entry><option>-o posix</option></entry>
	      <entry>POSIX</entry>
		  <entry>修改Bash或被调用脚本的行为, 
			  使其符合<link linkend="posix2ref">POSIX</link>标准. 
		</entry>
	    </row>
	    <row>
	      <entry><option>-p</option></entry>
	      <entry>privileged</entry>
	      <entry>以<quote>suid</quote>身份来运行脚本(小心!)</entry>
	    </row>
	    <row>
	      <entry><option>-r</option></entry>
	      <entry>restricted</entry>
	      <entry>以<emphasis>受限</emphasis>模式来运行脚本(参考<xref linkend="restricted-sh">). </entry>
	    </row>
	    <row>
	      <entry><option>-s</option></entry>
	      <entry>stdin</entry>
	      <entry>从<filename>stdin</filename>中读取命令</entry>
	    </row>
	    <row>
	      <entry><option>-t</option></entry>
	      <entry>(none)</entry>
	      <entry>执行完第一个命令之后, 就退出</entry>
	    </row>
	    <row>
	      <entry><option>-u</option></entry>
	      <entry>nounset</entry>
	      <entry>如果尝试使用了未定义的变量, 就会输出一个错误消息, 
		然后强制退出</entry>
	    </row>
	    <row>
	      <entry><option>-v</option></entry>
	      <entry>verbose</entry>
	      <entry>在执行每个命令之前, 把每个命令打印到<filename>stdout</filename>上</entry>
	    </row>
	    <row>
	      <entry><option>-x</option></entry>
	      <entry>xtrace</entry>
	      <entry>与<option>-v</option>选项类似, 但是会打印完整命令</entry>
	    </row>
	    <row>
	      <entry><option>-</option></entry>
	      <entry>(none)</entry>
	      <entry>选项结束标志. 后面的参数为<link linkend="posparamref">位置参数</link>. </entry>
	    </row>
	    <row>
	      <entry><option>--</option></entry>
	      <entry>(none)</entry>
	      <entry>unset(释放)位置参数. 
		如果指定了参数列表(<varname>-- arg1 arg2</varname>), 
		那么位置参数将会依次设置到参数列表中. </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
  </chapter> <!-- Options -->


  
  <chapter id="gotchas">
    <title>陷阱</title>

    <epigraph>
      <attribution>Puccini</attribution>
      <para>Turandot: Gli enigmi sono tre, la morte una!</para>
      <para>Caleph: No, no! Gli enigmi sono tre, una la vita!</para>
    </epigraph>

      <para><anchor id="bash3gotcha"></para>



      <itemizedlist>

	<listitem>
      <para>将保留字或特殊字符声明为变量名. </para>

	<para>
	<programlisting>case=value0       # 引发错误. 
23skidoo=value1   # 也会引发错误. 
# 以数字开头的变量名是被shell保留使用的. 
# 试试_23skidoo=value1. 以下划线开头的变量就没问题. 

# 然而 . . .   如果只用一个下划线作为变量名就不行. 
_=25
echo $_           # $_是一个特殊变量, 代表最后一个命令的最后一个参数. 

xyz((!*=value2    # 引起严重的错误. 
# Bash3.0之后, 标点不能出现在变量名中. </programlisting>
	</para>
	</listitem>

	<listitem>
      <para>使用连字符或其他保留字符来做变量名(或函数名). </para>
	<para>
	<programlisting>var-1=23
# Use 'var_1' instead.

function-whatever ()   # 错误
# 使用'function_whatever ()'来代替. 

 
# Bash3.0之后, 标点不能出现在函数名中. 
function.whatever ()   # 错误
# 使用'functionWhatever ()'来代替. </programlisting>
      </para>
	</listitem>

	<listitem>
      <para>让变量名与函数名相同. 这会使得脚本的可读性变得很差. </para>
      <para>
        <programlisting>do_something ()
{
  echo "This function does something with \"$1\"."
}

do_something=do_something

do_something do_something

# 这么做是合法的, 但是会让人混淆. </programlisting>
	</para>
	</listitem>



	<listitem>
      <para><anchor id="wsbad">不合时宜的使用<link
	linkend="whitespaceref">空白</link>字符. 
	与其它编程语言相比, Bash非常讲究空白字符的使用. 
	</para>

	<para>
	<programlisting>var1 = 23   # 'var1=23'才是正确的. 
# 对于上边这一行来说, Bash会把"var1"当作命令来执行, 
# "="和"23"会被看作"命令""var1"的参数. 
	
let c = $a - $b   # 'let c=$a-$b'或'let "c = $a - $b"'才是正确的. 

if [ $a -le 5]    # if [ $a -le 5 ]   是正确的. 
# if [ "$a" -le 5 ]   这么写更好. 
# [[ $a -le 5 ]] 也行. </programlisting>
	</para>
	</listitem>


	<listitem>
      <para>在<link linkend="codeblockref">大括号包含的代码块</link>中, 最后一条命令没有以<firstterm>分号</firstterm>结尾. </para>
      <para>
        <programlisting>{ ls -l; df; echo "Done." }
# bash: syntax error: unexpected end of file

{ ls -l; df; echo "Done."; }
#                        ^     ### 最后的这条命令必须以分号结尾. </programlisting>
      </para>
	</listitem>


	<listitem>
      <para>
		  假定未初始化的变量(赋值前的变量)被<quote>清0</quote>. 
		  事实上, 未初始化的变量值为<quote>null</quote>, 
	而<emphasis>不是</emphasis>0. </para>

      <para>
	   <programlisting>#!/bin/bash

echo "uninitialized_var = $uninitialized_var"
# uninitialized_var =</programlisting>

      </para>
	</listitem>


	<listitem>
	<para>混淆测试符号<emphasis>=</emphasis>和<emphasis>-eq</emphasis>. 
	请记住, <emphasis>=</emphasis>用于比较字符变量, 
	而<emphasis>-eq</emphasis>用来比较整数. </para>

      <para>
	<programlisting>if [ "$a" = 273 ]      # $a是整数还是字符串? 
if [ "$a" -eq 273 ]    # $a为整数. 

# 有些情况下, 即使你混用-eq和=, 也不会产生错误的结果. 
# 然而 . . .


a=273.0   # 不是一个整数. 
	   
if [ "$a" = 273 ]
then
  echo "Comparison works."
else  
  echo "Comparison does not work."
fi    # Comparison does not work.

# 与a=" 273"和a="0273"相同.


# 类似的, 如果对非整数值使用"-eq"的话, 就会产生问题. 
	   
if [ "$a" -eq 273.0 ]
then
  echo "a = $a"
fi  # 因为产生了错误消息, 所以退出. 
# test.sh: [: 273.0: integer expression expected</programlisting>
        </para>
	</listitem>
	  

	<listitem>
      <para>误用了<link linkend="scomparison1">字符串比较</link>操作符. 
        </para>

	    <example id="badop">
	      <title>数字比较与字符串比较并不相同</title>
	      <programlisting>&badop;</programlisting>
	    </example>
	</listitem>

      
	<listitem>
      <para>有时候在<quote>test</quote>中括号([ ])结构里的变量需要被引用起来(双引号). 
	如果不这么做的话, 可能会引起不可预料的结果. 
	请参考<xref linkend="strtest">, <xref
	linkend="redir2">, 和<xref linkend="arglist">. </para>
	</listitem>


	<listitem>
      <para>脚本中的命令可能会因为脚本宿主不具备相应的运行权限而导致运行失败, 
	如果用户在命令行中就不能调用这个命令的话, 
	那么即使把它放到脚本中来运行, 也还是会失败. 
	这时可以通过修改命令的属性来解决这个问题, 
	有时候甚至要给它设置suid位(当然, 要以root身份来设置). </para>
	</listitem>



	<listitem>
		<para>试图使用<command>-</command>作为重定向操作符(事实上它不是), 
			通常都会导致令人不快的结果. 
	</para>
        <para>
	<programlisting>command1 2&gt; - | command2  # 试图将command1的错误输出重定向到一个管道中...
#    ...不会工作. 	

command1 2&gt;&amp; - | command2  # 也没效果. 

感谢, S.C.</programlisting></para>
	</listitem>




	<listitem>
      <para>使用Bash <link linkend="bash2ref">2.0</link>或更高版本的功能, 
	可以在产生错误信息的时候, 引发修复动作. 
	但是比较老的Linux机器默认安装的可能是Bash 1.XX. 
	</para>
        <para>
	<programlisting>#!/bin/bash

minimum_version=2
# 因为Chet Ramey经常给Bash添加一些新的特征, 
# 所以你最好将$minimum_version设置为2.XX, 3.XX, 或是其他你认为比较合适的值. 
E_BAD_VERSION=80

if [ "$BASH_VERSION" \< "$minimum_version" ]
then
  echo "This script works only with Bash, version $minimum or greater."
  echo "Upgrade strongly recommended."
  exit $E_BAD_VERSION
fi

...</programlisting></para>
	</listitem>

	

	<listitem>
		<para>在非Linux机器上的Bourne shell脚本(<userinput>#!/bin/sh</userinput>)中使用Bash特有的功能, 
			可能会引起不可预料的行为. 
	Linux系统通常都会把<command>bash</command>别名化为<command>sh</command>, 
	但是在一般的UNIX机器上却不一定会这么做. </para>
	</listitem>

	<listitem>
      <para>使用Bash未文档化的特征, 将是一种危险的举动. 
	本书之前的几个版本就依赖一个这种<quote>特征</quote>, 
	下面说明一下这个<quote>特征</quote>, 
	虽然<link linkend="exitstatusref">exit</link>或<link
	linkend="returnref">return</link>所能返回的最大正值为255, 
	但是并没有限制我们使用<emphasis>负</emphasis>整数. 
	不幸的是, Bash 2.05b之后的版本, 这个漏洞消失了. 
	请参考<xref linkend="returntest">. </para>
	</listitem>



	<listitem>
      <para>
        一个带有DOS风格换行符(<replaceable>\r\n</replaceable>)的脚本将会运行失败, 
	因为<userinput>#!/bin/bash\r\n</userinput>是<emphasis>不</emphasis>合法的, 
	与我们所期望的<userinput>#!/bin/bash\n</userinput><emphasis>不同</emphasis>. 
	解决办法就是将这个脚本转换为UNIX风格的换行符. </para>
      <para>
	  <programlisting>#!/bin/bash

echo "Here"

unix2dos $0    # 脚本先将自己改为DOS格式. 
chmod 755 $0   # 更改可执行权限. 
               # 'unix2dos'会删除可执行权限. 

./$0           # 脚本尝试再次运行自己. 
               # 但它作为一个DOS文件, 已经不能运行了. 

echo "There"

exit 0</programlisting>
      </para>

	</listitem>



	<listitem>
      <para>以<userinput>#!/bin/sh</userinput>开头的Bash脚本, 
		  不能在完整的Bash兼容模式下运行. 
		  某些Bash特定的功能可能会被禁用. 
		  如果脚本需要完整的访问所有Bash专有扩展, 
		  那么它需要使用<userinput>#!/bin/bash</userinput>作为开头. </para>
	</listitem>

	<listitem>
		<para>如果在<link linkend="heredocref">here document</link>中, 
		<link linkend="indentedls">结尾的limit string之前加上空白字符</link>的话, 
	将会导致脚本的异常行为. 
	</para>
	</listitem>


	<listitem>
      <para><anchor id="parchildprobref"></para>
      
		  <para>脚本不能将变量<command>export</command>到它的<link 
				  linkend="forkref">父进程</link>(即调用这个脚本的shell), 
			  或父进程的环境中. 
			  就好比我们在生物学中所学到的那样, 
			  子进程只会继承父进程, 反过来则不行. 
		</para>
      <para>
	  <programlisting>WHATEVER=/home/bozo
export WHATEVER
exit 0</programlisting>
          <screen><prompt>bash$ </prompt><command>echo $WHATEVER</command>
<computeroutput>

</computeroutput>
<prompt>bash$ </prompt></screen>
      </para>
      <para>
        可以确定的是, 即使回到命令行提示符, 变量$WHATEVER仍然没有被设置. 
       </para>
	
	</listitem>


      
	<listitem>
		<para>在<link linkend="subshellsref">子shell</link>中设置和操作变量之后, 
			如果尝试在子shell作用域之外使用同名变量的话, 将会产生令人不快的结果. 
		</para>

      <example id="subpit">
	<title>子shell缺陷</title>
	<programlisting>&subpit;</programlisting>
      </example>
	</listitem>



	<listitem>
      <para><anchor id="badread0"></para>
		  <para>将<command>echo</command>的输出通过<link 
			linkend="piperef">管道</link>传递给<link
	linkend="readref">read</link>命令可能会产生不可预料的结果. 
	在这种情况下, <command>read</command>命令的行为就好像它在子shell中运行一样. 
	可以使用<link linkend="setref">set</link>命令来代替(就好像<xref
	linkend="setpos">一样). </para>

      <example id="badread">
	<title>将<command>echo</command>的输出通过管道传递给<command>read</command>命令</title>
	<programlisting>&badread;</programlisting>
      </example>

	  <para>事实上, 也正如Anthony Richardson指出的那样, 
		  通过管道将输出传递到<emphasis>任何</emphasis>循环中, 都会引起类似的问题. </para>

      <para>	
<programlisting># 循环的管道问题. 
#  这个例子由Anthony Richardson编写, 
#+ 由Wilbert Berendsen补遗. 


foundone=false
find $HOME -type f -atime +30 -size 100k |
while true
do
   read f
   echo "$f is over 100KB and has not been accessed in over 30 days"
   echo "Consider moving the file to archives."
   foundone=true
   # ------------------------------------
   echo "Subshell level = $BASH_SUBSHELL"
   # Subshell level = 1
   # 没错, 现在是在子shell中运行. 
   # ------------------------------------
done
   
#  变量foundone在这里肯定是false, 
#+ 因为它是在子shell中被设置为true的. 
if [ $foundone = false ]
then
   echo "No files need archiving."
fi

# =====================现在, 下边是正确的方法:=================

foundone=false
for f in $(find $HOME -type f -atime +30 -size 100k)  # 这里没使用管道. 
do
   echo "$f is over 100KB and has not been accessed in over 30 days"
   echo "Consider moving the file to archives."
   foundone=true
done
   
if [ $foundone = false ]
then
   echo "No files need archiving."
fi

# ==================这里是另一种方法==================

#  将脚本中读取变量的部分放到一个代码块中, 
#+ 这样一来, 它们就能在相同的子shell中共享了. 
#  感谢, W.B.

find $HOME -type f -atime +30 -size 100k | {
     foundone=false
     while read f
     do
       echo "$f is over 100KB and has not been accessed in over 30 days"
       echo "Consider moving the file to archives."
       foundone=true
     done

     if ! $foundone
     then
       echo "No files need archiving."
     fi
}</programlisting>
      </para>

      <para>
        一个相关的问题: 当你尝试将<command>tail -f</command>的<filename>stdout</filename>通过管道传递给<link linkend="grepref">grep</link>时, 会产生问题. 
	  <programlisting>tail -f /var/log/messages | grep "$ERROR_MSG" >> error.log
# "error.log"文件将不会写入任何东西. </programlisting>
      </para>
	</listitem>



	<listitem>
      <para>在脚本中使用<quote>suid</quote>命令是非常危险的, 
	因为这会危及系统安全. 
	  <footnote><para>给脚本设置<emphasis>suid</emphasis>权限是没用的. 
	    </para></footnote>
      </para>
	</listitem>


	<listitem>
		<para>使用shell脚本来编写CGI程序是值得商榷的. 
			因为Shell脚本的变量不是<quote>类型安全</quote>的, 
		当CGI被关联的时候, 可能会产生令人不快的行为. 
	此外, 它还很难抵挡住<quote>破解的考验</quote>. </para>
	</listitem>


	<listitem>
      <para>Bash不能正确的处理<link linkend="doubleslashref">双斜线(<token>//</token>)字符串</link>. </para>
	</listitem>


	<listitem>
		<para>在Linux或BSD上编写的Bash脚本, 可能需要修改一下, 
			才能使它们运行在商业的UNIX(或Apple OSX)机器上.  
	这些脚本通常都使用GNU命令和过滤工具, GNU工具通常都比一般的UNIX上的同类工具更加强大. 
	这方面的一个非常明显的例子就是, 文本处理工具<link
	linkend="trref">tr</link>. </para>
	</listitem>


      </itemizedlist>

    <epigraph>
      <attribution>A.J. Lamb and H.W. Petrie</attribution>
      <para>危险正在接近你 --</para>
      <para>小心, 小心, 小心, 小心.</para>
      <para>许多勇敢的心都在沉睡. </para>
      <para>所以一定要小心 --</para>
      <para>小心. </para>
    </epigraph>

  </chapter> <!-- Gotchas -->



  <chapter id="scrstyle">
    <title>脚本编程风格</title>

      <para>编写脚本时, 最好养成系统化和结构化的风格. 
	 即使你在<quote>空闲时</quote>, 
	<quote>在信封后边顺便做一下草稿</quote>也是非常有益处的, 
	所以, 在你坐下来编写代码之前, 最好花几分钟的时间来规划和组织一下你的想法. 
	</para>

	<para>这里所描述的是一些风格上的指导原则. 
		但是请注意, 这节文档并不是想成为一个<emphasis>官方的Shell脚本编写风格</emphasis>. </para>



      <sect1 id="unofficialst">
        <title>非官方的Shell脚本编写风格</title>

      <itemizedlist>

        <listitem>

			<para>习惯性的注释你的代码. 
			这可以让别人更容易看懂(或者感激)你的代码(译者注: 犯错时, 别人也会靠注释找到你), 
	    而且也更便于维护. 
	    <programlisting>PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"
# 去年你写下这段代码的时候, 你非常了解这段代码的含义, 但现在它对你来说完全是个谜. 
# (摘自Antek Sawicki的"pw.sh"脚本.)</programlisting>
	  </para>

	  <para>给脚本和函数加上描述性的头信息. 
	    <programlisting>#!/bin/bash

#************************************************#
#                   xyz.sh                       #
#           written by Bozo Bozeman              #
#                July 05, 2001                   #
#                                                #
#           Clean up project files.              #
#************************************************#

E_BADDIR=65                       # 没有这个目录. 
projectdir=/home/bozo/projects    # 想要清除的目录. 

# --------------------------------------------------------- #
# cleanup_pfiles ()                                         #
# 删除指定目录中的所有文件.                                 #
# Parameter: $target_directory                              #
# 返回值: 0表示成功, 失败返回$E_BADDIR.                     #
# --------------------------------------------------------- #
cleanup_pfiles ()
{
  if [ ! -d "$1" ]  # Test if target directory exists.
  then
    echo "$1 is not a directory."
    return $E_BADDIR
  fi

  rm -f "$1"/*
  return 0   # Success.
}  

cleanup_pfiles $projectdir

exit 0</programlisting>

	    在脚本开头添加任何注释之前, 一定要确保<emphasis>#!/bin/bash</emphasis>放在脚本第一行的开头. 
	    </para>

        </listitem>

        <listitem>
	  <para>避免使用<quote>魔法数字</quote>, 

	     <footnote><para>在这种上下文中所说的<quote>魔法数字</quote>与用来指明文件类型的<link linkend="magnumref">魔法数字</link>, 在含义上完全不同. 
	       </para></footnote>

	    也就是, 避免<quote>写死的</quote>字符常量. 
		可以使用有意义的变量名来代替. 
		这使得脚本更易于理解, 并且允许在不破坏应用的情况下进行修改和更新. 

	    <programlisting>if [ -f /var/log/messages ]
then
  ...
fi
# 一年以后, 你决定修改这个脚本, 让它来检查/var/log/syslog. 
# 到时候你就必须一行一行的手动修改这个脚本, 
# 并且寄希望于没有遗漏的地方. 

# 更好的办法是: 
LOGFILE=/var/log/messages  # 只需要改动一行就行了. 
if [ -f "$LOGFILE" ]
then
  ...
fi</programlisting>
          </para>
        </listitem>


        <listitem>

	  <para>给变量和函数起一些有意义的名字. 
	    <programlisting>fl=`ls -al $dirname`                 # 含义模糊. 
file_listing=`ls -al $dirname`       # 更好的名字. 


MAXVAL=10   # 使用变量来代替脚本常量, 并且在脚本中都是用这个变量. 
while [ "$index" -le "$MAXVAL" ]
...


E_NOTFOUND=75                        #  错误码使用大写, 
                                     #+ 并且命名的时候用"E_"作为前缀. 
if [ ! -e "$filename" ]
then
  echo "File $filename not found."
  exit $E_NOTFOUND
fi  


MAIL_DIRECTORY=/var/spool/mail/bozo  # 环境变量名使用大写. 
export MAIL_DIRECTORY


GetAnswer ()                         # 函数名采用大小写混合的方式. 
{
  prompt=$1
  echo -n $prompt
  read answer
  return $answer
}  

GetAnswer "What is your favorite number? "
favorite_number=$?
echo $favorite_number


_uservariable=23                     # 语法上可以这么起名, 但是不推荐. 
# 用户定义的变量名最好不要以下划线开头. 
# 因为以下划线开头的变量, 一般都保留, 作为系统变量. </programlisting>
          </para>
        </listitem>


        <listitem>

	  <para><link linkend="exitcommandref">退出码</link>最好也采用具有系统性的或有意义的命名方式. 

	    <programlisting>E_WRONG_ARGS=65
...
...
exit $E_WRONG_ARGS</programlisting>
            也请参考<xref linkend="exitcodes">. </para>


			<para><emphasis>最后</emphasis>, 
			我们建议采用<filename>/usr/include/sysexits.h</filename>中的定义作为退出码, 
			虽然这些定义主要用于C/C++编程语言. 
	    </para>

        </listitem>



        <listitem>


	   <para>在脚本调用中使用标准化的参数标志. 
		   <emphasis>最后</emphasis>, 我们建议使用下面的参数集. 
	   </para>

           <para>
             <programlisting>-a      全部: 返回全部信息(包括隐藏的文件信息). 
-b      摘要: 缩减版本, 通常用于其它版本. 通常用于其它脚本. 
-c      拷贝, 连接, 等等.
-d      日常的: 使用全天的信息, 
        而不仅仅是特定用户或特定实例的信息. 
-e      扩展/详细描述: (通常不包括隐藏文件信息). 
-h      帮助: 详细的使用方法, 附加信息, 讨论, 帮助.
        也请参考-V.
-l      打印出脚本的输出记录. 
-m      手册: 显示基本命令的man页. 
-n      数字: 仅使用数字数据. 
-r      递归: 这个目录中所有的文件(也包含所有子目录). 
-s      安装&文件维护: 这个脚本的配置文件. 
-u      用法: 列出脚本的调用方法. 
-v      详细信息: 只读输出, 或多或少的会做一些格式化. 
-V      版本/许可/版权Copy(right|left)/捐助(邮件列表). </programlisting>
           </para>

           <para>也请参考<xref linkend="standard-options">. </para>

        </listitem>


        <listitem>
	  <para>将一个复杂脚本分割成一些简单的模块. 
	    使用合适的函数来实现模块的功能. 请参考<xref linkend="ex79">. </para>
        </listitem>

        <listitem>
	  <para>如果有更简单的结构可以使用的话, 就不要使用复杂的结构. 
	    <programlisting>COMMAND
if [ $? -eq 0 ]
...
# 多余, 而且不好理解. 

if COMMAND
...
# 更简练(可能会损失一些可读性). </programlisting>
          </para>
        </listitem>

	    
      </itemizedlist>


    <epigraph>
      <attribution>Landon Noll</attribution>
      <para>... 当我阅读UNIX中Bourne shell (/bin/sh)部分的源代码时. 
		  我被震惊了, 有多少简单的算法被恶心的编码风格弄得令人看不懂, 
		  并且因此变得没用. 
	我问我自己, 
	<quote>有人会对这种代码感到骄傲和自豪么?</quote></para>
    </epigraph>

    </sect1> <!-- Unofficial Shell Scripting Stylesheet -->  



  </chapter> <!-- Scripting With Style -->



  <chapter id="miscellany">
    <title>杂项</title>

    <epigraph>
      <attribution>Tom Duff</attribution>
	  <para>没有人真正的了解Bourne shell的全部语法. 
		  即使你阅读源代码也获得不了多少帮助. 
      </para>
    </epigraph>


      <sect1 id="intandnonint">
        <title>交互与非交互式的交互与非交互式的shell和脚本</title>
         
	 <para><emphasis>交互式</emphasis>的shell会在<filename>tty</filename>上从用户输入中读取命令. 
	   另一方面, 
	   这样的shell能在启动时读取启动文件, 
	   显示一个提示符, 并默认激活作业控制. 
	   也就是说, 用户可以与shell<emphasis>交互</emphasis>. </para>

	 <para>shell所运行的脚本通常都是非交互的shell. 
		 但是脚本仍然可以访问它的<filename>tty</filename>. 
		 甚至可以在脚本中模拟一个交互式的shell. 

	   <programlisting>#!/bin/bash
MY_PROMPT='$ '
while :
do
  echo -n "$MY_PROMPT"
  read line
  eval "$line"
  done

exit 0

# 这个例子脚本, 还有上面那么多的解释
# 都是由Stephane Chazelas提供的(再次感谢). </programlisting></para>

	 <para>让我们考虑一个需要用户输入的<emphasis>交互式</emphasis>脚本, 
		 这种脚本通常都要使用<link linkend="readref">read</link>语句(请参考<xref linkend="ex36">). 
		但是<quote>现实的情况</quote>肯定要比这复杂的多. 
		就目前的情况来看, 交互式脚本通常都绑定在一个tty设备上, 
		换句话说, 用户都是在控制终端或<firstterm>xterm</firstterm>上来调用脚本的. </para>

	<para>初始化脚本和启动脚本都是非交互式的, 
		因为它们都不需要人为干预, 都是自动运行的. 
	   许多管理脚本和系统维护脚本也同样是非交互式的. 
	   对于那些不需要经常变化的, 重复性的任务, 应该交给非交互式的脚本来自动完成. 
	   </para>

	 <para>非交互式的脚本可以在后台运行, 
		 但是如果交互式脚本在后台运行的话, 就会被挂起, 
		 因为它们在等待永远不会到来的输入. 
		 如果想解决后台运行交互式脚本的问题, 
		 可以使用带有<command>expect</command>命令的脚本, 
		 或者在脚本中嵌入<link linkend="heredocref">here
	   document</link>来提供交互式脚本所需要的输入. 
	   最简单的办法其实就是将一个文件重定向给<command>read</command>命令, 
	   来提供它所需要的输入(<command>read variable &lt;file</command>). 
	   通过使用上述方法, 就可以编写出通用目的脚本, 
	   这种脚本即可以运行在交互模式下, 也可以运行在非交互模式下. 
	   </para>

	   <para>如果脚本需要测试一下自己是否运行在交互式shell中, 
		   那么一个简单的办法就是察看是否存在<emphasis>提示符(prompt)</emphasis>变量, 
		   也就是察看一下变量<link linkend="ps1ref">$PS1</link>是否被设置. 
		   (如果脚本需要用户输入, 那么脚本就需要显示提示符.)

	   <programlisting>if [ -z $PS1 ] # 没有提示符? 
then
  # 非交互式
  ...
else
  # 交互式
  ...
fi</programlisting>

	   <anchor id="iitest">另一种办法, 脚本可以测试一下标志<link
	   linkend="flpref">$-</link>中是否存在选项<quote>i</quote>. 

           <programlisting>case $- in
*i*)    # 交互式shell
;;
*)      # 非交互式shell
;;
# ("UNIX F.A.Q."的惯例, 1993)</programlisting></para>


	 <note><para>使用<userinput>#!/bin/bash -i</userinput>头, 
			 或者使用<token>-i</token>选项, 
			 可以强制脚本运行在交互模式下. 
			 注意, 这么做可能会让脚本产生古怪的行为, 
			 有时候即使在没有错误的情况下, 也可能会显示错误信息. 
	   </para></note>


      </sect1> <!-- Interactive and non-interactive scripts -->



    <sect1 id="wrapper">
      <title>Shell包装</title>

      <para><anchor id="shwrapper"></para>

      <para><quote>包装</quote>脚本指的是内嵌系统命令或工具的脚本, 
	并且这种脚本保留了传递给命令的一系列参数. 

      <footnote><para>事实上, Linux中相当一部分工具都是shell包装脚本. 
	比如<filename>/usr/bin/pdf2ps</filename>,
	<filename>/usr/bin/batch</filename>, 
	和<filename>/usr/X11R6/bin/xmkmf</filename>. </para></footnote>
	
	因为包装脚本中包含了许多带有参数的命令, 使它能够完成特定的目的, 
	所以这样就大大简化了命令行的输入. 
	这对于<link linkend="sedref">sed</link>和<link
	linkend="awkref">awk</link>命令特别有用. 
	</para>

      <para>
	<command>
	  <indexterm>
	    <primary>sed</primary>
	  </indexterm> <indexterm>
	    <primary>script</primary> <secondary>sed</secondary>
	  </indexterm> sed</command>或
	<command>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm> <indexterm>
	    <primary>script</primary> <secondary>awk</secondary>
	  </indexterm>
	    awk</command>脚本通常都是在命令行中被调用的, 
	    使用的形式一般为<userinput>sed -e
	    <replaceable>'commands'</replaceable></userinput>
	    或<userinput>awk
			<replaceable>'commands'</replaceable></userinput>. 
		将这样的脚本(译者注: 指的是包装了sed和awk的脚本)嵌入到Bash脚本中将会使调用更加简单, 
		并且还可以<quote>重复利用</quote>. 
		也可以将<command>sed</command>与<command>awk</command>的功能结合起来使用, 
	    比如, 可以将一系列<command>sed</command>命令的输出通过<link
	    linkend="piperef">管道</link>传递给<command>awk</command>. 
		还可以保存为可执行文件, 这样你就可以重复的调用它了, 如果功能不满足, 
		你还可以修改它, 这么做可以让省去每次都在命令行上输入命令的麻烦. 
	    </para>

      <example id="ex3">
	<title><command>shell包装</command></title>
	<programlisting>&ex3;</programlisting>
      </example>
      
      <example id="ex4">
	<title>稍微复杂一些的<command>shell包装</command></title>
	<programlisting>&ex4;</programlisting>
      </example>

      <example id="loggingwrapper">
	<title>一个通用的<command>shell包装</command>, 用来写日志文件</title>
	<programlisting>&loggingwrapper;</programlisting>
      </example>

      <example id="prasc">
	<title>包装awd脚本的<command>shell包装</command></title>
	<programlisting>&prasc;</programlisting>
      </example>

      <example id="coltotaler">
	<title>另一个包装awd脚本的<command>shell包装</command></title>
	<programlisting>&coltotaler;</programlisting>
      </example>


      <para><anchor id="perlref">如果那些脚本需要的是一个全功能(多合一)的工具, 
			  一把瑞士军刀, 那么只能使用Perl了. 
			  Perl兼顾<command>sed</command>和<command>awk</command>的能力, 
			  并且包含了<command>C</command>的很大的一个子集, 用于引导. 
	它是模块化的, 并且包含从面向对象编程到厨房水槽的所有功能(译者注: 就是表示Perl无所不能). 
	小段的Perl脚本可以内嵌到shell脚本中, 
	以至于有人声称Perl可以完全代替shell脚本(不过本文作者对此持怀疑态度). </para>

      <example id="ex56">
	<title>将Perl嵌入到<command>Bash</command>脚本中</title>
	<programlisting>&ex56;</programlisting>
      </example>
     
      <para>甚至可以将Bash脚本和Perl脚本放到同一个文件中. 
        这依赖于如何调用这个脚本, 或者执行Bash部分, 或者执行Perl部分. 
	</para>

      <example id="bashandperl">
	<title>将Bash和Perl脚本写到同一个文件中</title>
	<programlisting>&bashandperl;</programlisting>
      </example>

	      <para>
	      <screen><prompt>bash$ </prompt><userinput>bash bashandperl.sh</userinput>
<computeroutput>Greetings from the Bash part of the script.</computeroutput>


<prompt>bash$ </prompt><userinput>perl -x bashandperl.sh</userinput>
<computeroutput>Greetings from the Perl part of the script.</computeroutput>
	      </screen>
	      </para>


    </sect1> <!-- Shell wrappers -->



      <sect1 id="testsandcomparisons">
        <title>测试和比较: 一种可选的方法</title>

	<para>对于测试来说, <link linkend="dblbrackets">[[    ]]</link>结构可能比<userinput>[
	  ]</userinput>结构更合适. 
	  同样地, 在算术比较中, 使用<link linkend="dblparens">((    ))</link>结构可能会更有用. 

	  <programlisting>a=8

# 下面所有的比较都是等价的. 
test "$a" -lt 16 && echo "yes, $a < 16"         # "与列表"
/bin/test "$a" -lt 16 && echo "yes, $a < 16" 
[ "$a" -lt 16 ] && echo "yes, $a < 16" 
[[ $a -lt 16 ]] && echo "yes, $a < 16"          # 在[[ ]]和(( ))结构中, 
(( a < 16 )) && echo "yes, $a < 16"             # 不用将变量引用起来. 

city="New York"
# 同样地, 下面所有的比较都是等价的. 
test "$city" \< Paris && echo "Yes, Paris is greater than $city"  # 按照ASCII顺序比较. 
/bin/test "$city" \< Paris && echo "Yes, Paris is greater than $city" 
[ "$city" \< Paris ] && echo "Yes, Paris is greater than $city" 
[[ $city < Paris ]] && echo "Yes, Paris is greater than $city"    # 不需要引用$city. 

# 感谢, S.C. </programlisting></para>

      </sect1> <!-- Tests and Comparisons: Alternatives -->



      <sect1 id="recursionsct">
        <title>递归</title>

	<para>脚本是否可以<link linkend="recursionref">递归</link>调用自身? 当然可以. </para>

	    <example id="recurse">
	      <title>递归调用自身的(没用的)脚本</title>
	      <programlisting>&recurse;</programlisting>
	    </example>

	    <example id="pbook">
	      <title>递归调用自身的(有用的)脚本</title>
	      <programlisting>&pbook;</programlisting>
	    </example>

	    <example id="usrmnt">
	      <title>另一个递归调用自身的(有用的)脚本</title>
	      <programlisting>&usrmnt;</programlisting>
	    </example>

	<caution><para>过多层次的递归会耗尽脚本的栈空间, 引起段错误. 
	  </para></caution>

      </sect1> <!-- Recursion -->



      <sect1 id="colorizing">
        <title>将脚本<quote>彩色化</quote></title>

	<para><anchor id="colorizingref"></para>

		<para>ANSI<footnote><para>当然, 
			<acronym>ANSI</acronym>是美国国家标准组织(American National Standards Institute)的缩写. 
		这个令人敬畏的组织建立和维护着许多技术和工业的标准. 
	     </para></footnote>定义了屏幕属性的转义序列集合, 
	   比如说粗体文本, 前景与背景颜色. <link
	   linkend="dosbatch1">DOS批处理文件</link>通常都使用ANSI转义码来控制 <emphasis>颜色</emphasis>输出, 
	   Bash脚本也是这么做的. </para>

	    <example id="ex30a">
	      <title>一个<quote>彩色的</quote>地址数据库</title>
	      <programlisting>&ex30a;</programlisting>
	    </example>

	    <example id="draw-box">
	      <title>画一个盒子</title>
	      <programlisting>&drawbox;</programlisting>
	    </example>


	<para>最简单的, 也可能是最有用的ANSI转义序列是加粗文本, 
		<command>\033[1m ... \033[0m</command>. 
	  <token>\033</token>代表<emphasis>转义</emphasis>, 
	  <quote>[1</quote>打开加粗属性, 
	  而<quote>[0</quote>关闭加粗属性. 
	  <quote>m</quote>表示转义序列结束. 
	      <screen>
<prompt>bash$ </prompt><userinput>echo -e "\033[1mThis is bold text.\033[0m"</userinput>
	      </screen>
	</para>

	<para>一种类似的转义序列用来切换下划线属性(在<emphasis>rxvt</emphasis> 和<emphasis>aterm</emphasis>上). 
	      <screen>
<prompt>bash$ </prompt><userinput>echo -e "\033[4mThis is underlined text.\033[0m"</userinput>
	      </screen>
	</para>

	<note><para><command>echo</command>命令的<option>-e</option>选项用来启用转义序列. </para></note>

	<para>其他的转义序列可用于修改文本和背景色. </para>

	      <para>
	      <screen>
<prompt>bash$ </prompt><userinput>echo -e '\E[34;47mThis prints in blue.'; tput sgr0</userinput>


<prompt>bash$ </prompt><userinput>echo -e '\E[33;44m'"yellow text on blue background"; tput sgr0</userinput>


<prompt>bash$ </prompt><userinput>echo -e '\E[1;33;44m'"BOLD yellow text on blue background"; tput sgr0</userinput>
	      </screen>
	      </para>

	<note><para>通常情况下, 为浅色的前景文本设置<emphasis>粗体</emphasis>属性比较好. 
	  </para></note>

	      <para><command>tput sgr0</command>把终端设置恢复为原样. 
		如果省略这一句, 那么这个终端所有后续的输出还会是蓝色. 
	        </para>

              <note><para>因为<command>tput sgr0</command>在某些环境下不能恢复终端设置, 
		<command>echo -ne \E[0m</command>可能是更好的选择. </para></note>

	<sidebar>
	<para>可以在有色的背景上, 使用下面的模板, 在上面写有色的文本. 
	</para>

        <para>
	  <userinput>echo -e '\E[COLOR1;COLOR2mSome text goes here.'</userinput>
        </para>

	<para><quote>\E[</quote>开始转义序列. 
	  以分号分隔的数字<quote>COLOR1</quote>和<quote>COLOR2</quote>分别指定了前景色和背景色, 
	  数值与色彩之间的对应, 请参考下面的表格. (数值的顺序其实没关系, 
	  因为前景色和背景色的数值都落在互不重叠的范围中.) 
	  <quote>m</quote>用来终止转义序列, 
	  文本紧跟在<quote>m</quote>的后面. 
	  </para>

	<para>也要注意, <link linkend="snglquo">单引号</link>将<command>echo -e</command>后面的命令序列都引用了起来. 
	  </para>
	</sidebar>


	<para>下表的数值是在<emphasis>rxvt</emphasis>终端上运行的结果. 
		具体的结果可能和在其他终端上运行的结果不同. 
	  </para>

      <table>
	<title>转义序列中颜色与数值的对应</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>颜色</entry>
	      <entry>前景</entry>
	      <entry>背景</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>黑</option></entry>
	      <entry>30</entry>
	      <entry>40</entry>
	    </row>
	    <row>
	      <entry><option>红</option></entry>
	      <entry>31</entry>
	      <entry>41</entry>
	    </row>
	    <row>
	      <entry><option>绿</option></entry>
	      <entry>32</entry>
	      <entry>42</entry>
	    </row>
	    <row>
	      <entry><option>黄</option></entry>
	      <entry>33</entry>
	      <entry>43</entry>
	    </row>
	    <row>
	      <entry><option>蓝</option></entry>
	      <entry>34</entry>
	      <entry>44</entry>
	    </row>
	    <row>
	      <entry><option>洋红</option></entry>
	      <entry>35</entry>
	      <entry>45</entry>
	    </row>
	    <row>
	      <entry><option>青</option></entry>
	      <entry>36</entry>
	      <entry>46</entry>
	    </row>
	    <row>
	      <entry><option>白</option></entry>
	      <entry>37</entry>
	      <entry>47</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

	    <example id="colorecho">
	      <title>显示彩色文本</title>
	      <programlisting>&colorecho;</programlisting>
	    </example>

	    <example id="horserace">
	      <title><quote>赛马</quote>游戏</title>
	      <programlisting>&horserace;</programlisting>
	    </example>

	<para>也请参考<xref linkend="hashexample">. </para>


	<caution><para>然而, 这里有一个严重的问题. 
			<emphasis>ANSI转义序列是不可移植的. </emphasis>
			在某些终端(或控制台)上运行的好好的代码, 
			可能在其他终端上根本没办法运行. 
			<quote>彩色</quote>的脚本可能会在脚本作者的机器上运行的非常好, 
			但是在其他人的机器上就可能产生不可读的输出. 
			因为这个原因, 使得<quote>彩色</quote>脚本的用途大打折扣, 
	  而且很有可能使得这项技术变成华而不实的小花招, 甚至成为一个<quote>玩具</quote>. </para></caution>

	<para>Moshe Jacobson的<command>彩色</command>工具(<ulink
			url="http://runslinux.net/projects.html#color">http://runslinux.net/projects.html#color</ulink>)能够非常容易的简化ANSI转义序列的使用. 
		这个工具使用清晰而且富有逻辑的语法代替了之前讨论的难用的结构. 
	  </para>

        <para>Henry/teikedvl也开发了一个类似的工具(<ulink
          url="http://scriptechocolor.sourceforge.net/">http://scriptechocolor.sourceforge.net/</ulink>)用来简化彩色脚本的创建. </para>


      </sect1> <!-- "Colorizing" scripts -->



      <sect1 id="optimizations">
        <title>优化</title>

	<para>大部分shell脚本在处理不太复杂的问题的时候, 使用的都是小吃店(快速但是并不优雅)的方式. 
	  正因为这样, 所以优化脚本的速度并不是一个大问题. 
	  考虑一下这种情况, 当脚本正在处理一个重要任务的时候, 
	  虽然这个脚本能够处理的很好, 但是它运行的速度实在太慢. 
	  在这种情况下, 使用编译语言重写它其实也不是一种很合适的办法. 
	  最简单的办法其实就是重写这个脚本执行效率低下的部分. 
	  那么, 是否这种办法可以成为处理效率低下的shell脚本的一种原则? 
	  </para>

	<para>仔细检查脚本中循环的部分. 因为重复的操作非常耗时. 
	  如果有可能的话, 尽量删除掉循环中比较耗时的操作. 
	  </para>

	  <para>优先使用<link linkend="builtinref">内建命令</link>, 
		  而不是系统命令. 这是因为内建命令执行得更快, 
		  并且在调用时, 一般都不会产生子进程. 
	  </para>
	
	<para>避免使用不必要的命令, 尤其是<link
	  linkend="piperef">管道</link>中的命令. 
	    <programlisting>cat "$file" | grep "$word"

grep "$word" "$file"

#  上面的两行具有相同的效果, 
#+ 但是第二行运行的更快, 因为它不产生子进程. </programlisting>
	  <link linkend="catref">cat</link>命令看起来经常在脚本中被滥用. 
	  </para>

	<para>使用<link linkend="timref">time</link>和<link
	  linkend="timesref">times</link>工具来了解计算所消耗的时间. 
	  可以考虑使用C语言, 甚至是汇编语言来重写时间消耗比较大的代码部分. 
	  </para>

	  <para>尝试尽量减少文件I/O的操作. 因为Bash在处理文件方面, 
		  显得并不是很有效率, 所以可以在脚本中考虑使用更合适的工具, 
	   比如<link linkend="awkref">awk</link>或<link
	   linkend="perlref">Perl</link>. </para>

	 <para>使用结构化的思想来编写脚本, 并且按照需求将各个模块组织并紧密结合起来. 
	   一些适用于高级语言的优化技术也可以用在脚本上, 
	   但是有些技术, 比如, 循环展开优化(loop unrolling), 
	   就根本用不上. 关于上面的讨论, 可以根据经验来取舍. </para>

	 <para>怎么才能很好的减少脚本的执行时间, 让我们看一个优秀的例子, 
	   <xref linkend="monthlypmt">. </para>

      </sect1> <!-- Optimizations -->



      <sect1 id="assortedtips">
        <title>各种小技巧</title>

      <itemizedlist>

	<listitem>

		<para>为了记录在某个(或某些)特定会话中用户脚本的运行状态, 
			可以将下面的代码添加到你想要跟踪记录的脚本中. 
	    添加的这段代码会将脚本名和调用次数记录到一个连续的文件中. 
	    </para>

	  <para>
	  <programlisting># 添加(>>)下面的代码, 到你想跟踪记录的脚本末尾. 

whoami>> $SAVE_FILE    # 记录调用脚本的用户. 
echo $0>> $SAVE_FILE   # 脚本名. 
date>> $SAVE_FILE      # 记录日期和时间. 
echo>> $SAVE_FILE      # 空行作为分隔符. 

#  当然, 我们应该在~/.bashrc中定义并导出变量SAVE_FILE. 
#+ (看起来有点像~/.scripts-run)</programlisting>
          </para>
	</listitem>

	<listitem>
	  <para><anchor id="prependref"></para>
	  <para><token>&gt;&gt;</token>操作符可以在文件末尾添加内容. 
		  如果你想在文件的<emphasis>头部</emphasis>添加内容怎么办, 
		 难道要粘贴到文件头? 
	    </para>

	  <para>
	  <programlisting>file=data.txt
title="***This is the title line of data text file***"

echo $title | cat - $file >$file.new
# "cat -" 将stdout连接到$file.
#  最后的结果就是生成了一新文件, 
#+ 并且成功的将$title的内容附加到了文件的*开头*. </programlisting>
	  </para>

	  <para>这是之前的<xref linkend="prependex">脚本的简化版本. 
	    当然, <link linkend="sedref">sed</link>也能做到. </para>


	</listitem>

	<listitem>
	  <para>shell脚本也可以象一个内嵌到脚本的命令那样被调用, 
		  比如<emphasis>Tcl</emphasis>或<emphasis>wish</emphasis>脚本, 
		  甚至是<link linkend="makefileref">Makefile</link>. 
		  在C语言中, 它们可以作为一个外部的shell命令被<replaceable>system()</replaceable>函数调用, 比如, 
	   <replaceable>system("script_name");</replaceable>. </para>
	</listitem>

	<listitem>
          <para>将一个内嵌<firstterm>sed</firstterm>或<firstterm>awk</firstterm>的脚本内容赋值给一个变量, 能够提高<link
	    linkend="shwrapper">shell包装</link>脚本的可读性. 
	    请参考<xref linkend="mailformat">和<xref linkend="coltotaler3">. </para>
	</listitem>

	<listitem>
	  <para>将你最喜欢的变量定义和函数实现都放到一个文件中. 
	    在你需要的时候, 
		通过使用<link linkend="dotref">点</link>(<command>.</command>)命令, 
		或者<link linkend="sourceref">source</link>命令, 
		来将这些<quote>库文件</quote><quote>包含</quote>到脚本中. 
	    </para>

	  <para>  
            <programlisting># 脚本库
# ------ -------

# 注:
# 这里没有"#!". 
# 也没有"真正需要执行的代码". 


# 有用的变量定义

ROOT_UID=0             # root用户的$UID为0. 
E_NOTROOT=101          # 非root用户的出错代码. 
MAXRETVAL=255          # 函数最大的返回值(正值). 
SUCCESS=0
FAILURE=-1



# Functions

Usage ()               # "Usage:"信息. (译者注: 即帮助信息)
{
  if [ -z "$1" ]       # 没有参数传递进来. 
  then
    msg=filename
  else
    msg=$@
  fi

  echo "Usage: `basename $0` "$msg""
}  


Check_if_root ()       # 检查运行脚本的用户是否为root. 
{                      # 摘自"ex39.sh". 
  if [ "$UID" -ne "$ROOT_UID" ]
  then
    echo "Must be root to run this script."
    exit $E_NOTROOT
  fi
}  


CreateTempfileName ()  # 创建"唯一"的临时文件. 
{                      # 摘自"ex51.sh". 
  prefix=temp
  suffix=`eval date +%s`
  Tempfilename=$prefix.$suffix
}


isalpha2 ()            # 测试*整个字符串*是否都是由字母组成的. 
{                      # 摘自"isalpha.sh". 
  [ $# -eq 1 ] || return $FAILURE

  case $1 in
  *[!a-zA-Z]*|"") return $FAILURE;;
  *) return $SUCCESS;;
  esac                 # 感谢, S.C.
}


abs ()                           # 绝对值. 
{                                # 注意: 最大的返回值 = 255. 
  E_ARGERR=-999999

  if [ -z "$1" ]                 # 需要传递参数. 
  then
    return $E_ARGERR             # 返回错误. 
  fi

  if [ "$1" -ge 0 ]              # 如果是非负值, 
  then                           #
    absval=$1                    # 那就是绝对值本身. 
  else                           # 否则, 
    let "absval = (( 0 - $1 ))"  # 改变符号. 
  fi  

  return $absval
}


tolower ()             #  将传递进来的参数字符串
{                      #+ 转换为小写. 

  if [ -z "$1" ]       #  如果没有参数传递进来. 
  then                 #+ 打印错误消息
    echo "(null)"      #+ (C风格的void指针错误消息)
    return             #+ 并且从函数中返回. 
  fi  

  echo "$@" | tr A-Z a-z
  # 转换所有传递进来的参数($@). 

  return

# 使用命令替换, 将函数的输出赋值给变量. 
# 举例: 
#    oldvar="A seT of miXed-caSe LEtTerS"
#    newvar=`tolower "$oldvar"`
#    echo "$newvar"    # 一串混合大小写的字符全部转换为小写
#
# 练习: 重写这个函数, 
#           将传递进来的参数全部转换为大写[容易].
}</programlisting>
          </para>

	</listitem>

	<listitem>
	  <para>使用特殊目的注释头来增加脚本的条理性和可读性. 
	    </para>
	  <para><programlisting>## 表示注意. 
rm -rf *.zzy   ##  "rm"命令的"-rf"选项非常的危险. 
               ##+ 尤其对通配符, 就更危险. 

#+ 表示继续上一行. 
#  这是多行注释的第一行, 
#+ 
#+ 这是最后一行. 

#* 表示标注. 

#o 表示列表项. 

#> 表示另一种观点. 
while [ "$var1" != "end" ]    #> while test "$var1" != "end"</programlisting></para>
	
	</listitem>
	
	<listitem>
		<para><link linkend="testconstructs1">if-test</link>结构有一种聪明的用法, 
			用来注释代码块. </para>
	      
	  <para>    
	      <programlisting>#!/bin/bash

COMMENT_BLOCK=
#  如果给上面的变量赋值, 
#+ 就会出现令人不快的结果. 

if [ $COMMENT_BLOCK ]; then

Comment block --
=================================
This is a comment line.
This is another comment line.
This is yet another comment line.
=================================

echo "This will not echo."

Comment blocks are error-free! Whee!

fi

echo "No more comments, please."

exit 0</programlisting>
	  </para>    

	  <para>比较这种用法, 和<link linkend="cblock1">使用here document注释代码块</link>之间的区别. </para>    

	</listitem>

	<listitem>
		<para>使用<link linkend="xstatvarref">$?退出状态变量</link>, 
			因为脚本可能需要测试一个参数是否都是数字, 
			以便于后边可以把它当作一个整数来处理. 
	    </para>

	  <para>  
	    <programlisting>#!/bin/bash

SUCCESS=0
E_BADINPUT=65

test "$1" -ne 0 -o "$1" -eq 0 2>/dev/null
# 整数要不就是0, 要不就是非0值. (译者注: 感觉像废话 . . .)
# 2>/dev/null禁止输出错误信息. 

if [ $? -ne "$SUCCESS" ]
then
  echo "Usage: `basename $0` integer-input"
  exit $E_BADINPUT
fi

let "sum = $1 + 25"             # 如果$1不是整数, 就会产生错误. 
echo "Sum = $sum"

# 任何变量都可以使用这种方法来测试, 而不仅仅适用于命令行参数. 

exit 0</programlisting>
          </para>
	</listitem>


        <listitem>

	  <para><anchor id="rvt">函数的返回值严格限制在0 - 255之间. 
	    使用全局变量或者其他方法来代替函数返回值, 通常都很容易产生问题. 
	    从函数中, 返回一个值到脚本主体的另一个办法是, 
		将这个"返回值"写入到<filename>stdout</filename>(通常都使用<link linkend="echoref">echo</link>命令), 
		然后将其赋值给一个变量. 
		这种做法其实就是<link linkend="commandsubref">命令替换</link>的一个变种. </para>

	    <example id="multiplication">
	      <title>返回值小技巧</title>
	      <programlisting>&multiplication;</programlisting>
	    </example>

	  <para>相同的技术也可以用在字符串上. 
	    这意味着函数可以<quote>返回</quote>非数字的值. </para>
	    
	  <para>
	  <programlisting>capitalize_ichar ()          #  将传递进来的字符串的
{                            #+ 首字母转换为大写. 

  string0="$@"               # 能够接受多个参数. 

  firstchar=${string0:0:1}   # 首字母. 
  string1=${string0:1}       # 余下的字符. 

  FirstChar=`echo "$firstchar" | tr a-z A-Z`
                             # 将首字母转换为大写. 

  echo "$FirstChar$string1"  # 输出到stdout. 

}  

newstring=`capitalize_ichar "every sentence should start with a capital letter."`
echo "$newstring"          # Every sentence should start with a capital letter.</programlisting> 
	  </para>

	  <para>使用这种办法甚至能够<quote>返回</quote>多个值. </para>

	    <example id="sumproduct">
	      <title>返回多个值的技巧</title>
	      <programlisting>&sumproduct;</programlisting>
	    </example>

	</listitem>

        <listitem>
			<para>下一个技巧, 是将<link linkend="arrayref">数组</link>传递给<link linkend="functionref">函数</link>的技术, 
				然后<quote>返回</quote>一个数组给脚本的主体. 
	    </para>

		<para>使用<link linkend="commandsubref">命令替换</link>将数组中的所有元素(元素之间用空格分隔)赋值给一个变量, 
			这样就可以将数组传递到函数中了. 
			我们之前提到过一种返回值的策略, 就是将要从函数中返回的内容, 
			用<emphasis>echo</emphasis>命令输出出来, 
			然后使用命令替换或者<command>( ... )</command>操作符, 
			将函数的输出(也就是我们想要得返回值)保存到一个变量中. 
			如果我们想让函数<quote>返回</quote>数组, 当然也可以使用这种策略. 
	    </para>

	    <example id="arrfunc">
	      <title>传递数组到函数, 从函数中返回数组</title>
	      <programlisting>&arrfunc;</programlisting>
	    </example>

	  <para>如果想更加了解如何将数组传递到函数中, 
	    请参考<xref linkend="lifeslow">, 这是一个精心制作的例子. </para>

        </listitem>

        <listitem>
			<para>利用双括号结构, 就可以让我们使用C风格的语法, 
				在<link linkend="forloopref1">for</link>循环和<link
	    linkend="whileloopref">while</link>循环中, 设置或者增加变量. 
	    请参考<xref linkend="forloopc">和<xref linkend="whloopc">. </para>
	</listitem>

	<listitem>
	  <para>如果在脚本的开头设置<link linkend="pathref">path</link>和<link
			  linkend="umaskref">umask</link>的话, 就可以增加脚本的<quote>可移植性</quote> 
		  -- 即使在那些被用户将<varname>$PATH</varname>和<command>umask</command>弄糟了的机器上, 也可以运行. 
	      <programlisting>#!/bin/bash
PATH=/bin:/usr/bin:/usr/local/bin ; export PATH
umask 022   # 脚本创建的文件所具有的权限是755. 

# 感谢Ian D. Allen提出这个技巧. </programlisting></para>
	</listitem>

        <listitem>
	  <para>一项很有用的技术是, 
		  <emphasis>重复地</emphasis>将一个过滤器的输出(通过管道)传递给这个相同的过滤器, 
	    但是这两次使用不同的参数和选项. 
	    尤其是<link linkend="trref">tr</link>和<link linkend="grepref">grep</link>, 非常适合于这种情况. </para>

	  <para>
	  <programlisting># 摘自例子"wstrings.sh". 

wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`</programlisting>
	  </para>

	    <example id="agram">
	      <title>anagram游戏</title>
	      <programlisting>&agram;</programlisting>
	    </example>

	  <para>也请参考<xref linkend="constat">, <xref
	    linkend="cryptoquote">, 和<xref linkend="soundex">. </para>

	</listitem>

	<listitem>
	  <para>使用<quote><link linkend="anonheredoc0">匿名的here
	    document</link></quote>来注释代码块, 
		这样就不用在每个注释行前面都加上<token>#</token>了. 
		请参考<xref linkend="commentblock">. </para>
	</listitem>

	<listitem>
		<para>如果一个脚本的运行依赖于某个命令, 
			而且这个命令没被安装到运行这个脚本的机器上, 
			那么在运行的时候就会产生错误. 
	    我们可以使用<link linkend="whatisref">whatis</link>命令来避免这种可能产生的问题. 
	    </para>

	  <para>
	    <programlisting>CMD=command1                 # 第一选择. 
PlanB=command2               # 如果第一选择不存在就选用这个. 

command_test=$(whatis "$CMD" | grep 'nothing appropriate')
#  如果在系统中没找到'command1', 
#+ 那么'whatis'将返回"command1: nothing appropriate."
#
#  另一种更安全的做法是: 
#     command_test=$(whereis "$CMD" | grep \/)
#  但是下面的测试条件应该反过来, 
#+ 因为变量$command_test只有在$CMD存在于系统上的时候, 
#+ 才会有内容. 
#     (感谢, bojster.)


if [[ -z "$command_test" ]]  # 检查命令是否存在. 
then
  $CMD option1 option2       #  使用选项来调用command1. 
else                         #  否则,
  $PlanB                     #+ 运行command2.  
fi</programlisting>
          </para>
	</listitem>

	<listitem>

		<para>在错误的情况下, 
		<link linkend="ifgrepref">if-grep test</link>可能不会返回期望的结果, 
		因为出错文本是输出到<filename>stderr</filename>上, 
		而不是<filename>stdout</filename>. 
	      <programlisting>if ls -l nonexistent_filename | grep -q 'No such file or directory'
  then echo "File \"nonexistent_filename\" does not exist."
fi</programlisting></para>

		  <para>将<filename>stderr</filename><link 
				  linkend="ioredirref">重定向</link>到<filename>stdout</filename>上, 就可以解决这个问题. 
	      <programlisting>if ls -l nonexistent_filename 2&gt;&1 | grep -q 'No such file or directory'
#                             ^^^^
  then echo "File \"nonexistent_filename\" does not exist."
fi

# 感谢, Chris Martin指出这一点.</programlisting></para>

	</listitem>


	<listitem>
		<para><link linkend="runpartsref">run-parts</link>命令可以很方便的依次运行一组命令脚本, 
			尤其是和<link linkend="cronref">cron</link>或<link
	    linkend="atref">at</link>组合使用的时候. </para>
	</listitem>

	<listitem>
		<para>如果可以在shell脚本中调用X-Windows的小工具, 那该有多好. 
			目前已经有一些工具包可以完成这种功能, 
			比如<emphasis>Xscript</emphasis>, 
			<emphasis>Xmenu</emphasis>,
			和<emphasis>widtools</emphasis>. 
			头两种工具包已经不再被维护了. 
	    幸运的是, 我们还可以从<ulink
	    url="http://www.batse.msfc.nasa.gov/~mallozzi/home/software/xforms/src/widtools-2.0.tgz">这里</ulink>下载第三种工具包, 
	    <emphasis>widtools</emphasis>. 
	    </para>

		<caution><para>要想使用<emphasis>widtools</emphasis>(widget 
				tools)工具包, 必须先安装<emphasis>XForms</emphasis>库. 
	    除此之外, 在典型的Linux系统上编译之前, 需要正确的编辑它的<link
	    linkend="makefileref">Makefile</link>. 
	    最后, 在提供的6个部件中, 有3个不能工作(事实上, 会产生段错误). </para></caution>


          <para><anchor id="dialogref"></para>

	  <para><emphasis>dialog</emphasis>工具集提供了一种从shell脚本中调用<quote>对话框</quote>窗口部件的方法.  The
		  原始的<command>dialog</command>工具包只能工作在文本的控制台模式下, 
		  但是后续的类似工具, 比如<command>gdialog</command>,
	    <command>Xdialog</command>, 和<command>kdialog</command>都是基于X-Windows窗口部件集合的. </para>

    <example id="dialog">
      <title><command>从shell脚本中调用窗口部件</command></title>
      <programlisting>&dialog;</programlisting>
    </example>

	  <para>其他在脚本中使用窗口部件的工具, 
	    比如<emphasis>Tk</emphasis>或<emphasis>wish</emphasis>
	    (<emphasis>Tcl</emphasis>派生物), 
	    <emphasis>PerlTk</emphasis>(带有Tk扩展的Perl), 
	    <emphasis>tksh</emphasis>(带有Tk扩展的ksh), 
		<emphasis>XForms4Perl</emphasis>(带有XForms扩展的Perl), 
		<emphasis>Gtk-Perl</emphasis>(带有Gtk扩展的Perl), 
		或<emphasis>PyQt</emphasis>(带有Qt扩展的Python). </para>

	</listitem>


	<listitem>

	  <para>为了对复杂脚本做多次的修正, 
	    可以使用<emphasis>rcs</emphasis>修订控制系统包. </para>

	  <para>使用这个软件包的好处之一就是可以自动升级ID头标志. 
	    <emphasis>rcs</emphasis>包中的<command>co</command>命令可以对特定的保留关键字作参数替换, 
	    比如, 可以使用下面这行代码来替换掉脚本中的<parameter>#$Id$</parameter>, 
	      <programlisting>#$Id: hello-world.sh,v 1.1 2004/10/16 02:43:05 bozo Exp $</programlisting></para>

	</listitem>


      </itemizedlist>

      </sect1> <!-- Assorted Tips -->



      <sect1 id="securityissues">
        <title>安全问题</title>

      <sect2 id="infectedscripts">
        <title>被感染的脚本</title>

	<para>在这里对脚本安全进行一个简短的介绍非常合适. 
	  shell脚本可能会包含<emphasis>蠕虫</emphasis>,
	  <emphasis>特洛伊木马</emphasis>, 甚至可能会中<emphasis>病毒</emphasis>.
	  由于这些原因, 永远不要用root身份来运行脚本(或者将自己不太清楚的脚本插入到<filename
		  class="directory">/etc/rc.d</filename>里面的系统启动脚本中),
	  除非你确定这是值得信赖的源代码, 或者你已经小心的分析了这个脚本, 
	  并确定它不会产生什么危害. 
	  </para>

	<para>Bell实验室以及其他地方的病毒研究人员, 包括M.
	  Douglas McIlroy, Tom Duff, 和Fred Cohen已经研究过了shell脚本病毒的实现. 
	  他们认为即使是初学者也可以很容易的编写脚本病毒, 
	  比如<quote>脚本小子(script kiddie)</quote>, 就写了一个. 
	    <footnote><para>请参考Marius van Oers的文章, <ulink
	      url="http://www.virusbtn.com/magazine/archives/200204/malshell.xml">Unix
	      Shell Scripting Malware</ulink>, 还有列在<link
	      linkend="biblioref">参考书目</link>中的<emphasis>Denning</emphasis>的书目. </para></footnote>
	  </para>

	  <para>这也是学习脚本编程的另一个原因. 
		  能够很好地了解脚本, 就可以让的系统免受骇客的攻击和破坏. 
	  </para>

     </sect2> <!-- Infected Shell Scripts -->

      <sect2 id="hidingsource">
        <title>隐藏Shell脚本源代码</title>

	<para>出于安全目的, 让脚本不可读, 也是有必要的. 
	  如果有软件可以将脚本转化为相应的二进制可执行文件就好了. 
	  Francisco Rosales的<ulink
	  url="http://www.datsi.fi.upm.es/~frosal/sources/">shc -
	  generic shell script compiler</ulink>可以出色的完成这个任务. </para>

	<para>不幸的是, 根据<ulink
	 url="http://www.linuxjournal.com/article/8256">发表在2005年10月的<emphasis>Linux Journal</emphasis>上的一篇文章</ulink>, 
	 二进制文件, 至少在某些情况下, 可以被恢复成原始的脚本代码. 
	 但是不管怎么说, 对于那些技术不高的骇客来说, 这仍然是一种保证脚本安全的有效办法. 
	 </para>

     </sect2> <!-- Hiding Shell Script Source -->

      </sect1> <!-- Security -->



      <sect1 id="portabilityissues">
        <title>可移植性问题</title>

	<para>这本书主要描述的是, 在GNU/Linux系统上, 如何处理特定于Bash的脚本. 
	  但是使用<command>sh</command>和<command>ksh</command>的用户仍然会从这里找到很多有价值的东西. .</para>

	<para>碰巧, 许多不同的shell脚本语言其实都遵循POSIX 1003.2标准. 
		如果使用<option>--posix</option>选项来调用Bash, 
	   或者在脚本头插入<command>set -o posix</command>, 
	  那么将会使Bash与这个标准非常接近地保持一致. 
	  另一种办法就是在脚本头使用
	    <programlisting>#!/bin/sh</programlisting>
	  而不是
	    <programlisting>#!/bin/bash</programlisting>
	  注意在Linux或者某些特定的UNIX上, <filename>/bin/sh</filename>其实只是一个指向<filename>/bin/bash</filename>的<link
	  linkend="linkref">链接</link>, 
	  并且使用这种方法调用脚本的话, 将会禁用Bash的扩展功能. 
	  </para>

	  <para>大多数的Bash脚本都好像运行在<command>ksh</command>上一样, 
		  反过来看, 这是因为Chet Ramey一直致力于将<command>ksh</command>的特性移植到Bash的最新版本上. 
	  </para>

	  <para>对于商业UNIX机器来说, 如果在脚本中包含了使用GNU特性的标准命令, 
		 那么这些脚本可能不会正常运行. 
	  但是在最近几年, 这个问题得到了极大的改观, 
	  这是因为即使在<quote>大块头</quote>UNIX上, 
	  GNU工具包也非常好的替换掉了同类的私有工具. 
	  对于原始的UNIX来说, 
	  <ulink url="http://linux.oreillynet.com/pub/a/linux/2002/02/28/caldera.html">源代码的火山喷发</ulink>加剧了这种趋势. 
	  </para>

	<para>Bash具有的某些特性是传统的Bourne shell所缺乏的. 
	  下面就是其中的一部分: 

	<itemizedlist>

	<listitem>
	<para>某些扩展的<link
	linkend="invocationoptionsref">调用选项</link></para>
	</listitem>

        <listitem>
	<para>使用<command>$(    )</command>形式的<link linkend="commandsubref">命令替换</link></para>
	</listitem>

	<listitem>
	<para>某些<link linkend="stringmanip">字符串处理</link>操作符</para>
	</listitem>

	<listitem>
	<para><link linkend="processsubref">进程替换</link></para>
	</listitem>

	<listitem>
	<para>Bash特有的<link linkend="builtinref">内建命令</link></para>
	</listitem>

	</itemizedlist>
	</para>

	<para>请参考<ulink url="ftp://ftp.cwru.edu/pub/bash/FAQ">Bash
	   F.A.Q.</ulink>, 你将会获得完整的列表. </para>

      </sect1> <!-- Portability Issues -->



      <sect1 id="winscript">
        <title>Windows下的shell脚本</title>

		<para>即使用户使用<emphasis>其他的操作系统</emphasis>来运行类UNIX的shell脚本, 
		其实也能够从本书的大部分课程中受益. 
	  Cygnus公司的<ulink
	  url="http://sourceware.cygnus.com/cygwin/">
	  Cygwin</ulink>程序包和Mortice Kern Associates的<ulink
	  url="http://www.mkssoftware.com/">MKS工具集</ulink>都能够给Windows添加处理shell脚本的能力. 
	  </para>

        <para>这其实暗示了Windows将来的版本可能会包含处理类Bash命令行脚本的能力, 不过, 还是让我们拭目以待吧. </para>

      </sect1> <!-- Shell Scripting Under Windows -->



  </chapter> <!-- Miscellany -->



  <chapter id="bash2">
    <title>Bash, 版本2与版本3</title>

    <sect1 id="bashver2">
      <title>Bash, 版本2</title>

      <para><anchor id="bash2ref"></para>

		  <para>当前比较流行的<emphasis>Bash</emphasis>版本有两个, 
			  版本2.xx.y或版本3.xx.y, 
			  这两个中的某一个估计就运行在你的机器上. 
	      <screen><prompt>bash$ </prompt><userinput>echo $BASH_VERSION</userinput>
<computeroutput>2.05.b.0(1)-release</computeroutput>
	      </screen>
	经典Bash脚本语言版本2的主要升级内容, 增加了数组变量, 

	<footnote><para>Chet Ramey承诺会在Bash未来的版本中支持关联数组(一个Perl特性). 
			但是到了版本3, 他的承诺还没兑现. 
	  </para></footnote>

	字符串和参数扩展, 还添加了间接变量引用的一种更好的方法, 以及其他特性. 
	</para>

      <example id="ex77">
	<title>字符串扩展</title>
	<programlisting>&ex77;</programlisting>
      </example>

      <para><anchor id="varrefnew"></para>
      <example id="ex78">
	<title>间接变量引用 - 新方法</title>
	<programlisting>&ex78;</programlisting>
      </example>
	
      <example id="resistor">
	<title>使用间接变量引用的简单数据库应用</title>
	<programlisting>&resistor;</programlisting>
      </example>

      <example id="ex79">
	<title>使用数组和其他的小技巧来处理4人随机打牌</title>
	<programlisting>&ex79;</programlisting>
      </example>

    </sect1> <!-- Bash, Version 2 -->



    <sect1 id="bashver3">
      <title>Bash, 版本3</title>

      <para><anchor id="bash3ref"></para>

		  <para>2004年7月27日, Chet Ramey发布了Bash版本3. 
			  这一版本修复了相当多的bug, 并加入了一些新特性. 
	</para>

      <para>新增加的一些属性有: 

      <itemizedlist>
	<listitem>
	  <para>一个新的, 更加通用的<command>{a..z}</command><link
	  linkend="braceexpref">大括号扩展</link>操作符. 
               <programlisting>#!/bin/bash

for i in {1..10}
#  比下面的方式更简单, 更直接
#+ for i in $(seq 10)
do
  echo -n "$i "
done

echo

# 1 2 3 4 5 6 7 8 9 10
</programlisting>

         </para>
	</listitem>

	<listitem>
		<para><command>${!array[@]}</command>操作符, 
			用于扩展给定<link linkend="arrayref">数组</link>所有元素索引. 
	      <programlisting>#!/bin/bash

Array=(element-zero element-one element-two element-three)

echo ${Array[0]}   # 元素0
                   # 数组的第一个元素. 

echo ${!Array[@]}  # 0 1 2 3
                   # 数组的全部索引. 

for i in ${!Array[@]}
do
  echo ${Array[i]} # 元素0
                   # 元素1
                   # 元素2
                   # 元素3
                   #
                   # 数组的全部元素. 
done</programlisting>
         </para>
	</listitem>

	<listitem>
	  <para><anchor id="regexmatchref"></para>
	  <para><command>=~</command> <link linkend="regexref">正则表达式</link>匹配操作符, 在<link
	    linkend="dblbrackets">双中括号</link>测试表达式中的应用. 
	    (Perl也有一个类似的操作符. )</para>

	      <para><programlisting>#!/bin/bash

variable="This is a fine mess."

echo "$variable"

if [[ "$variable" =~ "T*fin*es*" ]]
# 在[[ 双中括号 ]]中使用=~操作符进行正则匹配. 
then
  echo "match found"
      # match found
fi</programlisting></para>

              <para>或者, 更有用的用法: </para>

	      <para><programlisting>#!/bin/bash

input=$1


if [[ "$input" =~ "[1-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]" ]]
# NNN-NN-NNNN
# 每个N都是一个数字. 
# 但是, 第一个数字不能为0. 
then
  echo "Social Security number."
  # 处理SSN.
else
  echo "Not a Social Security number!"
  # 或者, 要求正确的输入. 
fi</programlisting></para>

			  <para>还有一个使用<command>=~</command>操作符的例子, 
				  请参考<xref linkend="whx">和<xref linkend="mailboxgrep">. </para>


	</listitem>


      </itemizedlist>
      </para>

      <caution>
      <para>Bash 3.0版本的更新, 将会导致一小部分为早期Bash版本编写的脚本不能工作. 
        <emphasis>对于一些重要的早期脚本来说, 需要进行测试, 以保证它们在新版本的Bash中也可以正常工作!</emphasis></para>
      <para>如果发生确实不能正常工作的情况, 
        那么<emphasis>高级Bash脚本编程指南</emphasis>中的某些脚本就必须被修复(请参考<xref linkend="objoriented">和<xref linkend="tout">). </para>
      </caution>


       <sect2> <!-- Bash, Version 3.1 -->
         <title>Bash, 版本3.1</title>

		 <para>Bash3.1版本的更新修复了一部分bug, 
			 并且在其他方面也做了一些小的修改. </para>

          <itemizedlist>

	    <listitem>
			<para><token>+=</token>操作符是新添加的, 
			可以放在之前只能有<token>=</token>赋值操作符出现的地方. </para>

	      <para><programlisting>a=1
echo $a        # 1

a+=5           # 在Bash的早期版本中就不行, 只能运行在Bash3.1或更新的版本上. 
echo $a        # 15

a+=Hello
echo $a        # 15Hello</programlisting>
	      </para>

		  <para>在这里, <token>+=</token>是作为<firstterm>字符串连接</firstterm>操作符. 
		注意, 它在这种特定的上下文中所表现出来的行为, 
		与在<link linkend="letref">let</link>结构中所表现出来的行为是不同的. 
		</para>

	      <para><programlisting>a=1
echo $a        # 1

let a+=5       # 整数的算术运算, 而不是字符串连接. 
echo $a        # 6

let a+=Hello   # 不会给a"添加"任何东西.  
echo $a        # 6</programlisting>
	      </para>

	    </listitem>

          </itemizedlist>


       </sect2> <!-- Bash, Version 3 -->

    </sect1> <!-- Bash, Version 3 -->

  </chapter> <!-- Bash, versions 2 and 3 -->

  </part> <!-- Part 4 (Advanced Topics) -->



  <chapter id="endnotes">
    <title>后记</title>


    <sect1 id="authorsnote">
      <title>作者后记</title>

    <epigraph>
      <para>doce ut discas</para>
      <para>(Teach, that you yourself may learn.)</para>
    </epigraph>


      <para>我怎么会写这么一本与Bash脚本相关的书? 这有一个奇怪的故事. 
		  让我们把时间退回到几年前, 那时候我正准备学习shell脚本编程 -- 
		  除了阅读一本这方面的好书, 还有其他比这更好的学习方法么? 
	我苦苦的寻找一本能够覆盖关于这个主题所有部分内容的书籍. 
	我还希望这本书在讲解那些难懂的概念时, 能够做到深入浅出, 
	并且能附以详细的例子, 最好这些例子还能有很好的注释. 
	    <footnote><para>这真是一种声名狼藉并<emphasis>使人郁闷到死</emphasis>的技术. </para></footnote>
	事实上, 我想要找的是一本<emphasis>完美的书</emphasis>, 
	或者是类似的东西. 不幸的是, 它根本不存在, 如果我想要的话, 
	那我就非得自己写一本了. 正因为如此, 所以这本书才会呈现在这里. 
	</para>

      <para>这使我想起一个关于疯教授的虚构故事. 
		  这个家伙非常的古怪. 
		  当他在图书馆, 或者在书店, 任何地方都行 -- 
		  看到一本书的时候, 任何书 -- 
		  他都会突发奇想的认为, 他也可以写这本书, 早就应该写了 -- 
		  而且他会写得更好. 
		  因此, 他会马上冲回家, 然后着手开始写书, 
		  他甚至将书名都起的和原书的名字差不多. 
		  许多年过去, 当他去世之后, 他写了几千本书, 可能Asimov(译者注: 
		  美国的一个高产作家)在他面前都会觉得羞愧. 
		  这些书可能没有那么好 -- 谁知道 -- 但是这又有什么关系? 
		  这是一个生活在梦想中的家伙, 即使他被梦想所迷惑, 所驱使 . . .
		  但是我还是忍不住有点钦佩这个老笨蛋. 
        </para>

    </sect1> <!-- Author's Note -->


    
    <sect1 id="aboutauthor">
      <title>关于作者</title>
      <subtitle>这家伙到底是谁? </subtitle>

      <para>作者没有任何特殊的背景或资格, 只有一颗冲动的心, 用来写作. 
          <footnote><para>这种事谁都可以做. 但是有些人不能...想要拿到MCSE证书. </para></footnote>
	这本书有点偏离他主要的工作范围, 
	<ulink url="http://personal.riverusers.com/~thegrendel/hmw50.zip">
	HOW-2 Meet Women: The Shy Man's Guide to
	Relationships</ulink>. 他还写了另一本书, <ulink
	url="http://tldp.org/HOWTO/Software-Building-HOWTO.html">Software-Building
	HOWTO</ulink>. 
	最近, 他正打算编写一些短篇小说. </para>

      <para>从1995年成为一个Linux用户以来(Slackware 2.2, kernel 1.2.1), 
	作者已经发表了一些软件包, 
	包括<ulink
	url="http://ibiblio.org/pub/Linux/utils/file/cruft-0.2.tar.gz">cruft</ulink>
	一次一密乱码本(one-time pad)加密工具, <ulink
		url="http://ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz">mcalc</ulink>按揭计算器(mortgage calculator), 
	软件<ulink url="http://ibiblio.org/pub/Linux/games/amusements/judge-1.0.tar.gz">judge</ulink>是Scrabble拼字游戏的自动求解包, 
	和软件包<ulink url="http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz">yawl</ulink>一起组成猜词表. 
	他的编程之路是从CDC 3800的机器上编写FORTRAN程序开始的, 
	但是那段日子一点都不值得怀念. 
	</para>

       <para>作者和他的妻子, 还有他们的狗生活在一个偏远的社区里, 
         他认为人性是脆弱的. </para>

    </sect1> <!-- About the Author -->

    <sect1 id="translator_china">
      <title>译者后记</title>

     <sect2 id="translator1_rojy_yang">
       <title>杨春敏</title>
	   <para>为了学习Bash脚本知识, 我找到了本书, 并且做了详细的笔记. </para>
	   <para>因为是初学, 随着笔记的增加, 发现越来越像是翻译. </para>
	   <para>考虑到平时总在网上看其他人的免费资料, 有感而发, 才促成了本书的翻译版. </para>
	   <para>我从来没考虑过翻译书会是一件多么复杂和艰苦的事情. </para>
	   <para>但是随着翻译版的进行, 我体会了个中的酸甜苦辣, 
	   可能我这辈子只会有这么一次翻译书的经历, 我甚至不敢说我翻译的有多好, 但是我尽力了. </para>
	   <para>希望为大家做些贡献, 退一步讲, 我自己也收获了许多. </para>
	   <para>想不到的是, 有许多朋友关心翻译版, 我在这里由衷的对你们表示<emphasis>感谢!</emphasis></para>
	   <para>最后感谢原书作者写了这么一本好书, 才能给我这个翻译的机会. </para>
	 </sect2> <!-- translator1_rojy_yang -->

     <sect2 id="translator2_yi_huang">
       <title>黄毅</title>
	   <para>我在www.linuxsir.org的SHELL版块任版主有些时候了, 一直没有太多心力去做些事情. 工作之后, 非常的忙碌, 为了生活的需要和自已职业的发展, 更加地力不从心, 但我想总要做些什么, 这就是翻译这本书最初的念头. </para>
	   <para>在我艰难, 断断续续的翻译着的时候, Linuxsir上, 杨春敏兄弟发了一个帖子, 他也在翻译这本书 -- 太好了, 我们很快就一起合作翻译, 是的, 伙计! 这比一个人傻乎乎地单打独斗强多了. </para>
	   <para>不幸的是, 我们之前的工作有一些重复, 说不幸, 那只是因为更不幸的事情还没有被发现, 更不幸的事情是, 我们是直接在HTML或是在一个文本编辑器里翻译. 这样我们无法获得可持续的升级, 并且让工作更加地艰难. 不过, 事情最终还是在大半年之后有了进展, 2006年的5月15号, 我们发布了一个beta版本, 是以文本格式发布的, 在5月30号发布了HTML版本. 随后, 翻译工作告一段落, 我甚至不愿意回忆这枯燥无味的日子, 而此时我的本职工作更加的繁忙, 我一心扑到工作中来, 杨春敏兄弟一力承担起后继的工作, 建起这本书的SGML的版本, 使可持续的维护成为可能, 较正并重新翻译了书中的全部内容, 真可谓劳苦功高, 做了大量的工作, 辛苦了! </para>
	   <para>到此, 我们认为可以发布一个正式版本, 希望大家能喜欢这个中文版. </para>
	   <para>向那些对beta版本提出修改意见的人们, 和支持此书的人们表示感谢! </para>
	   <para>特别感谢原书作者Mendel Cooper为我们贡献了这本好书! </para>
	 </sect2> <!-- translator2_yi_huang -->

    </sect1> <!-- translator_china -->


    <sect1 id="wherehelp">
      <title>在哪里可以获得帮助</title>

	  <para>如果<ulink url="mailto:thegrendel@theriver.com">作者</ulink>不是太忙(并且心情还不错)的话, 
		  可能会回答一些通用的脚本编程问题. 
		  <footnote><para>那些来自于垃圾邮件大量滋生的顶级域名(61, 202, 211, 218, 220, 等等.)的email, 
		将会被垃圾邮件过滤器收集起来, 并且会删掉未读的信件. 
	   如果你的ISP不巧就是上面中的某一个, 那么请使用Webmail账号来联系作者. 
	   </para></footnote>
	 但是, 如果你想询问关于你的特殊脚本的某些特定问题, 
	 那么建议你最好将这些问题发送到<ulink url="news:comp.unix.shell">comp.os.unix.shell</ulink>新闻组中去. 
	 </para>

	 <para>如果你是在写作业的时候需要帮助, 那么你最好阅读这本书的相关章节, 
		 并且查阅相关资料. 然后用你的智慧和找到的资源, 
		 尽你最大的努力来解决这个问题. 
		 不要浪费作者的时间, 没人同情你, 否则你再也不会得到相关的帮助. 
	 </para>

    </sect1> <!-- Where to Go For Help -->



    <sect1 id="toolsused">
      <title>用来制作这本书的工具</title>


     <sect2 id="software-hardware">
       <title>硬件</title>

       <para>一台运行着Red Hat 7.1/7.3的IBM Thinkpad, model 760XL(P166, 104 meg RAM)笔记本. 
		   没错, 它非常慢, 而且还有一个令人胆战心惊的键盘, 
		   但它总比一根铅笔加上一个大写字板强多了. 
	 </para>
	 
	 <para>
		 <emphasis>更新:</emphasis> 已经升级到了770Z Thinkpad 
		 (P2-366, 192 meg RAM)笔记本, 并且在上面跑FC3. 
		 有人想捐献一个新一点的笔记本, 给这个快要饿死的作者么&lt;g&gt;? 
	 </para>

     </sect2> <!-- Hardware -->


     <sect2 id="software-printware">
       <title>软件与排版软件</title>

      <orderedlist id="software-printware2" numeration="lowerroman">

        <listitem>
	<para>Bram Moolenaar的强大的SGML软件, <ulink
	url="http://www.vim.org">vim</ulink>文本编辑器. </para>
	</listitem>

	<listitem>
	<para><ulink
	url="http://www.netfolder.com/DSSSL/">OpenJade</ulink>,
	使用DSSSL翻译引擎, 来将SGML文档转换为其他格式的工具. 
	</para>
	</listitem>

	<listitem>
	<para><ulink url="http://nwalsh.com/docbook/dsssl/">Norman
	Walsh的DSSSL样式单</ulink>. </para>
	</listitem>

	<listitem>
		<para><citetitle pubwork="book">DocBook, The Definitive Guide</citetitle>(译者注: 这本书被亲切称为TDG), 
			这本书由Norman Walsh和Leonard Muellner编写(O'Reilly, ISBN 1-56592-580-7). 
			对于任何想要使用Docbook SGML格式编写文档的人来说, 
			这本书到目前为止仍然是一本标准参考手册. 
			(译者注: 这本书到现在已经有xml的升级版了.)
	  </para>
	</listitem>
    </orderedlist>
	<para>译者: 事实上, 译者所使用的软件环境与原书作者基本相同, 甚至编辑器都一样. 
		唯一一点不同就是译者使用的是cygwin下的openjade, 如果读者们有兴趣, 
		我总结了一个关于如何在cygwin下配置openjade环境的文档 -- 
		因为网上没找到, 所以自己花功夫研究了一下, 有机会就公布出来 -- 
		另外译者为了与原版的html版本保持格式相同, 已经在TLDP的DSSSL基础上做了最大努力的修改. </para>


     </sect2> <!-- Software and Printware -->

    </sect1> <!-- Tools Used -->



    <sect1 id="credits">
      <title>致谢</title>

	  <para><emphasis>团体的力量才使得这本书顺利地完成.</emphasis> 
		  作者非常感激那些给作者提供帮助和反馈的人们, 如果没有他们, 
		  这本书根本就是一个不可能完成的任务. 
	</para>
	<para>译者: 如下是作者感谢的对象. 为了保持原文作者的完整性, 这里就不译了. </para>

      <para><ulink url="mailto:feloy@free.fr">Philippe Martin</ulink>
	translated the first version (0.1) of this document into
	DocBook/SGML. While not on the job at a small French company as a
	software developer, he enjoys working on GNU/Linux documentation
	and software, reading literature, playing music, and, for his
	peace of mind, making merry with friends. You may run across him
	somewhere in France or in the Basque Country, or you can email him
	at <ulink url="mailto:feloy@free.fr">feloy@free.fr</ulink>.</para>

      <para>Philippe Martin also pointed out that positional parameters
	past $9 are possible using {bracket} notation. (See <xref
	linkend="ex17">).</para>

      <para><ulink url="mailto:stephane_chazelas@yahoo.fr">Stephane
	Chazelas</ulink> sent a long list of corrections, additions,
	and example scripts. More than a contributor, he had, in effect,
	for a while taken on the role of <command>editor</command>
	for this document. Merci beaucoup!</para>

      <para>Paulo Marcel Coelho Aragao offered many corrections, both major
        and minor, and contributed quite a number of helpful
        suggestions.</para>

      <para>I would like to especially thank <emphasis>Patrick
        Callahan</emphasis>, <emphasis>Mike Novak</emphasis>, and
        <emphasis>Pal Domokos</emphasis> for catching bugs, pointing out
        ambiguities, and for suggesting clarifications and changes.
        Their lively discussion of shell scripting and general
        documentation issues inspired me to try to make this document
        more readable.</para>

      <para>I'm grateful to Jim Van Zandt for pointing out errors and
        omissions in version 0.2 of this document. He also contributed
        an instructive <link linkend="zfifo">example script</link>.</para>

      <para>Many thanks to <ulink
        url="mailto:mikaku@fiwix.org">Jordi Sanfeliu</ulink>
        for giving permission to use his fine tree script (<xref
        linkend="tree">), and to Rick Boivie for revising it.</para>

      <para>Likewise, thanks to <ulink
        url="mailto:charpov@cs.unh.edu">Michel Charpentier</ulink> for
	permission to use his <link linkend="dcref">dc</link> factoring script
	(<xref linkend="factr">).</para>

      <para>Kudos to <ulink
        url="mailto:friedman@prep.ai.mit.edu">Noah Friedman</ulink>
        for permission to use his string function script (<xref
        linkend="string">).</para>

      <para><ulink url="mailto:emmanuel.rouat@wanadoo.fr">Emmanuel
        Rouat</ulink> suggested corrections and additions on
	<link linkend="commandsubref">command substitution</link> and
	<link linkend="aliasref">aliases</link>.  He also contributed
	a very nice sample <filename>.bashrc</filename> file (<xref
	linkend="sample-bashrc">).</para>

      <para><ulink url="mailto:heiner.steven@odn.de">Heiner Steven</ulink>
	kindly gave permission to use his base conversion script, <xref
	linkend="base">. He also made a number of corrections and many
	helpful suggestions. Special thanks.</para>

      <para>Rick Boivie contributed the delightfully recursive
	<emphasis>pb.sh</emphasis> script (<xref linkend="pbook">),
	revised the <emphasis>tree.sh</emphasis> script (<xref
	linkend="tree">), and suggested performance improvements
	for the <emphasis>monthlypmt.sh</emphasis> script (<xref
	linkend="monthlypmt">).</para>

      <para>Florian Wisser enlightened me on some of the fine points of
	testing strings (see <xref linkend="strtest">), and on other
	matters.</para>

      <para>Oleg Philon sent suggestions concerning <link
        linkend="cutref">cut</link> and <link
        linkend="pidofref">pidof</link>.</para>

      <para>Michael Zick extended the <link linkend="emptyarray">empty
	array</link> example to demonstrate some surprising array
	properties. He also contributed the <emphasis>isspammer</emphasis>
	scripts (<xref linkend="isspammer"> and <xref
	linkend="isspammer2">).</para>

      <para>Marc-Jano Knopp sent corrections and clarifications on DOS
        batch files.</para>

      <para>Hyun Jin Cha found several typos in the document in the
        process of doing a Korean translation. Thanks for pointing
        these out.</para>

      <para>Andreas Abraham sent in a long list of typographical
	errors and other corrections. Special thanks!</para>

      <para>Others contributing scripts, making helpful suggestions, and
	pointing out errors were Gabor Kiss, Leopold Toetsch,
	Peter Tillier, Marcus Berglof, Tony Richardson, Nick Drage
	(script ideas!), Rich Bartell, Jess Thrysoee, Adam Lazur, Bram
	Moolenaar, Baris Cicek, Greg Keraunen, Keith Matthews, Sandro
	Magi, Albert Reiner, Dim Segebart, Rory Winston, Lee Bigelow,
	Wayne Pollock, <quote>jipe,</quote> <quote>bojster,</quote>
	<quote>nyal,</quote> <quote>Hobbit,</quote> <quote>Ender,</quote>
	<quote>Little Monster</quote> (Alexis), <quote>Mark,</quote>
	Emilio Conti, Ian. D. Allen, Arun Giridhar, Dennis Leeuw, Dan
	Jacobson, Aurelio Marinho Jargas, Edward Scholtz, Jean Helou,
	Chris Martin, Lee Maschmeyer, Bruno Haible, Wilbert Berendsen,
	Sebastien Godard, Bj&ouml;n Eriksson, John MacDonald, Joshua
	Tschida, Troy Engel, Manfred Schwarb, Amit Singh, Bill Gradwohl,
	David Lombard, Jason Parker, Steve Parker, Bruce W. Clare,
	William Park, Vernia Damiano, Mihai Maties, Jeremy Impson,
	Ken Fuchs, Frank Wang, Sylvain Fourmanoit, Matthew Walker,
	Kenny Stauffer, Filip Moritz, Andrzej Stefanski, Daniel Albers,
	Stefano Palmeri, Nils Radtke, Jeroen Domburg, Alfredo Pironti,
	Phil Braham, Bruno de Oliveira Schneider, Stefano Falsetto,
	Chris Morgan, Walter Dnes, Linc Fessenden, Michael Iatrou,
	Pharis Monalo, Jesse Gough, Fabian Kreutz, Mark Norman, Harald
	Koenig, Peter Knowles, Francisco Lobo, Mariusz Gniazdowski,
	Tedman Eng, Jochen DeSmet, Oliver Beckstein, Achmed Darwish,
	Andreas K&uuml;hne, and David Lawyer (himself an author of four
	HOWTOs).</para>

      <para>My gratitude to <ulink url="mailto:chet@po.cwru.edu">Chet
	Ramey</ulink> and Brian Fox for writing <firstterm>Bash</firstterm>,
	and building into it elegant and powerful scripting
	capabilities.</para>

      <para>Very special thanks to the hard-working volunteers at
	the <ulink url="http://www.tldp.org">Linux Documentation
	Project</ulink>. The LDP hosts a repository of Linux knowledge
	and lore, and has, to a large extent, enabled the publication
	of this book.</para>

      <para>Thanks and appreciation to IBM, Novell, Red Hat, the <ulink
        url="http://www.fsf.org">Free Software Foundation</ulink>, and
        all the good people fighting the good fight to keep Open Source
        software free and open.</para>

      <para>Thanks most of all to my wife, Anita, for her encouragement and
        emotional support.</para>	

    </sect1> <!-- Credits --> 

    <sect1 id="trans_credits">
      <title>译者致谢</title>
	  <para>这里放上所有对译本做过贡献同志们, 译者真心的感谢你们. (排名不分先后)</para>
	  <para><ulink url="http://www.linuxsir.org">www.linuxsir.org</ulink>站点提供了发布环境, 也是我们两个译者结识的地方. </para>
	  <para>宗耀堂 -- 感谢对exit status与exit code翻译的建议. </para>
	  <para>phanrider -- 感谢对于beta版本的错别字校正. </para>
    </sect1> <!-- Trans_Credits --> 
  </chapter> <!-- End Notes --> 



  <bibliography id="biblio">
  <anchor id="biblioref">

    <epigraph>
      <attribution>Henry Spencer</attribution>
      <para>Those who do not understand UNIX are condemned to reinvent it,
	poorly.</para>
    </epigraph>
    

    <biblioentry>
      <authorgroup>
	<editor><firstname>Peter</firstname><surname>Denning</surname></editor>
      </authorgroup>
      <title>Computers Under Attack: Intruders, Worms, and Viruses</title>
      <publisher>
	<publishername>ACM Press</publishername>
      </publisher>
      <copyright>
	<year>1990</year>
      </copyright>
      <isbn>0-201-53067-8</isbn>
      <abstract><para>This compendium contains a couple of articles on 
        shell script viruses.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Ken</firstname><surname>Burtch</surname></author>
      </authorgroup>
      <title><ulink url="http://www.samspublishing.com/title/0672326426">Linux Shell Scripting with Bash</ulink></title>
      <edition>1st edition</edition>
      <publisher>
	<publishername>Sams Publishing (Pearson)</publishername>
      </publisher>
      <copyright>
	<year>2004</year>
      </copyright>
      <isbn>0672326426</isbn>
      <abstract><para>
	  Covers much of the same material as this guide. Dead tree
	    media does have its advantages, though.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Dale</firstname><surname>Dougherty</surname></author>
	<author><firstname>Arnold</firstname><surname>Robbins</surname></author>
      </authorgroup>
      <title>Sed and Awk</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1997</year>
      </copyright>
      <isbn>1-156592-225-5</isbn>
      <abstract><para>
	  To unfold the full power of shell scripting, you need at least a passing
	  familiarity with <command>sed</command> and
	  <command>awk</command>. This is the standard tutorial. It 
	  includes an excellent introduction to <quote>regular expressions</quote>. Read this
	  book.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Jeffrey</firstname><surname>Friedl</surname></author>
      </authorgroup>
      <title>Mastering Regular Expressions</title>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>2002</year>
      </copyright>
      <isbn>0-596-00289-0</isbn>
      <abstract><para>The best, all-around reference on <link
      linkend="regexref">Regular Expressions</link>.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Aeleen</firstname><surname>Frisch</surname></author>
      </authorgroup>
      <title>Essential System Administration</title>
      <edition>3rd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>2002</year>
      </copyright>
      <isbn>0-596-00343-9</isbn>
      <abstract><para>This excellent sys admin manual has a decent introduction to shell
	  scripting for sys administrators and does a nice job of explaining the
	  startup and initialization scripts. The long overdue third edition of this
	  classic has finally been released.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Stephen</firstname><surname>Kochan</surname></author>
	<author><firstname>Patrick</firstname><surname>Woods</surname></author>
      </authorgroup>
      <title>Unix Shell Programming</title>
      <publisher>
	<publishername>Hayden</publishername>
      </publisher>
      <copyright>
	<year>1990</year>
      </copyright>
      <isbn>067248448X</isbn>
      <abstract><para>The standard reference, though a bit dated by now.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Neil</firstname><surname>Matthew</surname></author>
	<author><firstname>Richard</firstname><surname>Stones</surname></author>
      </authorgroup>
      <title>Beginning Linux Programming</title>
      <publisher>
	<publishername>Wrox Press</publishername>
      </publisher>
      <copyright>
	<year>1996</year>
      </copyright>
      <isbn>1874416680</isbn>
      <abstract><para>Good in-depth coverage of various programming
        languages available for Linux, including a fairly strong chapter
        on shell scripting.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry id="mayerref">
      <authorgroup>
	<author><firstname>Herbert</firstname><surname>Mayer</surname></author>
      </authorgroup>
      <title>Advanced C Programming on the IBM PC</title>
      <publisher>
	<publishername>Windcrest Books</publishername>
      </publisher>
      <copyright>
	<year>1989</year>
      </copyright>
      <isbn>0830693637</isbn>
      <abstract><para>Excellent coverage of algorithms and general
        programming practices.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>David</firstname><surname>Medinets</surname></author>
      </authorgroup>
      <title>Unix Shell Programming Tools</title>
      <publisher>
	<publishername>McGraw-Hill</publishername>
      </publisher>
      <copyright>
	<year>1999</year>
      </copyright>
      <isbn>0070397333</isbn>
      <abstract><para>Good info on shell scripting, with examples, and a short
        intro to Tcl and Perl.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Cameron</firstname><surname>Newham</surname></author>
	<author><firstname>Bill</firstname><surname>Rosenblatt</surname></author>
      </authorgroup>
      <title>Learning the Bash Shell</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1998</year>
      </copyright>
      <isbn>1-56592-347-2</isbn>
      <abstract><para>This is a valiant effort at a decent shell primer, but somewhat deficient
	  in coverage on programming topics and lacking sufficient examples.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Anatole</firstname><surname>Olczak</surname></author>
      </authorgroup>
      <title>Bourne Shell Quick Reference Guide</title>
      <publisher>
	<publishername>ASP, Inc.</publishername>
      </publisher>
      <copyright>
	<year>1991</year>
      </copyright>
      <isbn>093573922X</isbn>
      <abstract><para>A very handy pocket reference, despite lacking
      coverage of Bash-specific features.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Jerry</firstname><surname>Peek</surname></author>
	<author><firstname>Tim</firstname><surname>O'Reilly</surname></author>
	<author><firstname>Mike</firstname><surname>Loukides</surname></author>
      </authorgroup>
      <title>Unix Power Tools</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <publisher>
	<publishername>Random House</publishername>
      </publisher>
      <copyright>
	<year>1997</year>
      </copyright>
      <isbn>1-56592-260-3</isbn>
      <abstract><para>Contains a couple of sections of very informative
       in-depth articles on shell programming, but falls short of being
       a tutorial. It reproduces much of the regular expressions tutorial
       from the Dougherty and Robbins book, above.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Clifford</firstname><surname>Pickover</surname></author>
      </authorgroup>
      <title>Computers, Pattern, Chaos, and Beauty</title>
      <publisher>
	<publishername>St. Martin's Press</publishername>
      </publisher>
      <copyright>
	<year>1990</year>
      </copyright>
      <isbn>0-312-04123-3</isbn>
      <abstract><para>A treasure trove of ideas and recipes for
        computer-based exploration of mathematical oddities.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>George</firstname><surname>Polya</surname></author>
      </authorgroup>
      <title>How To Solve It</title>
      <publisher>
	<publishername>Princeton University Press</publishername>
      </publisher>
      <copyright>
	<year>1973</year>
      </copyright>
      <isbn>0-691-02356-5</isbn>
      <abstract><para>The classic tutorial on problem solving methods
        (i.e., algorithms).</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

     <biblioentry>
       <authorgroup>
 	<author><firstname>Chet</firstname><surname>Ramey</surname></author>
 	<author><firstname>Brian</firstname><surname>Fox</surname></author>
       </authorgroup>
       <title><ulink
           url="http://www.network-theory.co.uk/bash/manual/">The GNU Bash Reference Manual</ulink></title>
       <publisher>
 	<publishername>Network Theory Ltd</publishername>
       </publisher>
       <copyright>
 	<year>2003</year>
       </copyright>
       <isbn>0-9541617-7-7</isbn>
       <abstract><para>This manual is the definitive reference for
         GNU Bash. The authors of this manual, Chet Ramey and Brian Fox,
         are the original developers of GNU Bash. For each copy sold the
         publisher donates $1 to the Free Software Foundation.</para>
       </abstract>
     </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Arnold</firstname><surname>Robbins</surname></author>
      </authorgroup>
      <title>Bash Reference Card</title>
      <publisher>
	<publishername>SSC</publishername>
      </publisher>
      <copyright>
	<year>1998</year>
      </copyright>
      <isbn>1-58731-010-5</isbn>
      <abstract>
          <para>Excellent Bash pocket reference (don't leave home
	    without it).  A bargain at $4.95, but
	    also available for free download <ulink
	    url="http://www.ssc.com/ssc/bash/">on-line</ulink> in pdf
	    format.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Arnold</firstname><surname>Robbins</surname></author>
      </authorgroup>
      <title>Effective Awk Programming</title>
      <publisher>
	<publishername>Free Software Foundation / O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>2000</year>
      </copyright>
      <isbn>1-882114-26-4</isbn>
      <abstract>
          <para>The absolute best <command>awk</command> tutorial and
	    reference. The free electronic version of this book is part of the
	    <command>awk</command> documentation, and printed copies of the
	    latest version are available from O'Reilly and Associates.</para>
	  <para>This book has served as an inspiration for the author of this
	    document.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Bill</firstname><surname>Rosenblatt</surname></author>
      </authorgroup>
      <title>Learning the Korn Shell</title>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1993</year>
      </copyright>
      <isbn>1-56592-054-6</isbn>
      <abstract>
      <para>This well-written book contains some excellent pointers on shell
        scripting.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Paul</firstname><surname>Sheer</surname></author>
      </authorgroup>
      <title>LINUX: Rute User's Tutorial and Exposition</title>
      <edition>1st edition</edition>
      <publisher>
	<publishername></publishername>
      </publisher>
      <copyright>
	<year>2002</year>
      </copyright>
      <isbn>0-13-033351-4</isbn>
      <abstract>
      <para>Very detailed and readable introduction to Linux system
        administration.</para>
      <para>The book is available in print, or
      <ulink url="http://rute.sourceforge.net/">on-line</ulink>.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Ellen</firstname><surname>Siever</surname></author>
	<author><surname>the staff of O'Reilly and Associates</surname></author>
      </authorgroup>
      <title>Linux in a Nutshell</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1999</year>
      </copyright>
      <isbn>1-56592-585-8</isbn>
      <abstract><para>The all-around best Linux command reference, even has a Bash section.</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Dave</firstname><surname>Taylor</surname></author>
      </authorgroup>
      <title>Wicked Cool Shell Scripts: 101 Scripts for Linux, Mac OS X, and Unix Systems</title>
      <edition>1st edition</edition>
      <publisher>
	<publishername>No Starch Press</publishername>
      </publisher>
      <copyright>
	<year>2004</year>
      </copyright>
      <isbn>1-59327-012-7</isbn>
      <abstract><para>Just as the title says . . .</para>
	  <para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <title>The UNIX CD Bookshelf</title>
      <edition>3rd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>2003</year>
      </copyright>
      <isbn>0-596-00392-7</isbn>
      <abstract><para>An array of seven UNIX books on CD ROM, including
	<citetitle pubwork="book">UNIX Power Tools</citetitle>,
	<citetitle pubwork="book">Sed and Awk</citetitle>, and <citetitle
	pubwork="book">Learning the Korn Shell</citetitle>. A complete
	set of all the UNIX references and tutorials you would ever need
	at about $130. Buy this one, even if it means going into debt
	and not paying the rent.</para>
	<para>*</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The O'Reilly books on Perl. (Actually, any O'Reilly books.)</para>
	<para>---</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract><para>Fioretti, Marco, <quote>Scripting for X
	Productivity,</quote> <ulink url="linuxjournal.com"><citetitle
	pubwork="journal">Linux Journal</citetitle></ulink>, Issue 113,
	September, 2003, pp.  86-9.</para></abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Ben Okopnik's well-written <emphasis>introductory Bash
	  scripting</emphasis> articles in issues 53, 54, 55, 57, and
	  59 of the <ulink url="http://www.linuxgazette.com"><citetitle
	  pubwork="journal">Linux Gazette</citetitle></ulink>, and his
	  explanation of <quote>The Deep, Dark Secrets of Bash</quote>
	  in issue 56.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract><para>Chet Ramey's <emphasis>bash - The GNU Shell</emphasis>,
        a two-part series published in issues 3 and 4 of the
        <ulink url="http://www.linuxjournal.com"><citetitle
        pubwork="journal">Linux Journal</citetitle></ulink>, July-August
        1994.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Mike G's <ulink
	  url="http://www.tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html">Bash-Programming-Intro
	  HOWTO</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Richard's <ulink url="http://www.injunea.demon.co.uk/index.htm">Unix
	  Scripting Universe</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Chet Ramey's <ulink
	url="ftp://ftp.cwru.edu/pub/bash/FAQ">Bash F.A.Q.</ulink></para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Ed Schaefer's <ulink
	url="http://www.unixreview.com/columns/schaefer/">Shell
	Corner</ulink>
	 in <ulink url="http://www.unixreview.com"><citetitle
	 pubwork="journal">Unix Review</citetitle></ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Example shell scripts at <ulink
	  url="http://alge.anart.no/linux/scripts/">Lucc's Shell Scripts
	  </ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Example shell scripts at <ulink
	  url="http://www.shelldorado.com">SHELLdorado </ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Example shell scripts at <ulink
	  url="http://clri6f.gsi.de/gnu/bash-2.01/examples/scripts.noah/">Noah
	  Friedman's script site</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Example shell scripts at <ulink
	  url="http://www.zazzybob.com">zazzybob</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Steve Parker's <ulink
	url="http://steve-parker.org/sh/sh.shtml">Shell Programming
	Stuff</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Example shell scripts at <ulink
	  url="http://sourceforge.net/snippet/browse.php?by=lang&amp;lang=7">
	  SourceForge Snippet Library - shell scrips</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para><quote>Mini-scripts</quote> at <ulink
	url="http://www.primaat.com/unix_oneliners">Unix
	Oneliners</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Giles Orr's <ulink
	url="http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/">Bash-Prompt
	HOWTO</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Very nice <command>sed</command>,
	<command>awk</command>, and regular expression tutorials at
	<ulink url="http://www.grymoire.com/Unix/index.html">The UNIX
	Grymoire</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Eric Pement's
	<ulink url="http://www.student.northpark.edu/pemente/sed/">sed resources page</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Many interesting sed scripts at the <ulink
	url="http://sed.sourceforge.net/grabbag/"> seder's grab bag</ulink>.</para>
      </abstract>
    </biblioentry>



    <biblioentry>
      <abstract>
	<para>The GNU <command>gawk</command> <ulink
	url="http://sunsite.ualberta.ca/Documentation/Gnu/gawk-3.0.6/gawk.html">
	reference manual</ulink> (<command>gawk</command> is the extended
	GNU version of <command>awk</command> available on Linux and
	BSD systems).</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Tips and tricks at <ulink
	url="http://linuxreviews.org"> Linux Reviews</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Trent Fisher's <ulink
	url="http://www.cs.pdx.edu/~trent/gnu/groff/groff.html">groff
	tutorial</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Mark Komarinski's <ulink
	url="http://www.tldp.org/HOWTO/Printing-Usage-HOWTO.html">Printing-Usage
	HOWTO</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
        <para><ulink url="http://www.linux-usb.org/USB-guide/book1.html">The
	  Linux USB subsystem</ulink> (helpful in writing scripts affecting
	  USB peripherals).</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>There is some nice material on <link
	linkend="ioredirref">I/O redirection</link> in <ulink
	url="http://sunsite.ualberta.ca/Documentation/Gnu/textutils-2.0/html_chapter/textutils_10.html">
	chapter 10 of the textutils documentation</ulink> at the <ulink
	url="http://sunsite.ualberta.ca/Documentation"> University of
	Alberta site</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para><ulink url="mailto:humbubba@smarty.smart.net">Rick
	  Hohensee</ulink> has written the <ulink
	  url="ftp://ftp.gwdg.de/pub/linux/install/clienux/interim/osimpa.tgz">
	  osimpa</ulink> i386 assembler entirely as Bash scripts.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Aurelio Marinho Jargas has written a <ulink
	  url="http://txt2regex.sf.net">Regular expression
	  wizard</ulink>. He has also written an informative <ulink
	  url="http://guia-er.sf.net">book</ulink> on Regular Expressions,
	  in Portuguese.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para><ulink url="mailto:brtompkins@comcast.net">Ben
	  Tomkins</ulink> has created the <ulink
	  url="http://bashnavigator.sourceforge.net">
	  Bash Navigator</ulink> directory management tool.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para><ulink url="mailto:opengeometry@yahoo.ca">William Park</ulink>
	  has been working on a <ulink
	  url="http://home.eol.ca/~parkw/index.html">project</ulink>
	  to incorporate certain Awk and Python
	  features into Bash. Among these is a
	  <emphasis>gdbm</emphasis> interface. He has released <ulink
	  url="http://freshmeat.net/projects/bashdiff/">bashdiff</ulink>
	  on <ulink url="http://freshmeat.net">Freshmeat.net</ulink>. He
	  has an <ulink
	  url="http://linuxgazette.net/108/park.html">article</ulink>
	  in the November, 2004 issue of the <ulink
	  url="http://www.linuxgazette.net"><citetitle
	  pubwork="journal">Linux Gazette</citetitle></ulink>
	  on adding string functions to Bash, with a <ulink
	  url="http://linuxgazette.net/109/park.html">followup
	  article</ulink> in the December issue, and <ulink
	  url="http://linuxgazette.net/110/park.htm">yet another</ulink>
	  in the January, 2005 issue.</para>
      </abstract>

    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Peter Knowles has written an
	  <ulink url="http://booklistgensh.peterknowles.com/">elaborate
	  Bash script</ulink> that generates a book list on the <ulink
	  url="http://www.dottocomu.com/b/archives/002571.html">Sony
	  Librie</ulink> e-book reader. This useful tool permits
	  loading non-DRM user content on the <emphasis>Librie</emphasis>.</para>
	  
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Rocky Bernstein is in the process of developing a
	  <quote>full-fledged</quote> <ulink
	  url="http://bashdb.sourceforge.net"> debugger</ulink> for
	  Bash.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>Of historical interest are Colin Needham's <ulink
	url="http://groups.google.com/group/rec.arts.movies/browse_thread/thread/5a37
	19142fd4db9e/152249faf7593d14">original
	International Movie Database (IMDB) reader polling
	scripts</ulink>, which nicely illustrate the use of <link
	linkend="awkref">awk</link> for string parsing.</para>
	<para>---</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The excellent <citetitle pubwork="book"> Bash Reference Manual</citetitle>, by Chet Ramey and Brian Fox,
	  distributed as part of the "bash-2-doc" package (available as an rpm).
	  See especially the instructive example scripts in this package.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
        <para>The <ulink
          url="news:comp.unix.shell">comp.os.unix.shell</ulink>
          newsgroup.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
        <para>The <ulink
	  url="http://home.comcast.net/~j.p.h/">comp.os.unix.shell
	  FAQ</ulink> and <ulink
	  url="http://www.newsville.com/cgi-bin/getfaq?file=comp.unix.shell/comp.unix.shell_FAQ_-_Answers_to_Frequently_Asked_Questions">its
	  mirror site</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
        <para>Assorted comp.os.unix <ulink
          url="http://www.faqs.org/faqs/by-newsgroup/comp/comp.unix.shell.html">
          FAQs</ulink>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The manpages for <command>bash</command> and
	  <command>bash2</command>, <command>date</command>,
	  <command>expect</command>, <command>expr</command>,
	  <command>find</command>, <command>grep</command>,
	  <command>gzip</command>, <command>ln</command>,
	  <command>patch</command>, <command>tar</command>,
	  <command>tr</command>, <command>bc</command>,
	  <command>xargs</command>.  The texinfo documentation
	  on <command>bash</command>, <command>dd</command>,
	  <command>m4</command>, <command>gawk</command>, and
	  <command>sed</command>.</para>
      </abstract>
    </biblioentry>


  </bibliography>



  <appendix id="contributed-scripts">
      <title>捐献的脚本</title>

    <para>这些脚本展示了一些有趣的shell编程技术, 但是它们并不适合放入本文档的文本讲解中. 
    不过它们还是非常有用, 运行和分析它们都是很有意思的事. </para>
	<para>译者: 这里留给那些有能力而且有多余时间的读者来详读, 个人认为翻译这些注释有点画蛇添足. </para>

    <example id="mailformat">
      <title><command>mailformat</command>: 格式化一个e-mail消息</title>
      <programlisting>&mailformat;</programlisting>
    </example>

    <example id="rn">
      <title><command>rn</command>: 一个非常简单的文件重命名工具</title>
      <para>这个脚本是<xref linkend="lowercase">的一个修改版. </para>
      <programlisting>&rn;</programlisting>
    </example>

    <example id="blankrename">
      <title><command>blank-rename</command>: 重命名包含空白的文件名</title>
      <para>这是上一个脚本的简化版. </para>
      <programlisting>&blankrename;</programlisting>
    </example>

    <example id="encryptedpw">
      <title><command>encryptedpw</command>: 使用一个本地加密口令, 上传到一个ftp服务器. </title>
      <programlisting>&encryptedpw;</programlisting>
    </example>

    <example id="copycd">
      <title><command>copy-cd</command>: 拷贝一个数据CD</title>
      <programlisting>&copycd;</programlisting>
    </example>

    <example id="collatz">
      <title>Collatz序列</title>
    <programlisting>&collatz;</programlisting>
    </example>

    <example id="daysbetween">
      <title><command>days-between</command>: 计算两个日期之间天数差</title>
      <programlisting>&daysbetween;</programlisting>
    </example>

    <example id="makedict">
      <title>构造一个<quote>字典</quote></title>
    <programlisting>&makedict;</programlisting>
    </example>

    <example id="soundex">
      <title>Soundex转换</title>
    <programlisting>&soundex;</programlisting>
    </example>

    <example id="lifeslow">
      <title><quote>Game of Life</quote></title>
    <programlisting>&lifeslow;</programlisting>
    </example>

    <example id="gen0data">
      <title><quote>Game of Life</quote>的数据文件</title>
    <programlisting>&gen0data;</programlisting>
    </example>



    <para>+++</para>
    
    <para>下面的两个脚本是由多伦多大学的Mark Moraes编写的. 
    请参考附件文件<quote>Moraes-COPYRIGHT</quote>, 
    详细的指明了授权与约定. </para>

    <example id="behead">
      <title><command>behead</command>: 去掉信件与新消息的头</title>
      <programlisting>&behead;</programlisting>
    </example>

    <example id="ftpget">
      <title><command>ftpget</command>: 通过ftp下载文件</title>
      <programlisting>&ftpget;</programlisting>
    </example>

    <para>+</para>

	<para>Antek Sawicki捐献了下面的脚本, 这个脚本非常聪明的使用了参数替换操作符, 
		我们在<xref linkend="Parameter-Substitution">中讨论了参数替换操作符. </para>

    <example id="pw">
      <title><command>password</command>: 产生随机的8个字符的密码</title>
      <programlisting>&pw;</programlisting>
    </example>

    <para>+</para>

    <para><anchor id="zfifo">James R. Van Zandt捐献了这个脚本, 
      使用命名管道, 用他的话来说, <quote>引用与转义的真正练习</quote>. </para>

    <example id="fifo">
      <title><command>fifo</command>: 使用命名管道来做每日的备份</title>
      <programlisting>&fifo;</programlisting>
    </example>

    <para>+</para>

    <para>Stephane Chazelas捐献了这个脚本, 用来展示如何不使用数组来产生素数</para>

    <example id="primes">
      <title>使用模操作符来产生素数</title>
      <programlisting>&primes;</programlisting>
    </example>
    
    <para>+</para>

    <para>这是Jordi Sanfeliu的<emphasis>tree</emphasis>脚本的升级版, 由Rick Boivie编写. </para>

    <example id="tree">
      <title><command>tree</command>: 显示目录树</title>
      <programlisting>&tree;</programlisting>
    </example>

    <para>经过Noah Friedman的授权, 他的<emphasis>string
			function</emphasis>脚本可以在本书中使用, 
		这个脚本本质上就是复制了一些C库的字符串操作函数. 
      </para>

    <example id="string">
      <title><command>string functions</command>: C风格的字符串函数</title>
      <programlisting>&string;</programlisting>
    </example>

    <para>这个复杂的数组用例使用了<link
			linkend="md5sumref">md5sum</link>检查和命令来编码目录信息, 
		此脚本由Michael Zick编写. </para>

    <example id="directoryinfo">
      <title>目录信息</title>
      <programlisting>&directoryinfo;</programlisting>
    </example>


    <para>Stephane Chazelas向我们展示了如何在Bash脚本中使用面向对象的编程方法. </para>

    <example id="objoriented">
      <title>面向对象数据库</title>
      <programlisting>&objoriented;</programlisting>
    </example>

	<para>Mariusz Gniazdowski发布了一个可以在脚本中使用的<link 
			linkend="hashref">hash</link>库. </para>

    <example id="hashlib">
      <title>hash函数库</title>
      <programlisting>&hashlib;</programlisting>
    </example>

    <para>这是个例子脚本, 这个脚本使用了前面的hash库. </para>

    <example id="hashexample">
      <title>使用hash函数来给文本上色</title>
      <programlisting>&hashexample;</programlisting>
    </example>

    <para>站在一个比较难的观点来阐明hash的结构. </para>

    <example id="hashex2">
      <title>深入hash函数</title>
      <programlisting>&hashex2;</programlisting>
    </example>

    <para>下面这个脚本可以用来安装和挂载那些小的USB keychain<quote>硬件设备</quote>(译者: 就是U盘一类的东西). </para>

    <example id="usbinst">
      <title>挂载USB keychain型的存储设备</title>
      <programlisting>&usbinst;</programlisting>
    </example>

    <para>这个脚本对于站点管理员来说很有用: 这是一个可以保存weblog的脚本. </para>

    <example id="archivweblogs">
      <title>保存weblog</title>
      <programlisting>&archiveweblogs;</programlisting>
    </example>

    <para>你怎么做才能阻止shell扩展或者重新解释字符串? 
      </para>

    <example id="protectliteral">
      <title>保护字符串的字面含义</title>
      <programlisting>&protectliteral;</programlisting>
    </example>

    <para>如果你<emphasis>确实想让</emphasis>shell扩展或者重新解释字符串的话, 该怎么办? </para>

    <example id="unprotectliteral">
      <title>不保护字符串的字面含义</title>
      <programlisting>&unprotectliteral;</programlisting>
    </example>


    <para>这个强大的脚本帮助我们抓住垃圾邮件服务器. </para>

    <example id="isspammer2">
      <title>鉴定是否是垃圾邮件服务器</title>
      <programlisting>&isspammer2;</programlisting>
    </example>


    <para>另一个阻挡垃圾邮件的脚本. </para>

    <example id="whx">
      <title>垃圾邮件服务器猎手</title>
      <programlisting>&whx;</programlisting>
    </example>


    <para><quote>Little Monster的</quote>之前的<link
      linkend="wgetref">wget</link>. </para>

    <example id="wgetter2">
      <title>使得<command>wget</command>更易用</title>
      <programlisting>&wgetter2;</programlisting>
    </example>

    <example id="bashpodder">
      <title>一个<quote>podcasting</quote>(译者: 指的是在互联网上发布音视频文件, 并允许用户订阅并自动接收的方法)脚本</title>
      <programlisting>&bashpodder;</programlisting>
    </example>

    <para>作为本小节的结尾, 让我们回顾一下基本概念 . . . 可能还有些扩展部分. </para>

    <example id="basicsreviewed">
      <title>基础回顾</title>
      <programlisting>&basicsreviewed;</programlisting>
    </example>

    <example id="cdll">
      <title>一个扩展的<command>cd</command>命令</title>
      <programlisting>&cdll;</programlisting>
    </example>

  </appendix>
    <!-- End Contributed Scripts appendix -->




  <appendix id="refcards">
      <title>参考卡片</title>

      <para>下面的参考卡片提供了对于某些特定的脚本概念的一个<emphasis>总结</emphasis>. 
	之前我们已经对这里所提及的概念进行了详细的解释, 并且给出了使用的例子. </para>

      <table pgwide=0>
	<title>特殊的shell变量</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>变量</entry>
	      <entry>含义</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>$0</option></entry>
	      <entry>脚本名字</entry>
	    </row>
	    <row>
	      <entry><option>$1</option></entry>
	      <entry>位置参数 #1</entry>
	    </row>
	    <row>
	      <entry><option>$2 - $9</option></entry>
	      <entry>位置参数 #2 - #9</entry>
	    </row>
	    <row>
	      <entry><option>${10}</option></entry>
	      <entry>位置参数 #10</entry>
	    </row>
	    <row>
	      <entry><option>$#</option></entry>
	      <entry>位置参数的个数</entry>
	    </row>
	    <row>
	      <entry><option>"$*"</option></entry>
	      <entry>所有的位置参数(作为单个字符串) *</entry>
	    </row>
	    <row>
	      <entry><option>"$@"</option></entry>
	      <entry>所有的位置参数(每个都作为独立的字符串)</entry>
	    </row>
	    <row>
	      <entry><option>${#*}</option></entry>
	      <entry>传递到脚本中的命令行参数的个数</entry>
	    </row>
	    <row>
	      <entry><option>${#@}</option></entry>
	      <entry>传递到脚本中的命令行参数的个数</entry>
	    </row>
	    <row>
	      <entry><option>$?</option></entry>
	      <entry>返回值</entry>
	    </row>
	    <row>
	      <entry><option>$$</option></entry>
	      <entry>脚本的进程ID(PID)</entry>
	    </row>
	    <row>
	      <entry><option>$-</option></entry>
	      <entry>传递到脚本中的标志(使用<emphasis>set</emphasis>)</entry>
	    </row>
	    <row>
	      <entry><option>$_</option></entry>
	      <entry>之前命令的最后一个参数</entry>
	    </row>
	    <row>
	      <entry><option>$!</option></entry>
	      <entry>运行在后台的最后一个作业的进程ID(PID)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para><command>*</command> <emphasis>必须被引用起来</emphasis>,
        否则默认为<quote><varname>$@</varname></quote>. </para>


      <table>
	<title>测试操作: 二元比较</title>
	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>操作</entry>
	      <entry>描述</entry>
	      <entry>-----</entry>
	      <entry>操作</entry>
	      <entry>描述</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry></entry>
	      <entry></entry>
	    </row>
	    <row>
	      <entry>算术比较</entry>
	      <entry></entry>
	      <entry></entry>
	      <entry>字符串比较</entry>
	      <entry></entry>
	    </row>
	    <row>
	      <entry><option>-eq</option></entry>
	      <entry>等于</entry>
	      <entry></entry>
	      <entry><option>=</option></entry>
	      <entry>等于</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry></entry>
	      <entry></entry>
	      <entry><option>==</option></entry>
	      <entry>等于</entry>
	    </row>
	    <row>
	      <entry><option>-ne</option></entry>
	      <entry>不等于</entry>
	      <entry></entry>
	      <entry><option>!=</option></entry>
	      <entry>不等于</entry>
	    </row>
	    <row>
	      <entry><option>-lt</option></entry>
	      <entry>小于</entry>
	      <entry></entry>
	      <entry><option>\&lt;</option></entry>
	      <entry>小于 (ASCII) *</entry>
	    </row>
	    <row>
	      <entry><option>-le</option></entry>
	      <entry>小于等于</entry>
	      <entry></entry>
	      <entry></entry>
	    </row>
	    <row>
	      <entry><option>-gt</option></entry>
	      <entry>大于</entry>
	      <entry></entry>
	      <entry><option>\&gt;</option></entry>
	      <entry>大于 (ASCII) *</entry>
	    </row>
	    <row>
	      <entry><option>-ge</option></entry>
	      <entry>大于等于</entry>
	      <entry></entry>
	      <entry></entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry></entry>
	      <entry></entry>
	      <entry><option>-z</option></entry>
	      <entry>字符串为空</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry></entry>
	      <entry></entry>
	      <entry><option>-n</option></entry>
	      <entry>字符串不为空</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry></entry>
	    </row>
	    <row>
	      <entry>算术比较</entry>
	      <entry>双括号(( ... ))结构</entry>
	    </row>
	    <row>  
	      <entry><option>&gt;</option></entry>
	      <entry>大于</entry>
	    </row>
	    <row>
	      <entry><option>&gt;=</option></entry>
	      <entry>大于等于</entry>
	    </row>
	    <row>  
	      <entry><option>&lt;</option></entry>
	      <entry>小于</entry>
	    </row>
	    <row>  
	      <entry><option>&lt;=</option></entry>
	      <entry>小于等于</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


      <para><command>*</command> <emphasis>如果在双中括号</emphasis> [[ ... ]] <emphasis>测试结构中使用的话, 
        那么就不需要使用转义符</emphasis>\<emphasis>了. </emphasis></para>

      <table>
	<title>文件类型的测试操作</title>
	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>操作</entry>
	      <entry>测试条件</entry>
	      <entry>-----</entry>
	      <entry>操作</entry>
	      <entry>测试条件</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>-e</option></entry>
	      <entry>文件是否存在</entry>
	      <entry></entry>
	      <entry><option>-s</option></entry>
	      <entry>文件大小不为0</entry>
	    </row>
	    <row>
	      <entry><option>-f</option></entry>
	      <entry>是一个<emphasis>标准</emphasis>文件</entry>
	    </row>
	    <row>
	      <entry><option>-d</option></entry>
	      <entry>是一个<emphasis>目录</emphasis></entry>
	      <entry></entry>
	      <entry><option>-r</option></entry>
	      <entry>文件具有<emphasis>读</emphasis>权限</entry>
	    </row>
	    <row>
	      <entry><option>-h</option></entry>
	      <entry>文件是一个<emphasis>符号链接</emphasis></entry>
	      <entry></entry>
	      <entry><option>-w</option></entry>
	      <entry>文件具有<emphasis>写</emphasis>权限</entry>
	    </row>
	    <row>
	      <entry><option>-L</option></entry>
	      <entry>文件是一个<emphasis>符号链接</emphasis></entry>
	      <entry></entry>
	      <entry><option>-x</option></entry>
	      <entry>文件具有<emphasis>执行</emphasis>权限</entry>
	    </row>
	    <row>
	      <entry><option>-b</option></entry>
	      <entry>文件是一个<emphasis>块设备</emphasis></entry>
	    </row>
	    <row>
	      <entry><option>-c</option></entry>
	      <entry>文件是一个<emphasis>字符设备</emphasis></entry>
	      <entry></entry>
	      <entry><option>-g</option></entry>
	      <entry>设置了<emphasis>sgid</emphasis>标记</entry>
	    </row>
	    <row>
	      <entry><option>-p</option></entry>
	      <entry>文件是一个<emphasis>管道</emphasis></entry>
	      <entry></entry>
	      <entry><option>-u</option></entry>
	      <entry>设置了<emphasis>suid</emphasis>标记</entry>
	    </row>
	    <row>
	      <entry><option>-S</option></entry>
	      <entry>文件是一个<link linkend="socketref">socket</link></entry>
	      <entry></entry>
	      <entry><option>-k</option></entry>
	      <entry>设置了<quote>粘贴位</quote></entry>
	    </row>
	    <row>
	      <entry><option>-t</option></entry>
	      <entry>文件与一个<emphasis>终端</emphasis>相关联</entry>
	    </row>
	    <row><entry></entry></row>
	    <row>
	      <entry><option>-N</option></entry>
	      <entry>从这个文件最后一次被读取之后, 它被修改过</entry>
	      <entry></entry>
	      <entry><option>F1 -nt F2</option></entry>
	      <entry>文件F1比文件F2<emphasis>新</emphasis> *</entry>
	    </row>
	    <row>
	      <entry><option>-O</option></entry>
	      <entry>这个文件的宿主是你</entry>
	      <entry></entry>
	      <entry><option>F1 -ot F2</option></entry>
	      <entry>文件F1比文件F2<emphasis>旧</emphasis> *</entry>
	    </row>
	    <row>
	      <entry><option>-G</option></entry>
	      <entry>文件的<emphasis>组id</emphasis>与你所属的组相同</entry>
	      <entry></entry>
	      <entry><option>F1 -ef F2</option></entry>
	      <entry>文件F1和文件F2都是同一个文件的<emphasis>硬链接</emphasis> *</entry>
	    </row>
	    <row><entry></entry></row>
	    <row>
	      <entry><option>!</option></entry>
	      <entry><quote>非</quote> (反转上边的测试结果)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


      <para><command>*</command> <emphasis>二元</emphasis>操作符(需要两个操作数). </para>




      <table pgwide=0>
	<title>参数替换和扩展</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>表达式</entry>
	      <entry>含义</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>${var}</option></entry>
	      <entry>变量<parameter>var</parameter>的值, 与<parameter>$var</parameter>相同</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><option>${var-DEFAULT}</option></entry>
		  <entry>如果<parameter>var</parameter>没有被声明, 
			  那么就以<parameter>$DEFAULT</parameter>作为其值 *</entry>
	    </row>
	    <row>
	      <entry><option>${var:-DEFAULT}</option></entry>
	      <entry>如果<parameter>var</parameter>没有被声明, 或者其值为空,
		那么就以<parameter>$DEFAULT</parameter>作为其值 *</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><option>${var=DEFAULT}</option></entry>
		  <entry>如果<parameter>var</parameter>没有被声明, 
			  那么就以<parameter>$DEFAULT</parameter>作为其值 *</entry>
	    </row>
	    <row>
	      <entry><option>${var:=DEFAULT}</option></entry>
		  <entry>如果<parameter>var</parameter>没有被声明, 或者其值为空,
			  那么就以<parameter>$DEFAULT</parameter>作为其值 *</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><option>${var+OTHER}</option></entry>
		  <entry>如果<parameter>var</parameter>声明了, 
			  那么其值就是<parameter>$OTHER</parameter>, 
			  否则就为null字符串</entry>
	    </row>
	    <row>
	      <entry><option>${var:+OTHER}</option></entry>
		  <entry>如果<parameter>var</parameter>被设置了, 
			  那么其值就是<parameter>$OTHER</parameter>, 
			  否则就为null字符串</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><option>${var?ERR_MSG}</option></entry>
		  <entry>如果<parameter>var</parameter>没被声明, 
			  那么就打印<parameter>$ERR_MSG</parameter> *</entry>
	    </row>
	    <row>
	      <entry><option>${var:?ERR_MSG}</option></entry>
		  <entry>如果<parameter>var</parameter>没被设置, 
			  那么就打印<parameter>$ERR_MSG</parameter> *</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><option>${!varprefix*}</option></entry>
	      <entry>匹配之前所有以<parameter>varprefix</parameter>开头进行声明的变量</entry>
	    </row>
	    <row>
	      <entry><option>${!varprefix@}</option></entry>
	      <entry>匹配之前所有以<parameter>varprefix</parameter>开头进行声明的变量</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para><command>*</command> 当然, 如果变量<parameter>var</parameter>已经被设置的话, 
        那么其值就是<parameter>$var</parameter>. </para>


      <table pgwide=0>
	<title>字符串操作</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>表达式</entry>
	      <entry>含义</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>${#string}</option></entry>
	      <entry><parameter>$string</parameter>的长度</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><option>${string:position}</option></entry>
		  <entry>在<parameter>$string</parameter>中, 
			  从位置<parameter>$position</parameter>开始提取子串
		</entry>
	    </row>
	    <row>
	      <entry><option>${string:position:length}</option></entry>
		  <entry>在<parameter>$string</parameter>中, 
			  从位置<parameter>$position</parameter>开始提取长度为<parameter>$length</parameter>的子串
		</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><option>${string#substring}</option></entry>
		  <entry>从变量<parameter>$string</parameter>的开头, 
			  删除最短匹配<parameter>$substring</parameter>的子串
	      </entry>
	    </row>
	    <row>
	      <entry><option>${string##substring}</option></entry>
	      <entry>从变量<parameter>$string</parameter>的开头, 
			  删除最长匹配<parameter>$substring</parameter>的子串
	      </entry>
	    </row>
	    <row>
	      <entry><option>${string%substring}</option></entry>
	      <entry>从变量<parameter>$string</parameter>的结尾, 
			  删除最短匹配<parameter>$substring</parameter>的子串
	      </entry>
	    </row>
	    <row>
	      <entry><option>${string%%substring}</option></entry>
	      <entry>从变量<parameter>$string</parameter>的结尾, 
			  删除最长匹配<parameter>$substring</parameter>的子串
	      </entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><option>${string/substring/replacement}</option></entry>
	      <entry>使用<parameter>$replacement</parameter>, 
	      来代替第一个匹配的<parameter>$substring</parameter>
	      </entry>
	    </row>
	    <row>
	      <entry><option>${string//substring/replacement}</option></entry>
	      <entry>使用<parameter>$replacement</parameter>, 
	      代替<emphasis>所有</emphasis>匹配的<parameter>$substring</parameter>
	      </entry>
	    </row>
	    <row>
	      <entry><option>${string/#substring/replacement}</option></entry>
	      <entry>如果<parameter>$string</parameter>的<emphasis>前缀</emphasis>匹配<parameter>$substring</parameter>, 
	      那么就用<parameter>$replacement</parameter>来代替匹配到的<parameter>$substring</parameter></entry>
	    </row>
	    <row>
	      <entry><option>${string/%substring/replacement}</option></entry>
	      <entry>如果<parameter>$string</parameter>的<emphasis>后缀</emphasis>匹配<parameter>$substring</parameter>, 
	      那么就用<parameter>$replacement</parameter>来代替匹配到的<parameter>$substring</parameter></entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><option>expr match "$string" '$substring'</option></entry>
	      <entry>匹配<parameter>$string</parameter>开头的<parameter>$substring</parameter>*的长度</entry>
	    </row>
	    <row>
	      <entry><option>expr "$string" : '$substring'</option></entry>
	      <entry>匹配<parameter>$string</parameter>开头的<parameter>$substring</parameter>*的长度</entry>
	    </row>
	    <row>
	      <entry><option>expr index "$string" $substring</option></entry>
	      <entry>在<parameter>$string</parameter>中匹配到的<parameter>$substring</parameter>的第一个字符出现的位置</entry>
	    </row>
	    <row>
	      <entry><option>expr substr $string $position
	        $length</option></entry>
	      <entry>在<parameter>$string</parameter>中从位置<parameter>$position</parameter>开始提取长度为<parameter>$length</parameter>的子串</entry>
            </row>
	    <row>
	      <entry><option>expr match "$string"
	        '\($substring\)'</option></entry>
	      <entry>从<parameter>$string</parameter>的开头位置提取<parameter>$substring</parameter>*</entry>
            </row>
	    <row>
	      <entry><option>expr "$string" :
	        '\($substring\)'</option></entry>
	      <entry>从<parameter>$string</parameter>的开头位置提取<parameter>$substring</parameter>*</entry>
            </row>
	    <row>
	      <entry><option>expr match "$string"
	        '.*\($substring\)'</option></entry>
	      <entry>从<parameter>$string</parameter>的结尾提取<parameter>$substring</parameter>*</entry>
            </row>
	    <row>
	      <entry><option>expr "$string" :
	        '.*\($substring\)'</option></entry>
	      <entry>从<parameter>$string</parameter>的结尾提取<parameter>$substring</parameter>*</entry>
            </row>
	  </tbody>
	</tgroup>
      </table>
      
      <para><command>*</command> <parameter>$substring</parameter>是一个<emphasis>正则表达式</emphasis>. </para>



      <table pgwide=0>
	<title>一些结构的汇总</title>
	<tgroup cols="2">
	  <thead>

	    <row>
	      <entry>表达式</entry>
	      <entry>解释</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><emphasis>中括号</emphasis></entry><entry></entry>
	    </row>  
	    <row>
	      <entry><option>if [ CONDITION ]</option></entry>
	      <entry>测试结构</entry>
	    </row>
	    <row>
	      <entry><option>if [[ CONDITION ]]</option></entry>
	      <entry>扩展的测试结构</entry>
	    </row>
	    <row>
	      <entry><option>Array[1]=element1</option></entry>
	      <entry>数组初始化</entry>
	    </row>
	    <row>
	      <entry><option> [a-z]</option></entry>
	      <entry><link linkend="regexref">正则表达式</link>的字符范围</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><emphasis>大括号</emphasis></entry><entry></entry>
	    </row>  
	    <row>
	      <entry><option>${variable}</option></entry>
	      <entry>参数替换</entry>
	    </row>
	    <row>
	      <entry><option>${!variable}</option></entry>
	      <entry><link linkend="ivrref">间接变量引用</link></entry>
	    </row>
	    <row>
	      <entry><option>{ command1; command2; . . . commandN; }</option></entry>
	      <entry>代码块</entry>
	    </row>
	    <row>
	      <entry><option>{string1,string2,string3,...}</option></entry>
	      <entry>大括号扩展</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><emphasis>圆括号</emphasis></entry><entry></entry>
	    </row>  
	    <row>
	      <entry><option>( command1; command2 )</option></entry>
	      <entry><link linkend="subshellsref">子shell</link>中执行的命令组</entry>
	    </row>
	    <row>
	      <entry><option>Array=(element1 element2 element3)</option></entry>
	      <entry>数组初始化</entry>
	    </row>
	    <row>
	      <entry><option>result=$(COMMAND)</option></entry>
	      <entry>在子shell中执行命令, 并将结果赋值给变量</entry>
	    </row>
	    <row>
	      <entry><option>&gt;(COMMAND)</option></entry>
	      <entry><link linkend="processsubref">进程替换</link></entry>
	    </row>
	    <row>
	      <entry><option>&lt;(COMMAND)</option></entry>
	      <entry>进程替换</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><emphasis>双圆括号</emphasis></entry><entry></entry>
	    </row>  
	    <row>
	      <entry><option>(( var = 78 ))</option></entry>
	      <entry>整型运算</entry>
	    </row>
	    <row>
	      <entry><option>var=$(( 20 + 5 ))</option></entry>
	      <entry>整型运算, 并将结果赋值给变量</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><emphasis>引号</emphasis></entry><entry></entry>
	    </row>  
	    <row>
	      <entry><option>"$variable"</option></entry>
	      <entry>"弱"引用</entry>
	    </row>  
	    <row>  
	      <entry><option>'string'</option></entry>
	      <entry>"强"引用</entry>
	    </row>
	    <row><entry></entry><entry></entry></row>
	    <row>
	      <entry><emphasis>后置引用</emphasis></entry><entry></entry>
	    </row>  
	    <row>
	      <entry><option>result=`COMMAND`</option></entry>
	      <entry>在子shell中运行命令, 并将结果赋值给变量</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

  </appendix>
    <!-- Reference Cards appendix -->





  <appendix id="sedawk">
      <title>一个学习Sed和Awk的小手册</title>
      
      <para><anchor id="sedref"></para>

      <para>这是一份关于<command>sed</command>和<command>awk</command>文本处理工具的概要介绍. 
		  我们在这里只讨论一些基本命令, 
		  但是这些基本命令已经足够让我们了解如何在shell脚本中使用简单的sed和awk结构. 
	</para>


       <para><command>sed</command>: 一个非交互的文本文件编辑器</para>

       <para><command>awk</command>: 一个面向域的模式处理语言, 使用类似C的语法</para>

	   <para>在我们讨论这两个工具的差异性之前, 我们先说一下它们的共性, 
		   这两个工具都使用类似的调用语法, 都使用<link linkend="regexref">正则表达式</link>, 
		   默认情况下都从<filename>stdin</filename>中读取输入, 
		   并且都输出到<filename>stdout</filename>. 
		   它们都是行为良好的UNIX工具, 并且它们能够很好的在一起工作. 
		   其中一个的输出可以通过管道传递给另一个, 正是由于它们组合能力, 
		   才使得shell脚本能够具备一些Perl的特性. 
	 </para>

	 <note><para>注意一下这两个工具之间的一个非常重要的区别, 
			 shell脚本可以很容易的给sed传递参数, 
			 但是传递参数给awk就比较复杂(请参考<xref 
				 linkend="coltotaler">和<xref linkend="coltotaler2">). 
	 </para></note>


    <sect1>
      <title>Sed</title>

	  <para>Sed是非交互式的行编辑器. 
		  它即可以从<filename>stdin</filename>中接收文本输入, 
		  也可以从文件中接收文本输入, 它对输入中的指定行进行特定的操作, 
		  一行操作一次, 然后将结果输出到<filename>stdout</filename>, 或输出到文件中. 
		  在shell脚本中使用的话, 
	sed通常都是作为管道工具链中的一个处理部分来使用. </para>

      <para>Sed会决定它需要处理那些行, 因为sed的参数就包含有<emphasis>地址范围</emphasis>. 
	  <footnote><para>如果没指定地址范围, 那么默认就是<emphasis>所有</emphasis>行. </para></footnote>
	既可以通过行号来指定地址范围, 也可以通过模式匹配来决定地址范围. 
	比如, <replaceable>3d</replaceable>表示sed会删除输入的第3行, 
	<replaceable>/windows/d</replaceable>表示sed会删除掉所有匹配<quote>windows</quote>的输入行. </para>

      <para>对于sed工具包的所有操作来说, 我们最关心的其实就是3个最主要的操作. 
		  分别是<command>p</command>rinting(打印到<filename>stdout</filename>), 
		 <command>d</command>eletion(删除), 
	和<command>s</command>ubstitution(替换). </para>


      <table>
	<title>基本sed操作</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>操作符</entry>
	      <entry>名字</entry>
	      <entry>效果</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>[地址范围]/p</option></entry>
	      <entry>打印</entry>
	      <entry>打印[指定的地址范围]</entry>
	    </row>
	    <row>
	      <entry><option>[地址范围]/d</option></entry>
	      <entry>删除</entry>
	      <entry>删除[指定的地址范围]</entry>
	    </row>
	    <row>
	      <entry><option>s/pattern1/pattern2/</option></entry>
	      <entry>替换</entry>
	      <entry>将指定行中, 将第一个匹配到的pattern1, 替换为pattern2. </entry>
	    </row>
	    <row>
	      <entry><option>[地址范围]/s/pattern1/pattern2/</option></entry>
	      <entry>替换</entry>
	      <entry>在<replaceable>地址范围</replaceable>指定的每一行中, 将第一个匹配到的pattern1, 替换为pattern2.
	      </entry>
	    </row>
	    <row>
	      <entry><option>[地址范围]/y/pattern1/pattern2/</option></entry>
	      <entry>transform</entry>
		  <entry>在<replaceable>地址范围</replaceable>指定的每一行中, 
			  将pattern1中的每个匹配到pattern2的字符都使用pattern2的相应字符作替换. 
			  (等价于<command>tr</command>命令)</entry>
	    </row>
	    <row>
	      <entry><option>g</option></entry>
	      <entry>全局</entry>
	      <entry>在每个匹配的输入行中, 将<emphasis>每个</emphasis>模式匹配都作相应的操作. (译者注: 不只局限于第一个匹配) 
	        </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <note><para>除非在<emphasis>替换</emphasis>命令的后边明确指定选项<option>g</option>(<emphasis>全局</emphasis>), 
	否则的话, 替换操作只会替换掉每行上的第一个模式匹配实例. 
	</para></note>

      <para>如果在命令行或脚本中使用这个命令, sed操作可能还需要某些选项和引用. </para>

       <para><programlisting>sed -e '/^$/d' $filename
# -e选项, 将会使得后边的字符被看作为编辑指令. 
#  (如果只给"sed"传递了单个指令, 那么"-e"是可选的.)
#  "强"引用('')将会保护指令中的RE(正则表达式)字符串, 
#+ 也就是防止脚本将RE重新解释为特殊字符. 
# (这会为sed命令, 保存指令的RE表达式.)
#
# 将会对文件$filename中的文本进行操作. 
</programlisting></para>

	<para>在某些特定的情况下, 
	<command>sed</command>编辑命令将不会和单引号的强引用一起工作. 
    </para>

       <para><programlisting>
filename=file1.txt
pattern=BEGIN

  sed "/^$pattern/d" "$filename"  # 工作正常. 
# sed '/^$pattern/d' "$filename"    就会出现异常的结果. 
#        在这个实例中, 被强引用(' ... ')引起的
#+      "$pattern"就不会扩展为"BEGIN". </programlisting></para>


       <note><para>Sed命令的<option>-e</option>选项表示后续的字符串是一个指令, 或指令集. 
		如果后续的字符串中只有一个指令, 
		那么<option>-e</option>选项可以被省略. 
	 </para></note>

       <para><programlisting>sed -n '/xzy/p' $filename
# -n选项会让sed只打印那些匹配模式的行. 
# 否则所有的输入行都会被打印. 
# 这里可以省略-e选项, 因为这里只有一个编辑指令. 
</programlisting></para>

      <table>
	<title>sed操作符举例</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>表示法</entry>
	      <entry>效果</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>8d</option></entry>
	      <entry>删除输入的第8行. </entry>
	    </row>
	    <row>
	      <entry><option>/^$/d</option></entry>
	      <entry>删除所有空行. </entry>
	    </row>
	    <row>
	      <entry><option>1,/^$/d</option></entry>
	      <entry>从输入的开头一直删除到第1个空行(第一个空行也删除掉). </entry>
	    </row>
	    <row>
	      <entry><option>/Jones/p</option></entry>
	      <entry>只打印那些包含<quote>Jones</quote>的行(使用<token>-n</token>选项). </entry>
	    </row>
	    <row>
	      <entry><option>s/Windows/Linux/</option></entry>
		  <entry>在每个输入行中, 
			 将第一个出现的<quote>Windows</quote>实例替换为<quote>Linux</quote>. 
	        </entry>
	    </row>
	    <row>
	      <entry><option>s/BSOD/stability/g</option></entry>
	      <entry>在每个输入行中, 将所有<quote>BSOD</quote>都替换为<quote>stability</quote>. </entry>
	    </row>
	    <row>
	      <entry><option>s/ *$//</option></entry>
	      <entry>删除掉每行结尾的所有空格. </entry>
	    </row>
	    <row>
	      <entry><option>s/00*/0/g</option></entry>
	      <entry>将所有连续出现的0都压缩成单个的0. </entry>
	    </row>
	    <row>
	      <entry><option>/GUI/d</option></entry>
	      <entry>删除掉所有包含<quote>GUI</quote>的行. </entry>
	    </row>
	    <row>
	      <entry><option>s/GUI//g</option></entry>
	      <entry>将所有<quote>GUI</quote>都删除掉, 并保持剩余部分的完整性. 
	        </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


     <para>在输入行中, 将一个字符串替换为空字符, 等价于删除这个字符串. 
       剩余部分会保持完整. 比如<userinput>s/GUI//</userinput>, 拿下边这句为例: 
       <screen><userinput>The most important parts of any application are its GUI and sound effects</userinput></screen>
       结果为: 
       <screen><computeroutput>The most important parts of any application are its  and sound effects</computeroutput></screen></para>

     <para>反斜线将会强制<command>sed</command>替换命令延续到下一行. 
       类似于, 在第一行的结尾使用<emphasis>换行</emphasis>作为<emphasis>替换字符串</emphasis>. 

       <programlisting>s/^  */\
/g</programlisting>

	   这将每行开头的空格用换行来替换. 
	   最后的结果就是将每段的缩进替换为一个空行. 
       </para>

	   <para>地址范围后边可以加上一系列操作, 
		   这些操作可能需要放到大括号对中, 并且需要重起一行. 
       <programlisting>/[0-9A-Za-z]/,/^$/{
/^$/d
}</programlisting>
	   这只会删除连续空行中的第一行. 
	   对于单行间距的文本文件来说, 这很有用, 但是会保留段落间的空行. 
       </para>


     <tip><para>将文本文件双倍行距的快速方法是<userinput>sed G filename</userinput>. </para></tip>  

     <para>下面是一些在脚本中使用sed命令的例子: 
       <orderedlist>
         <listitem><para><xref linkend="ex3"></para></listitem>
	 <listitem><para><xref linkend="ex4"></para></listitem>
	 <listitem><para><xref linkend="ex57"></para></listitem>
         <listitem><para><xref linkend="rn"></para></listitem>
	 <listitem><para><xref linkend="grp"></para></listitem>
	 <listitem><para><xref linkend="col"></para></listitem>
         <listitem><para><xref linkend="behead"></para></listitem>
	 <listitem><para><xref linkend="tree"></para></listitem>
	 <listitem><para><xref linkend="stripc"></para></listitem>
	 <listitem><para><xref linkend="findstring"></para></listitem>
	 <listitem><para><xref linkend="base"></para></listitem>
	 <listitem><para><xref linkend="mailformat"></para></listitem>
	 <listitem><para><xref linkend="rnd"></para></listitem>
	 <listitem><para><xref linkend="wf"></para></listitem>
	 <listitem><para><xref linkend="lifeslow"></para></listitem>
         <listitem><para><xref linkend="selfdocument"></para></listitem>
         <listitem><para><xref linkend="dictlookup"></para></listitem>
         <listitem><para><xref linkend="whx"></para></listitem>
       </orderedlist>
     </para>  

      <para>如果想了解sed命令的更多细节, 请察看<xref linkend="biblio">中的这方面的参考资料. </para>

    </sect1>
    <!-- End sed primer -->



    <sect1 id="awk">
      <title>Awk</title>

      <para><anchor id="awkref"></para>

     <para><command>Awk</command>是功能完整的文本处理语言, 
		 使用类似于<command>C</command>的语法. 
		 它具有一整套操作符和能力集, 我们只在这里讲解一小部分 - 
		 也就是在shell脚本中最有用的部分. 
       </para>

	   <para>Awk将传递进来的每行输入都分割成<firstterm>域</firstterm>. 
		   默认情况下, 一个域指的就是使用<link
			   linkend="whitespaceref">空白</link>分隔的一个连续字符串, 
		   不过我们可以修改属性来改变分隔符. 
       Awk将会分析并操作每个分割域. 
	   因为这种特性, 所以awk非常善于处理结构化的文本文件 -- 
	   尤其是表 -- 将数据组织成统一的块, 
	   比如说分成行和列. </para>

     <para>强引用(单引号)和大括号用来包含shell脚本中的awk代码段. </para>

     <para><programlisting>echo one two | awk '{print $1}'
# one

echo one two | awk '{print $2}'
# two


awk '{print $3}' $filename
# 打印文件$filename的域#3, 到stdout. 

awk '{print $1 $5 $6}' $filename
# 打印文件$filename的域#1, #5, 和#6. </programlisting></para> 

     <para>事实上, 上边我们只讲解了awk的<command>print</command>命令. 
       我们需要在这里讲解awk的另一个特点, 变量. 
	   Awk处理变量的手段与shell脚本很相似, 
	  虽然更复杂一些. 
       </para>

     <para><programlisting>{ total += ${column_number} }</programlisting>
		 上边这句将<emphasis>column_number</emphasis>的值加上<quote>total</quote>的值然后再赋给<emphasis>total</emphasis>. 
		 最后, 为了打印出<quote>total</quote>, 
		 我们需要一个<command>END</command>命令块, 
       当脚本处理完所有输入之后, 就会执行这个命令块中的内容. 
       <programlisting>END { print total }</programlisting></para>

   <para>与<command>END</command>对应, 
	   还有<command>BEGIN</command>命令块, 
       在脚本处理所有输入之前, 将会执行这个命令块中的内容. 
       </para>

     <para>下面这个例子展示了<command>awk</command>如何在shell脚本中添加文本分析工具. 
       </para>

    <example id="lettercount2">
      <title>计算字符出现次数</title>
      <programlisting>&lettercount2;</programlisting>
    </example>

     <para>如果想再看一些在shell脚本中使用awk的简单例子, 如下: 
       <orderedlist>
         <listitem><para><xref linkend="ex44"></para></listitem>
	 <listitem><para><xref linkend="redir4"></para></listitem>
	 <listitem><para><xref linkend="stripc"></para></listitem>
         <listitem><para><xref linkend="coltotaler"></para></listitem>
         <listitem><para><xref linkend="coltotaler2"></para></listitem>
         <listitem><para><xref linkend="coltotaler3"></para></listitem>
         <listitem><para><xref linkend="pidid"></para></listitem>
         <listitem><para><xref linkend="constat"></para></listitem>
         <listitem><para><xref linkend="fileinfo"></para></listitem>
         <listitem><para><xref linkend="blotout"></para></listitem>
         <listitem><para><xref linkend="seedingrandom"></para></listitem>
         <listitem><para><xref linkend="idelete"></para></listitem>
         <listitem><para><xref linkend="substringex"></para></listitem>
         <listitem><para><xref linkend="sumproduct"></para></listitem>
         <listitem><para><xref linkend="userlist"></para></listitem>
         <listitem><para><xref linkend="prasc"></para></listitem>
       </orderedlist>
      </para>	 

	  <para>我们在这里所要讲解的awk内容就这么多, 
		  但是事实上还有好多东西需要学. 
		  可以参考<xref linkend="biblio">中的内容深入学习. </para>


     </sect1> 
    <!-- End awk primer -->

  </appendix>
    <!-- End sed/awk appendix -->



  <appendix id="exitcodes">
      <title>带有特殊含义的退出码</title>

      <para><anchor id="exitcodesref"></para>

      <table>
	<title><quote>保留的</quote>退出码</title>
	<tgroup cols="4">
	  <thead>
	    <row>
	      <entry>退出码的值</entry>
	      <entry>含义</entry>
	      <entry>例子</entry>
	      <entry>注释</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>1</option></entry>
	      <entry>通用错误</entry>
	      <entry>let "var1 = 1/0"</entry>
	      <entry>各种各样的错误都可能使用这个退出码, 比如<quote>除0错误</quote></entry>
	    </row>
	    <row>
	      <entry><option>2</option></entry>
	      <entry>shell内建命令使用错误(Bash文档上有说明)</entry>
	      <entry></entry>
	      <entry>很少看到, 通常情况下退出码都为<errorcode>1</errorcode></entry>
	    </row>
	    <row>
	      <entry><option>126</option></entry>
	      <entry>命令调用不能执行</entry>
	      <entry></entry>
	      <entry>程序或命令的权限是不可执行的</entry>
	    </row>
	    <row>
	      <entry><option>127</option></entry>
	      <entry><quote>command not found</quote></entry>
	      <entry></entry>
	      <entry>估计是<varname>$PATH</varname>不对, 或者是拼写错误</entry>
	    </row>
	    <row>
	      <entry><option>128</option></entry>
	      <entry><link linkend="exitcommandref">exit</link>的参数错误</entry>
	      <entry>exit 3.14159</entry>
		  <entry><command>exit</command>只能以整数作为参数, 
			  范围是<returnvalue>0 - 255</returnvalue>(见脚注)</entry>
	    </row>
	    <row>
	      <entry><option>128+n</option></entry>
	      <entry>信号<quote>n</quote>的致命错误</entry>
	      <entry><command>kill -9</command> 脚本的<varname>$PPID</varname></entry>
	      <entry><userinput>$?</userinput> 返回<errorcode>137</errorcode>(128 + 9)</entry>
	    </row>
	    <row>
	      <entry><option>130</option></entry>
	      <entry>用Control-C来结束脚本</entry>
	      <entry></entry>
		  <entry>Control-C是信号<errorcode>2</errorcode>的致命错误, 
			  (130 = 128 + 2, 见上边)</entry>
	    </row>
	    <row>
	      <entry><option>255*</option></entry>
	      <entry>超出范围的退出状态</entry>
	      <entry>exit <returnvalue>-1</returnvalue></entry>
	      <entry><command>exit</command>命令只能够接受范围是<errorcode>0 - 255</errorcode>的整数作为参数</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>通过上面的表, 我们了解到, 退出码<errorcode>1 - 2,
        126 - 165, 和255</errorcode>

	<footnote><para>超出范围的退出值可能会产生意想不到的退出码. 
			如果退出值比<errorcode>255</errorcode>大, 
			那么退出码将会取<errorcode>256</errorcode>的<link linkend="moduloref">模</link>. 
	  举个例子, <command>exit 3809</command>的退出码将是<errorcode>225</errorcode>(3809 % 256 = 225). </para></footnote>

	都具有特殊的含义, 因此应该避免使用用户指定的退出参数. 
	如果脚本使用<command>exit 127</command>作为退出语句, 
	那么可能就会在故障诊断的时候产生混淆(如何判断这是由<quote>command not found</quote>引起的, 还是由用户定义引起的?). 
	然而, 许多脚本使用<command>exit 1</command>作为通用的返回错误值. 
	因为退出码<errorcode>1</errorcode>能够表示的错误太多了, 
	不过这么做, 对于调试来说, 也起不到任何帮助的作用. 
	</para>

      <para>其实早就有人对退出状态值进行了系统的分类(请参考<filename
	class="headerfile">/usr/include/sysexits.h</filename>), 
	不过这个文件是为C/C++程序员准备的. 
	其实shell脚本也需要这样一个类似的标准. 
	所以本文作者呼吁限制使用用户定义的退出码, 
	尤其是范围<returnvalue>64 - 113</returnvalue>(还有<returnvalue>0</returnvalue>, 表示成功), 
	这么做, 就可以和C/C++标准保持一致. 
	这样我们就有了50个可用的退出码, 
	而且非常便于故障诊断. </para>

      <para>本书中所有例子中的用户定义退出码都符合这个标准, 
	除了那些超出标准范围的例子, 比如<xref linkend="tmdin">. </para>

	<note><para>只有在Bash或<emphasis>sh</emphasis>提示符下, 当shell脚本退出后, 
			在命令行上使用<link linkend="xstatvarref">$?</link>才会得到与上表相一致的结果. 
	在某些情况下, 
	运行C-shell或者<emphasis>tcsh</emphasis>可能会给出不同的值. </para></note>


  </appendix>
    <!-- End Reserved Exit Code appendix -->


  <appendix id="ioredirintro">
	  <title>I/O和I/O重定向的详细介绍</title>

      <para><emphasis>由Stephane Chazelas编写, 本书作者修订</emphasis></para>

	  <para>一个命令期望前3个<link linkend="fdref">文件描述符</link>是可用的. 
		 第一个, <emphasis>fd 0</emphasis>(标准输入, <filename>stdin</filename>), 
        用作读取. 另外两个, (<emphasis>fd 1</emphasis>, 
        <filename>stdout</filename>和<emphasis>fd 2</emphasis>, 
        <filename>stderr</filename>), 用来写入. </para>

	<para>每个命令都会关联到<filename>stdin</filename>, 
		<filename>stdout</filename>, 和<filename>stderr</filename>. 
        <userinput>ls 2&gt;&1</userinput>意味着临时的将<command>ls</command>命令的<filename>stderr</filename>连接到shell的<filename>stdout</filename>. </para>

	<para>按惯例, 命令一般都是从fd 0(<filename>stdin</filename>)上读取输入, 
		打印输出到fd 1(<filename>stdout</filename>)上, 
		错误输出一般都输出到fd 2(<filename>stderr</filename>)上. 
		如果这3个文件描述中的某一个没打开, 你可能就会遇到麻烦了: 
        </para>

      <screen>
<prompt>bash$ </prompt><userinput>cat /etc/passwd >&-</userinput>
<computeroutput>cat: standard output: Bad file descriptor</computeroutput>
      </screen>

	  <para>比如说, 当<command>xterm</command>运行的时候, 
		  它首先会初始化自身. 
		  在运行用户shell之前, 
        <command>xterm</command>会打开终端设备(/dev/pts/&lt;n&gt; 或者类似的东西)三次. </para>

      <para>这里, Bash继承了这三个文件描述符, 
        而且每个运行在Bash上的命令(子进程)也都依次继承了它们, 
        除非你重定向了这些命令. <link
			linkend="ioredirref">重定向</link>意味着将这些文件描述符中的某一个, 
		重新分配到其他文件中(或者分配到一个管道中, 或者是其他任何可能的东西). 
		文件描述符既可以被局部重分配(对于一个命令, 命令组, 
		一个子shell, 一个<link
        linkend="redirref">while循环, if或case结构</link>...), 
        也可以全局重分配, 对于余下的shell(使用<link
        linkend="execref">exec</link>). </para>

      <para><userinput>ls &gt; /dev/null</userinput> 表示将运行的<command>ls</command>命令的fd 1连接到<filename>/dev/null</filename>上. </para>

      <para>
      <screen>
<prompt>bash$ </prompt><userinput>lsof -a -p $$ -d0,1,2</userinput>
<computeroutput>COMMAND PID     USER   FD   TYPE DEVICE SIZE NODE NAME
 bash    363 bozo        0u   CHR  136,1         3 /dev/pts/1
 bash    363 bozo        1u   CHR  136,1         3 /dev/pts/1
 bash    363 bozo        2u   CHR  136,1         3 /dev/pts/1</computeroutput>


<prompt>bash$ </prompt><userinput>exec 2&gt; /dev/null</userinput>
<prompt>bash$ </prompt><userinput>lsof -a -p $$ -d0,1,2</userinput>
<computeroutput>COMMAND PID     USER   FD   TYPE DEVICE SIZE NODE NAME
 bash    371 bozo        0u   CHR  136,1         3 /dev/pts/1
 bash    371 bozo        1u   CHR  136,1         3 /dev/pts/1
 bash    371 bozo        2w   CHR    1,3       120 /dev/null</computeroutput>


<prompt>bash$ </prompt><userinput>bash -c 'lsof -a -p $$ -d0,1,2' | cat</userinput>
<computeroutput>COMMAND PID USER   FD   TYPE DEVICE SIZE NODE NAME
 lsof    379 root    0u   CHR  136,1         3 /dev/pts/1
 lsof    379 root    1w  FIFO    0,0      7118 pipe
 lsof    379 root    2u   CHR  136,1         3 /dev/pts/1</computeroutput>


<prompt>bash$ </prompt><userinput>echo "$(bash -c 'lsof -a -p $$ -d0,1,2' 2&gt;&1)"</userinput>
<computeroutput>COMMAND PID USER   FD   TYPE DEVICE SIZE NODE NAME
 lsof    426 root    0u   CHR  136,1         3 /dev/pts/1
 lsof    426 root    1w  FIFO    0,0      7520 pipe
 lsof    426 root    2w  FIFO    0,0      7520 pipe</computeroutput>
</screen>
</para>

<para>这是用来展示不同类型的重定向. </para>

<para><userinput>练习:</userinput> 分析下面的脚本. 

<programlisting>#! /usr/bin/env bash                                                                                    
												
mkfifo /tmp/fifo1 /tmp/fifo2                                                                            
while read a; do echo "FIFO1: $a"; done < /tmp/fifo1 &                                                  
exec 7> /tmp/fifo1                                                                                      
exec 8> >(while read a; do echo "FD8: $a, to fd7"; done >&7)                                            
                                                                                                        
exec 3>&1                                                                                               
(                                                                                                       
 (                                                                                                      
  (                                                                                                     
   while read a; do echo "FIFO2: $a"; done < /tmp/fifo2 | tee /dev/stderr | tee /dev/fd/4 | tee /dev/fd/5 | tee /dev/fd/6 >&7 &                                                                        
   exec 3> /tmp/fifo2                                                                                   
                                                                                                        
   echo 1st, to stdout                                                                                  
   sleep 1                                                                                              
   echo 2nd, to stderr >&2                                                                              
   sleep 1                                                                                              
   echo 3rd, to fd 3 >&3                                                                                
   sleep 1                                                                                              
   echo 4th, to fd 4 >&4                                                                                
   sleep 1                                                                                              
   echo 5th, to fd 5 >&5                                                                                
   sleep 1                                                                                              
   echo 6th, through a pipe | sed 's/.*/PIPE: &, to fd 5/' >&5                                          
   sleep 1                                                                                              
   echo 7th, to fd 6 >&6                                                                                
   sleep 1                                                                                              
   echo 8th, to fd 7 >&7                                                                                
   sleep 1                                                                                              
   echo 9th, to fd 8 >&8                                                                                
                                                                                                        
  ) 4>&1 >&3 3>&- | while read a; do echo "FD4: $a"; done 1>&3 5>&- 6>&-                                
 ) 5>&1 >&3 | while read a; do echo "FD5: $a"; done 1>&3 6>&-                                           
) 6>&1 >&3 | while read a; do echo "FD6: $a"; done 3>&-                                                 
                                                                                                        
rm -f /tmp/fifo1 /tmp/fifo2


# 对于每个命令和子shell, 分别指出每个fd的指向. 

exit 0</programlisting>
      </para>

  </appendix>
    <!-- A Detailed Introduction to I/O and I/O Redirection -->


   <appendix id="command-line-options">
     <title>命令行选项</title>

     <para>许多可执行文件, 不管是二进制可执行文件还是脚本文件, 
       都可以使用选项来修改它们运行时的行为. 
	   比如: 在命令行上键入<command>command -o</command>, 
	   那么就意味着使用选项<option>o</option>来调用<emphasis>command</emphasis>. 
       </para>


   <sect1 id="standard-options">
     <title>标准命令行选项</title>

      <para>随着时间的流逝, 对于命令行选项标志的含义来说, 已经建立起了一套比较宽松的标准. 
        GNU工具比老式的UNIX工具更加符合这套<quote>标准</quote>. 
        </para>

      <para>按惯例, UNIX命令行选项通常都包含一个破折号, 后边跟一个或多个小写字母. 
        GNU工具增加了一个双破折号, 后边跟一个完整的单词或复合单词. 
        </para>


      <para>这两个最通用的选项是: </para>

      <itemizedlist id="widelyaccopt">

      <listitem>
      <para><option>-h</option></para>
      <para><option>--help</option></para>
      <para><emphasis>帮助</emphasis>: 给出使用信息, 然后退出. </para>
      </listitem>

      <listitem>
      <para><option>-v</option></para>
      <para><option>--version</option></para>
      <para><emphasis>版本</emphasis>: 现实程序版本号, 然后退出. </para>
      </listitem>

      </itemizedlist>


      <para>其他公用选项: </para>

      <itemizedlist id="otheroptns">

      <listitem>
      <para><option>-a</option></para>
      <para><option>--all</option></para>
      <para><emphasis>全部</emphasis>: 显示<emphasis>所有</emphasis>参数的<emphasis>全部</emphasis>信息或操作. 
        </para>
       
      </listitem>

      <listitem>
      <para><option>-l</option></para>
      <para><option>--list</option></para>
      <para><emphasis>列表</emphasis>: 列出文件或参数, 不采取其他动作. </para>
      </listitem>

      <listitem>
      <para><option>-o</option></para>
      <para><emphasis>输出</emphasis>文件</para>
      </listitem>

      <listitem>
      <para><option>-q</option></para>
      <para><option>--quiet</option></para>
      <para><emphasis>安静</emphasis>: 抑制<filename>stdout</filename>. </para>
      </listitem>

      <listitem>
      <para><option>-r</option></para>
      <para><option>-R</option></para>
      <para><option>--recursive</option></para>
      <para><emphasis>递归</emphasis>: 递归操作(包含子目录树). </para>
      </listitem>

      <listitem>
      <para><option>-v</option></para>
      <para><option>--verbose</option></para>
      <para><emphasis>冗余</emphasis>: 将额外的信息输出到<filename>stdout</filename>或<filename>stderr</filename>. </para>
      </listitem>

      <listitem>
      <para><option>-z</option></para>
      <para><option>--compress</option></para>
      <para><emphasis>压缩</emphasis>: 进行压缩(通常为<link linkend="gzipref">gzip</link>). </para>
      </listitem>

      </itemizedlist>


      <para>然而: </para>

      <itemizedlist id="exceptionsopts">

      <listitem>
      <para>在<command>tar</command>和<command>gawk</command>中: </para>
      <para><option>-f</option></para>
      <para><option>--file</option></para>
      <para><emphasis>文件</emphasis>: 跟文件名参数. </para>
      </listitem>

      <listitem>
      <para>在<command>cp</command>, <command>mv</command>,
        <command>rm</command>中:</para>
      <para><option>-f</option></para>
      <para><option>--force</option></para>
      <para><emphasis>强制</emphasis>: 目标文件的强制覆盖. </para>
      </listitem>

      </itemizedlist>


	  <caution><para>许多UNIX和Linux工具都严重的偏离了这个<quote>标准</quote>, 
		所以, 按照标准来<emphasis>假定</emphasis>一个给定选项的行为是非常危险的. 
      当遇到拿不准的问题时, 一定要经常察看命令的man页. 
      </para></caution>

      <para>GNU工具有一张完整的推荐选项表, 在<ulink
        url="http://www.gnu.org/prep/standards_19.html">http://www.gnu.org/prep/standards_19.html</ulink>. </para>

   </sect1>




   <sect1 id="bash-options">
     <title>Bash命令行选项</title>

     <para><firstterm>Bash</firstterm>本身也带有许多命令行选项. 
       下面就是一些有用的选项. </para>

      <itemizedlist id="bash-commline-opts">

      <listitem>
      <para><option>-c</option></para>
	  <para><emphasis>从这个选项后边的字符串中读取命令, 
		并且将参数分配到<link linkend="posparamref">位置参数</link>中. </emphasis></para>
       <para>
	      <screen>
<prompt>bash$ </prompt><userinput>bash -c 'set a b c d; IFS="+-;"; echo "$*"'</userinput>
<computeroutput>a+b+c+d</computeroutput>
	      </screen>
       </para>
      </listitem>

      <listitem>
      <para><option>-r</option></para>
      <para><option>--restricted</option></para>
      <para><emphasis>使用<link
				  linkend="restrictedshref">受限模式</link>运行这个shell, 
			  或脚本. </emphasis></para>
      </listitem>

      <listitem>
      <para><option>--posix</option></para>
      <para><emphasis>强制Bash符合<link
        linkend="posix2ref">POSIX</link>模式. </emphasis></para>
      </listitem>

      <listitem>
      <para><option>--version</option></para>
      <para><emphasis>显示Bash版本并退出. </emphasis></para>
      </listitem>

      <listitem>
      <para><option>--</option></para>
      <para><emphasis>选项的结束. 命令行上的其他东西就都是参数了, 不是选项. </emphasis></para>
      </listitem>

      </itemizedlist>

      </sect1>


   </appendix>
   <!-- End Command-Line Options appendix -->


   <appendix id="files">
    <title>重要的文件</title>

      <variablelist id="filesref">
        <title><anchor id="filesref1">启动文件</title>

	<varlistentry>
	  <term></term>
	<listitem>
	  <para>这些文件包含别名和<link
			  linkend="envref">环境变量</link>, 
		  正是这些别名和环境变量才使得Bash可以作为一个用户shell来运行, 
		  当系统初始化之后, 这些别名和变量也可被其他的的Bash脚本调用. 
	    </para>
	</listitem>
	</varlistentry>


	<varlistentry>
	  <term><filename>/etc/profile</filename></term>
	<listitem>
		<para>系统范围的默认值, 大部分用来设置环境(所有的Bourne类型的shell, 
			而不仅仅是Bash
	     <footnote><para>不能应用于<command>csh</command>,
		<command>tcsh</command>, 
		或那些与经典Bourne shell无关的shell(也就是说那些不是派生自<command>sh</command>的shell). 
	       </para></footnote>)</para>
	</listitem>
      </varlistentry>

	<varlistentry>
	  <term><filename>/etc/bashrc</filename></term>
	<listitem>
	  <para>特定于Bash的, 系统范围函数与<link
	  linkend="aliasref">别名</link></para>
	</listitem>
      </varlistentry>

	<varlistentry>
	  <term><filename><varname>$HOME</varname>/.bash_profile</filename></term>
	<listitem>
		<para>用户定义的, 环境默认设置, 
			在每个用户的home目录下都可找到(本地副本保存在<filename>/etc/profile</filename>)</para>
	</listitem>
      </varlistentry>

	<varlistentry>
	  <term><filename><varname>$HOME</varname>/.bashrc</filename></term>
	<listitem>
		<para>用户定义的Bash初始化文件, 
			可以在每个用户的home目录下找到(本地副本保存在<filename>/etc/bashrc</filename>). 
		只有交互式的shell和用户脚本才会读取这个文件. 
		请参考<xref linkend="sample-bashrc">, 
		这是一个<filename>.bashrc</filename>文件的例子. </para>
	</listitem>
      </varlistentry>

      </variablelist>


      <variablelist id="logoutfileref">
        <title><anchor id="logoutfileref1">登出文件</title>
	<varlistentry>
	  <term><filename><varname>$HOME</varname>/.bash_logout</filename></term>

	<listitem>
		<para>用户定义的指令文件, 
			在每个用户的home目录下找到. 
			在登出(Bash)shell的时候, 这个文件中的命令就会得到执行. 
	    </para>
	</listitem>

	</varlistentry>
      </variablelist>

  </appendix>
  <!-- End Files appendix -->





  <appendix id="systemdirs">

      <title>重要的系统目录</title>


      <para>每位系统管理员或者是编写系统管理脚本的人员都应该对这些系统目录非常熟悉. 
        </para>

        <itemizedlist>

          <listitem>
	    <para><filename class="directory">/bin</filename></para>
	    <para>二进制(可执行文件). 基本的系统程序和工具(比如<command>bash</command>). </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/bin</filename>

            <footnote>
				<para>早期的UNIX系统一般都有两个磁盘设备, 
					一个是速度快但容量小的硬盘(主要包含<filename 
					class="directory">/</filename>, 即根目录), 
	      另一个磁盘容量大, 但是速度慢(主要包含<filename
	      class="directory">/usr</filename>目录和其他分区). 
	      所以, 使用频率最高的程序和工具都放到小而快的磁盘中, 
	      也就是放到<filename class="directory">/bin</filename>中, 
	      而其他的东西都放到慢磁盘上, 即<filename
	      class="directory">/usr/bin</filename>中. </para>

	    <para>其他的类似的东西也是按照这种方式进行分类的, 
	      比如<filename class="directory">/sbin</filename>和<filename class="directory">/usr/sbin</filename>, 
	      <filename class="directory">/lib</filename>和<filename
	      class="directory">/usr/lib</filename>, 等等. </para>
	    </footnote>

	    </para>

	    <para>更多的系统二进制可执行文件. </para>

          </listitem>

          <listitem>
            <para><filename class="directory">/usr/local/bin</filename></para>
	    <para>一些局部于特定机器的杂项二进制可执行文件. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/sbin</filename></para>
			<para>系统二进制可执行文件. 
				基本的系统管理程序和工具(比如<command>fsck</command>). </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/sbin</filename></para>
	    <para>更多的系统管理程序和工具. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/etc</filename></para>

	    <para><emphasis>其他</emphasis>. 系统范围的配置脚本. </para>
	      
	    <para>其中比较有趣的文件是<filename>/etc/fstab</filename>(文件系统表), 
			<filename>/etc/mtab</filename>(挂载文件系统表), 
			还有文件<link
	      linkend="inittabref"><filename>/etc/inittab</filename></link>. 
	      </para>

	  </listitem>

          <listitem>
            <para><filename class="directory">/etc/rc.d</filename></para>
	    <para>启动脚本, 适用于红帽及其派生的Linux发行版. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/share/doc</filename></para>
	    <para>安装包的文档. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/man</filename></para>
	    <para>系统范围的man页. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/dev</filename></para>
	    <para>设备目录. 物理设备和虚拟设备的入口(但<emphasis>不是</emphasis>挂载点). 
	      请参考<xref linkend="devproc">. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/proc</filename></para>
	    <para>进程目录. 包含关于运行进程和内核参数的统计信息与其他信息. 
	      请参考<xref linkend="devproc">. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/sys</filename></para>
	    <para>系统范围的设备目录. 包含关于设备和设备名称的统计信息与其他信息. 
	      这是在Linux 2.6.X内核版本上新添加的目录. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/mnt</filename></para>
			<para><emphasis>挂载</emphasis>. 挂载硬驱动分区的目录, 
				比如<filename class="directory">/mnt/dos</filename>, 
				和物理驱动器. 
	      在比较新的Linux发行版中, <filename
			  class="directory">/media</filename>目录已经成为了I/O设备的首选挂载点. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/media</filename></para>
			<para>在比较新的Linux发行版中, I/O设备的首选挂载点, 
	      比如CD ROM或USB flash驱动器. </para>
          </listitem>

          <listitem>
	    <para><filename class="directory">/var</filename></para>
	    <para><emphasis>可变的</emphasis>(可修改的)系统文件. 
			这是一个包罗万象的<quote>杂项</quote>目录, 
			用于保存Linux/UNIX机器运行时产生的各种数据. 
	      </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/var/log</filename></para>
	    <para>系统范围的日志文件. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/var/spool/mail</filename></para>
	    <para>用户的假脱机邮件(mail spool).</para>
          </listitem>

          <listitem>
            <para><filename class="directory">/lib</filename></para>
	    <para>系统范围的库文件. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/usr/lib</filename></para>
	    <para>更多系统范围的库文件. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/tmp</filename></para>
	    <para>系统临时文件. </para>
          </listitem>

          <listitem>
            <para><filename class="directory">/boot</filename></para>
			<para>系统<emphasis>引导</emphasis>目录. 
				内核, 模块链接, 系统镜像, 和引导管理器都放在这. </para>
            <warning><para>如果在这个目录下修改文件, 可能会导致系统不能启动. </para></warning>
          </listitem>

        </itemizedlist>

  </appendix>



  <appendix id="localization">
      <title>本地化</title>


      <para>本地化是Bash的一个未文档化的特征. </para>

	  <para>对于一个本地化的shell脚本来说, 
		  它的输出都会使用本地系统所定义的语言. 
        对于一个德国柏林的Linux用户来说, 他的脚本会输出德文, 
        而对于他在马里兰的堂兄来说, 同样运行这个脚本, 输出就是英文. 
        </para>

		<para>为了创建一个本地化的脚本, 
			可以使用下面的模版来编写所有的用户消息(错误消息, 
			提示符, 等等.). 
        </para>

      <para>
      <programlisting>#!/bin/bash
# localized.sh
#  此脚本由Stephane Chazelas编写, 
#+ Bruno Haible进行了修改, Alfredo Pironti修正了bug. 

. gettext.sh

E_CDERROR=65

error()
{
  printf "$@" >&2
  exit $E_CDERROR
}

cd $var || error "`eval_gettext \"Can\'t cd to \\\$var.\"`"
#  $var前面之所以需要三个反斜线(转义)
#+ "因为在变量值还没被替换之前, 
#+ eval_gettext需要一个字符串."
#    -- per Bruno Haible
read -p "`gettext \"Enter the value: \"`" var
#  ...


#  ------------------------------------------------------------------
#  Alfredo Pironti注释: 

#  这个脚本已经被修改, 
#+ 使用"`gettext \"...\"`"语法形式替换了$"..."语法形式. 
#  这么做没问题, 但是在新的localized.sh程序中, 
#+ 命令"bash -D filename" and "bash --dump-po-string filename"
#+ 将不会产生输出
#+ (因为那些命令只会搜索$"..."字符串)!
#  从新文件中提取字符串的唯一方法就是使用'xgettext'程序. 
#  然而, xgettext程序存在许多bug. 

# 注意'xgettext'还有一个bug. 
#
# shell片断: 
#    gettext -s "I like Bash"
# 将会被正确的提取, 但是 . . .
#    xgettext -s "I like Bash"
# . . . 失败!
#  'xgettext'将会提取"-s"
#+ 因为这个命令仅仅会提取
#+ 'gettext'后边的第一个参数. 


#  转义字符:
#
#  为了本地化一个句子, 就像
#     echo -e "Hello\tworld!"
#+ 你必须使用
#     echo -e "`gettext \"Hello\\tworld\"`"
#  `t'前边的"双转义字符"是必须的, 
#+ 因为'gettext'将会搜索那些字符串(就像'Hello\tworld')
#  这是因为gettext将会读取一个字符`\')
#+ 并将输出一个字符串(就像"Bonjour\tmonde"), 
#+ 所以'echo'命令将会正确的显示消息. 
#
#  你可能不想使用
#     echo "`gettext -e \"Hello\tworld\"`"
#+ 因为我们上面解释的xgettext的bug. 



# 让我们本地化下面的shell片断:
#     echo "-h display help and exit"
#
# 首先, 可以用:
#     echo "`gettext \"-h display help and exit\"`"
#  这样'xgettext'工作正常, 
#+ 但是'gettext'程序将会把"-h"当作选项来读取! 
#
# 一个解决方法是
#     echo "`gettext -- \"-h display help and exit\"`"
#  这样'gettext'工作正常, 
#+ 但是'xgettext'将会提取"--", 就像上边那样. 
#
# 为了获得这个本地化的字符串, 你可能使用的变通方法就是: 
#     echo -e "`gettext \"\\0-h display help and exit\"`"
#  我们已经在这句的开头添加了\0 (NULL). 
#  这样'gettext'能够正确工作, 就像'xgettext'一样.
#  此外, NULL字符将不会修改
#+ 'echo'命令的行为. 
#  ------------------------------------------------------------------</programlisting>
      </para>


      <para>
      <screen><prompt>bash$ </prompt><userinput>bash -D localized.sh</userinput>
<computeroutput>"Can't cd to %s."
 "Enter the value: "</computeroutput></screen>

	  这将列出所有的本地化文本. 
	  (<option>-D</option>选项将会列出以<token>$</token>为前缀, 
	 并且使用双引号引用起来的字符串, 而不会执行这个脚本.)</para>

      <para>
      <screen><prompt>bash$ </prompt><userinput>bash --dump-po-strings localized.sh</userinput>
<computeroutput>#: a:6
 msgid "Can't cd to %s."
 msgstr ""
 #: a:7
 msgid "Enter the value: "
 msgstr ""</computeroutput></screen>
      
	  Bash的<option>--dump-po-strings</option>选项与<option>-D</option>选项很相似, 
	 但使用<link linkend="gettextref">gettext</link> <quote>po</quote>格式. 

      </para>

      <note>
      <para>Bruno Haible指出:</para>

	  <para>以gettext-0.12.2开始, <command>xgettext -o - 
		localized.sh</command>被推荐代替<command>bash --dump-po-strings
      localized.sh</command>, 因为<command>xgettext</command> . . .</para>
      
      <para>1. 了解命令gettext和eval_gettext(而bash --dump-po-strings只认识它的$"..."语法)</para>

      <para>2. 可以提取程序中的注释, 进而可以被翻译者读取. </para>

      <para>这个脚本将不再被特定于Bash,  它与Bash 1.x和其他的/bin/sh实现, 都使用相同的方式工作. 
      </para>
      </note>


      <para>现在, 为每种脚本需要被转换的语言都建立一个<filename>language.po</filename>文件, 
		  指定<replaceable>msgstr</replaceable>. 
		  Alfredo Pironti给出了下面的例子: </para>

      <para>fr.po:

      <programlisting>#: a:6
msgid "Can't cd to $var."
msgstr "Impossible de se positionner dans le repertoire $var."
#: a:7
msgid "Enter the value: "
msgstr "Entrez la valeur : "

#  这个字符串和变量名被打印, 没有%s语法, 
#+ 与C程序很像. 
#+ 如果程序员使用有意义的变量名, 
#+ 那么这将会是一个非常酷的特点!</programlisting>
      </para>

      <para>然后, 运行<link linkend="msgfmtref">msgfmt</link>.</para>
      <para><userinput>msgfmt -o localized.sh.mo fr.po</userinput></para>

	  <para>将文件<filename>localized.sh.mo</filename>的结果放到<filename 
	class="directory">/usr/local/share/locale/fr/LC_MESSAGES</filename>目录下, 
       并且在脚本的开头插入如下行: 

	  <programlisting>TEXTDOMAINDIR=/usr/local/share/locale
TEXTDOMAIN=localized.sh</programlisting>
      </para>

      <para>如果法文系统上的用户运行这个脚本, 那么她将得到法文消息. </para>

      <note>
		  <para>在老本的Bash或其他shell中, 
			  本地化需要使用<option>-s</option>选项的命令<link linkend="gettextref">gettext</link>. 
	在这种情况下, 脚本为:</para>

      <para><anchor id="gettextexample">
      <programlisting>#!/bin/bash
# localized.sh

E_CDERROR=65

error() {
  local format=$1
  shift
  printf "$(gettext -s "$format")" "$@" >&2
  exit $E_CDERROR
}
cd $var || error "Can't cd to %s." "$var"
read -p "$(gettext -s "Enter the value: ")" var
# ...</programlisting>
      </para>
      </note>

	  <para>变量<varname>TEXTDOMAIN</varname>和<varname>TEXTDOMAINDIR</varname>需要被设置, 
		 并且需要export到环境变量中. 
	这应该在脚本中完成. </para>

      <para>---</para>

      <para>此附录由Stephane Chazelas编写,
	Alfredo Pironti, 和Bruno Haible给出了一些建议, 是GNU<link
	linkend="gettextref">gettext</link>的维护者. </para>

  </appendix>
    <!-- Localization -->



  <appendix id="histcommands">
      <title>历史命令</title>

	  <para>Bash shell提供命令行工具用于编辑和操作用户的<emphasis>命令历史</emphasis>. 
		  这其实主要就是为了方便, 节省用户的重复按键. </para>

     <para>Bash历史命令: 
       <orderedlist>
         <listitem><para><command>history</command></para></listitem>
         <listitem><para><command>fc</command></para></listitem>
       </orderedlist>
     </para>  

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>history</userinput>
<computeroutput>   1  mount /mnt/cdrom
    2  cd /mnt/cdrom
    3  ls
     ...</computeroutput>
	      </screen>
	    </para>

     <para>与Bash历史命令相关的内部变量: 
       <orderedlist>
         <listitem><para>$HISTCMD</para></listitem>
         <listitem><para>$HISTCONTROL</para></listitem>
         <listitem><para>$HISTIGNORE</para></listitem>
         <listitem><para>$HISTFILE</para></listitem>
         <listitem><para>$HISTFILESIZE</para></listitem>
         <listitem><para>$HISTSIZE</para></listitem>
         <listitem><para>$HISTTIMEFORMAT (Bash 3.0或后续版本)</para></listitem>
         <listitem><para>!!</para></listitem>
         <listitem><para>!$</para></listitem>
         <listitem><para>!#</para></listitem>
         <listitem><para>!N</para></listitem>
         <listitem><para>!-N</para></listitem>
         <listitem><para>!STRING</para></listitem>
         <listitem><para>!?STRING?</para></listitem>
         <listitem><para>^STRING^string^</para></listitem>
       </orderedlist>
     </para>  

     <para>不幸的是, Bash历史工具在脚本中没用. 
        <programlisting>#!/bin/bash
# history.sh
# 尝试在脚本中使用'history'命令. 

history

# 脚本没产生输出. 
# 历史命令不能工作在脚本中. </programlisting>
     </para>

	  <para>
	      <screen><prompt>bash$ </prompt><userinput>./history.sh</userinput>
<computeroutput>(no output)</computeroutput>	      
	      </screen>
	  </para>

     <para>站点<ulink url="http://www.deadman.org/bash.html">Advancing in the
       Bash Shell</ulink>给出了一份关于如何在Bash中使用历史命令的详细介绍. 
       </para>



  </appendix>
    <!-- History Commands -->


  <appendix id="sample-bashrc">
      <title>一个简单的<filename>.bashrc</filename>文件</title>

     <para><filename>~/.bashrc</filename>文件决定了交互shell的行为. 
       好好的了解这个文件, 将会使你更加了解Bash. </para>

      <para><ulink url="mailto:emmanuel.rouat@wanadoo.fr">Emmanuel
	  Rouat</ulink>捐献了下边这个注释非常详细的<filename>.bashrc</filename>文件, 
		  这个文件是为Linux系统编写的. 
        他希望读者能够给他一些回馈. </para>
       
	<para>仔细的学习这个文件, 直到你可以自由重用其中的代码片断和函数, 
		并把它们用到你自己的<filename>.bashrc</filename>文件中, 
	   甚至可以放到你的脚本中. </para>


      <example id="bashrc">
	<title><filename>.bashrc</filename>文件样本</title>
	<programlisting>&bashrc;</programlisting>
      </example>

  </appendix>
    <!-- End Sample .bashrc File appendix -->


  <appendix id="dosbatch">
      <title>将DOS批处理文件转换为Shell脚本</title>

  <para><anchor id="dosbatch1"></para>
  <para>相当多的在PC上学习脚本的程序员都在运行DOS. 
    事实上, 残废的DOS批处理文件语言还是可以编写出一些比较强大的脚本来的, 
    虽然它们一般都需要借助于外部的工具. 
    所以说, 某些时候, 我们还是需要将老式的DOS批处理文件转换为UNIX shell脚本. 
	一般来说, 做这种事情并不困难, 
	因为DOS批处理文件操作不过是等价的shell脚本的一个受限子集. 
    </para>

      <table>
	<title>批处理文件关键字 / 变量 / 操作符, 和等价的shell符号</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>批处理文件操作符</entry>
	      <entry>Shell脚本等价符号</entry>
	      <entry>含义</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>%</option></entry>
	      <entry>$</entry>
	      <entry>命令行参数前缀</entry>
	    </row>
	    <row>
	      <entry><option>/</option></entry>
	      <entry>-</entry>
	      <entry>命令选项标记</entry>
	    </row>
	    <row>
	      <entry><option>\</option></entry>
	      <entry>/</entry>
	      <entry>目录路径分隔符</entry>
	    </row>
	    <row>
	      <entry><option>==</option></entry>
	      <entry>=</entry>
	      <entry>(等于)字符串比较测试</entry>
	    </row>
	    <row>
	      <entry><option>!==!</option></entry>
	      <entry>!=</entry>
	      <entry>(不等)字符串比较测试</entry>
	    </row>
	    <row>
	      <entry><option>|</option></entry>
	      <entry>|</entry>
	      <entry>管道</entry>
	    </row>
	    <row>
	      <entry><option>@</option></entry>
	      <entry>set <option>+v</option></entry>
	      <entry>不打印当前命令</entry>
	    </row>
	    <row>
	      <entry><option>*</option></entry>
	      <entry>*</entry>
	      <entry>文件名<quote>通配符</quote></entry>
	    </row>
	    <row>
	      <entry><option>&gt;</option></entry>
	      <entry>&gt;</entry>
	      <entry>文件重定向(覆盖)</entry>
	    </row>
	    <row>
	      <entry><option>&gt;&gt;</option></entry>
	      <entry>&gt;&gt;</entry>
	      <entry>文件重定向(附加)</entry>
	    </row>
	    <row>
	      <entry><option>&lt;</option></entry>
	      <entry>&lt;</entry>
	      <entry>重定向<filename>stdin</filename></entry>
	    </row>
	    <row>
	      <entry><option>%VAR%</option></entry>
	      <entry>$VAR</entry>
	      <entry>环境变量</entry>
	    </row>
	    <row>
	      <entry><option>REM</option></entry>
	      <entry>#</entry>
	      <entry>注释</entry>
	    </row>
	    <row>
	      <entry><option>NOT</option></entry>
	      <entry>!</entry>
	      <entry>取反</entry>
	    </row>
	    <row>
	      <entry><option>NUL</option></entry>
	      <entry><filename>/dev/null</filename></entry>
	      <entry><quote>黑洞</quote>用来阻止命令输出</entry>
	    </row>
	    <row>
	      <entry><option>ECHO</option></entry>
	      <entry>echo</entry>
	      <entry>打印(Bash中有更多选项)</entry>
	    </row>
	    <row>
	      <entry><option>ECHO.</option></entry>
	      <entry>echo</entry>
	      <entry>打印空行</entry>
	    </row>
	    <row>
	      <entry><option>ECHO OFF</option></entry>
	      <entry>set <option>+v</option></entry>
	      <entry>不打印后续的命令</entry>
	    </row>
	    <row>
	      <entry><option>FOR %%VAR IN (LIST) DO</option></entry>
	      <entry>for var in [list]; do</entry>
	      <entry><quote>for</quote>循环</entry>
	    </row>
	    <row>
	      <entry><option>:LABEL</option></entry>
	      <entry>没有等价物(多余)</entry>
	      <entry>标签</entry>
	    </row>
	    <row>
	      <entry><option>GOTO</option></entry>
	      <entry>没有等价物(使用函数)</entry>
	      <entry>跳转到脚本的另一个位置</entry>
	    </row>
	    <row>
	      <entry><option>PAUSE</option></entry>
	      <entry>sleep</entry>
	      <entry>暂停或等待一段时间</entry>
	    </row>
	    <row>
	      <entry><option>CHOICE</option></entry>
	      <entry>case or select</entry>
	      <entry>菜单选择</entry>
	    </row>
	    <row>
	      <entry><option>IF</option></entry>
	      <entry>if</entry>
	      <entry>if条件语句</entry>
	    </row>
	    <row>
	      <entry><option>IF EXIST <replaceable>FILENAME</replaceable></option></entry>
	      <entry>if [ -e filename ]</entry>
	      <entry>测试文件是否存在</entry>
	    </row>
	    <row>
	      <entry><option>IF !%N==!</option></entry>
	      <entry>if [ -z "$N" ]</entry>
	      <entry>参数<quote>N</quote>是否存在</entry>
	    </row>
	    <row>
	      <entry><option>CALL</option></entry>
	      <entry>source命令或.(点操作符)</entry>
	      <entry><quote>include</quote>另一个脚本</entry>
	    </row>
	    <row>
	      <entry><option>COMMAND /C</option></entry>
	      <entry>source命令或.(点操作符)</entry>
	      <entry><quote>include</quote>另一个脚本(与CALL相同)</entry>
	    </row>
	    <row>
	      <entry><option>SET</option></entry>
	      <entry>export</entry>
	      <entry>设置一个环境变量</entry>
	    </row>
	    <row>
	      <entry><option>SHIFT</option></entry>
	      <entry>shift</entry>
	      <entry>左移命令行参数列表</entry>
	    </row>
	    <row>
	      <entry><option>SGN</option></entry>
	      <entry>-lt或-gt</entry>
	      <entry>(整形)符号</entry>
	    </row>
	    <row>
	      <entry><option>ERRORLEVEL</option></entry>
	      <entry>$?</entry>
	      <entry>退出状态</entry>
	    </row>
	    <row>
	      <entry><option>CON</option></entry>
	      <entry><filename>stdin</filename></entry>
	      <entry><quote>控制台</quote>(<filename>stdin</filename>)</entry>
	    </row>
	    <row>
	      <entry><option>PRN</option></entry>
	      <entry><filename>/dev/lp0</filename></entry>
	      <entry>(一般的)打印设备</entry>
	    </row>
	    <row>
	      <entry><option>LPT1</option></entry>
	      <entry><filename>/dev/lp0</filename></entry>
	      <entry>第一个打印设备</entry>
	    </row>
	    <row>
	      <entry><option>COM1</option></entry>
	      <entry><filename>/dev/ttyS0</filename></entry>
	      <entry>第一个串口</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>



	  <para>批处理文件一般都包含DOS命令. 
		  我们必须把它转换为UNIX的等价命令, 
		  这样我们才能把批处理文件转换为shell脚本文件. 
	</para>

      <table>
	<title>DOS命令与UNIX的等价命令</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>DOS命令</entry>
	      <entry>UNIX等价命令</entry>
	      <entry>效果</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>ASSIGN</option></entry>
	      <entry>ln</entry>
	      <entry>链接文件或目录</entry>
	    </row>
	    <row>
	      <entry><option>ATTRIB</option></entry>
	      <entry>chmod</entry>
	      <entry>修改文件权限</entry>
	    </row>
	    <row>
	      <entry><option>CD</option></entry>
	      <entry>cd</entry>
	      <entry>更换目录</entry>
	    </row>
	    <row>
	      <entry><option>CHDIR</option></entry>
	      <entry>cd</entry>
	      <entry>更换目录</entry>
	    </row>
	    <row>
	      <entry><option>CLS</option></entry>
	      <entry>clear</entry>
	      <entry>清屏</entry>
	    </row>
	    <row>
	      <entry><option>COMP</option></entry>
	      <entry>diff, comm, cmp</entry>
	      <entry>文件比较</entry>
	    </row>
	    <row>
	      <entry><option>COPY</option></entry>
	      <entry>cp</entry>
	      <entry>文件拷贝</entry>
	    </row>
	    <row>
	      <entry><option>Ctl-C</option></entry>
	      <entry>Ctl-C</entry>
	      <entry>中断(信号)</entry>
	    </row>
	    <row>
	      <entry><option>Ctl-Z</option></entry>
	      <entry>Ctl-D</entry>
	      <entry>EOF(文件结束)</entry>
	    </row>
	    <row>
	      <entry><option>DEL</option></entry>
	      <entry>rm</entry>
	      <entry>删除文件</entry>
	    </row>
	    <row>
	      <entry><option>DELTREE</option></entry>
	      <entry>rm -rf</entry>
	      <entry>递归删除目录</entry>
	    </row>
	    <row>
	      <entry><option>DIR</option></entry>
	      <entry>ls -l</entry>
	      <entry>列出目录内容</entry>
	    </row>
	    <row>
	      <entry><option>ERASE</option></entry>
	      <entry>rm</entry>
	      <entry>删除文件</entry>
	    </row>
	    <row>
	      <entry><option>EXIT</option></entry>
	      <entry>exit</entry>
	      <entry>退出当前进程</entry>
	    </row>
	    <row>
	      <entry><option>FC</option></entry>
	      <entry>comm, cmp</entry>
	      <entry>文件比较</entry>
	    </row>
	    <row>
	      <entry><option>FIND</option></entry>
	      <entry>grep</entry>
	      <entry>在文件中查找字符串</entry>
	    </row>
	    <row>
	      <entry><option>MD</option></entry>
	      <entry>mkdir</entry>
	      <entry>新建目录</entry>
	    </row>
	    <row>
	      <entry><option>MKDIR</option></entry>
	      <entry>mkdir</entry>
	      <entry>新建目录</entry>
	    </row>
	    <row>
	      <entry><option>MORE</option></entry>
	      <entry>more</entry>
	      <entry>分页显示文本文件</entry>
	    </row>
	    <row>
	      <entry><option>MOVE</option></entry>
	      <entry>mv</entry>
	      <entry>移动文件</entry>
	    </row>
	    <row>
	      <entry><option>PATH</option></entry>
	      <entry>$PATH</entry>
	      <entry>可执行文件的路径</entry>
	    </row>
	    <row>
	      <entry><option>REN</option></entry>
	      <entry>mv</entry>
	      <entry>重命名(移动)</entry>
	    </row>
	    <row>
	      <entry><option>RENAME</option></entry>
	      <entry>mv</entry>
	      <entry>重命名(移动)</entry>
	    </row>
	    <row>
	      <entry><option>RD</option></entry>
	      <entry>rmdir</entry>
	      <entry>删除目录</entry>
	    </row>
	    <row>
	      <entry><option>RMDIR</option></entry>
	      <entry>rmdir</entry>
	      <entry>删除目录</entry>
	    </row>
	    <row>
	      <entry><option>SORT</option></entry>
	      <entry>sort</entry>
	      <entry>排序文件</entry>
	    </row>
	    <row>
	      <entry><option>TIME</option></entry>
	      <entry>date</entry>
	      <entry>显示系统时间</entry>
	    </row>
	    <row>
	      <entry><option>TYPE</option></entry>
	      <entry>cat</entry>
	      <entry>将文件输出到<filename>stdout</filename></entry>
	    </row>
	    <row>
	      <entry><option>XCOPY</option></entry>
	      <entry>cp</entry>
	      <entry>(扩展的)文件拷贝</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>	


      <note>
		  <para>事实上, 几乎所有的UNIX和shell操作符, 
			  还有命令都有许多的选项, 
			  对比DOS和批处理文件来说, 它们要强大的多. 
	许多DOS批处理文件都需要依靠辅助工具, 
	比如<command>ask.com</command>, 这是一个比<link linkend="readref">read</link>命令差很多的类似副本. </para>

		<para>DOS对于文件名<link 
		linkend="globbingref">通配符扩展</link>支持的非常有限, 
		并且很不完整, 
	仅仅识别<token>*</token>和<token>?</token>. 
	</para>
	</note>

      <para>将DOS批处理文件转换为sehll脚本, 通常是一件很简单的事情, 
	而且转换的结果通常都比原始的批处理文件好. 
	</para>

      <example id="VIEWDAT">
	<title>VIEWDATA.BAT: DOS批处理文件</title>
	<programlisting>&VIEWDAT;</programlisting>
      </example>

      <para>转换脚本作了一些改进. </para>

      <example id="viewdata">
	<title>viewdata.sh: 转换自VIEWDATA.BAT的shell脚本</title>
	<programlisting>&viewdata;</programlisting>
      </example>


      <para>Ted Davis的<ulink url="http://www.maem.umr.edu/~batch/">Shell
	Scripts on the PC</ulink>站点上有许多关于老式的批处理文件编程的教程, 
	他使用的某些独创性的技术, 和shell脚本有异曲同工之妙. 
	</para>

      
  </appendix>
    <!-- End DOS Batch File Conversion appendix -->


  <appendix id="exercises">
    <title>练习</title>

    <sect1 id="scriptanalysis">
      <title>分析脚本</title>

      <para>检查下面的脚本. 运行它, 然后解释一下这个脚本是做什么用的. 
        注释这个脚本, 并以更紧凑和更优雅的形式重写它. 
        </para>
	
       <para>
       <programlisting>#!/bin/bash

MAX=10000


  for((nr=1; nr<$MAX; nr++))
  do

    let "t1 = nr % 5"
    if [ "$t1" -ne 3 ]
    then
      continue
    fi

    let "t2 = nr % 7"
    if [ "$t2" -ne 4 ]
    then
      continue
    fi

    let "t3 = nr % 9"
    if [ "$t3" -ne 5 ]
    then
      continue
    fi

  break   # 当你注释掉这行, 会发生什么? 为什么? 

  done

  echo "Number = $nr"


exit 0</programlisting>
       </para>

      <para>---</para>

      <para>解释一下下面脚本的作用. 事实上它只是一个参数化的命令行管道. </para>

      <para>
        <programlisting>#!/bin/bash

DIRNAME=/usr/bin
FILETYPE="shell script"
LOGFILE=logfile

file "$DIRNAME"/* | fgrep "$FILETYPE" | tee $LOGFILE | wc -l

exit 0</programlisting>
      </para>

      <para>---</para>

      <para>一个读者发来了如下的代码片断. 

         <programlisting>while read LINE
do
  echo $LINE
done < `tail -f /var/log/messages`</programlisting>

		他希望编写一个脚本, 
		用来跟踪系统日志文件(<filename>/var/log/messages</filename>)的更新情况.
	    不幸的是, 上面的这段代码会被挂起, 并且不会做任何有意义的事情. 为什么? 
	    修复它, 让这个脚本如期望般的运行. (小提示: 
		不要<link linkend="redirref">重定向循环的<filename>stdin</filename></link>, 
		试试<link linkend="piperef">管道</link>. )</para>


      <para>---</para>


      <para>分析<xref linkend="lifeslow">, 然后简化它, 使其逻辑性更好. 
	看看可以省掉多少个变量, 尝试优化这个脚本, 并提高这个脚本的运行速度. 
	</para>

      <para>修改这个脚本, 让它可以接受任意的ASCII文本文件作为输入, 用于它初始的"产生". 
	这个脚本将读取最初的<varname>$ROW*$COL</varname>字符, 
	并且设置元音的出现次数作为<quote>活的</quote>细胞.  
	提示: 必须保证将输入文件中的空格转换为下划线. 
	</para>

    </sect1>
    <!-- End Analyzing Scripts section -->



    <sect1 id="writingscripts">
      <title>编写脚本</title>

      <para><anchor id="writingscripts1"></para>

      <para>编写脚本来完成下面列出的每项任务. </para>

      <para>译者: 家庭作业, 就不译了. </para>

      <variablelist id="exeasy">
        <title><anchor id="exeasy1">EASY</title>

	  <varlistentry>
	    <term><command>Home Directory Listing</command></term>
	    <listitem>
	    <para>Perform a recursive directory listing on the user's home
	      directory and save the information to a file. Compress
	      the file, have the script prompt the user to insert
	      a floppy, then press <keycap>ENTER</keycap>. Finally,
	      save the file to the floppy.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Converting  <link linkend="forloopref1">for</link>
	    loops to <link linkend="whileloopref">while</link> and <link
	    linkend="untilloopref">until</link> loops</command></term>
	    <listitem>
	    <para>Convert the <emphasis>for loops</emphasis> in <xref
	      linkend="ex22"> to <emphasis>while
	      loops</emphasis>. Hint: store the data in an <link
	      linkend="arrayref">array</link> and step through the array
	      elements.</para>
	    <para>Having already done the <quote>heavy lifting</quote>,
	      now convert the loops in the example to <emphasis> until
	      loops</emphasis>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Changing the line spacing of a text file</command></term>
	    <listitem>

	    <para>Write a script that reads each line of a target file, then
	      writes the line back to <filename>stdout</filename>, but with
	      an extra blank line following. This has the effect of
	      <emphasis>double-spacing</emphasis> the file.</para>

	    <para>Include all necessary code to check whether the script
	      gets the necessary command line argument (a filename),
	      and whether the specified file exists.</para>

	    <para>When the script runs correctly, modify it to
	      <emphasis>triple-space</emphasis> the target file.</para>

	    <para>Finally, write a script to remove all blank lines from
	      the target file, <emphasis>single-spacing</emphasis> it.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Backwards Listing</command></term>
	    <listitem>
	    <para>Write a script that echoes itself to
	      <filename>stdout</filename>, but
	      <emphasis>backwards</emphasis>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Automatically Decompressing Files</command></term>
	    <listitem>
	    <para>Given a list of filenames as input, this script
	      queries each target file (parsing the output of the
	      <link linkend="fileref">file</link> command) for
	      the type of compression used on it. Then the script
	      automatically invokes the appropriate decompression command
	      (<command>gunzip</command>, <command>bunzip2</command>,
	      <command>unzip</command>, <command>uncompress</command>,
	      or whatever). If a target file is not compressed, the
	      script emits a warning message, but takes no other action
	      on that particular file.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Unique System ID</command></term>
	    <listitem>
	    <para>Generate a <quote>unique</quote> 6-digit hexadecimal
	      identifier for your computer. Do <emphasis>not</emphasis>
	      use the flawed <link linkend="hostidref">hostid</link>
	      command. Hint: <command><link
	      linkend="md5sumref">md5sum</link>
	      <filename>/etc/passwd</filename></command>, then select
	      the first 6 digits of output.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Backup</command></term>
	    <listitem>
	    <para>Archive as a <quote>tarball</quote>
	      (<filename>*.tar.gz</filename> file) all the files
	      in your home directory tree
	      (<filename>/home/your-name</filename>) that have
	      been modified in the last 24 hours. Hint: use <link
	      linkend="findref">find</link>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Checking whether a process is still running</command></term>
	    <listitem>
	    <para>Given a <link linkend="processidref">process ID</link>
	      (<firstterm>PID</firstterm>) as an argument, this script
	      will check, at user-specified intervals, whether
	      the given process is still running. You may use
	      the <link linkend="ppssref">ps</link> and <link
	      linkend="sleepref">sleep</link> commands.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Primes</command></term>
	    <listitem>
	    <para>Print (to stdout) all prime numbers between 60000 and
	      63000. The output should be nicely formatted in columns
	      (hint: use <link linkend="printfref">printf</link>).</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Lottery Numbers</command></term>
	    <listitem>
	    <para>One type of lottery involves picking five
	      different numbers, in the range of 1 - 50. Write a
	      script that generates five pseudorandom numbers in this
	      range, <emphasis>with no duplicates</emphasis>. The
	      script will give the option of echoing the numbers to
	      <filename>stdout</filename> or saving them to a file,
	      along with the date and time the particular number set
	      was generated.</para>
	    </listitem>
	  </varlistentry>

      </variablelist>


      <variablelist id="exmedium">
        <title><anchor id="exmedium1">INTERMEDIATE</title>

	  <varlistentry>
	    <term><command>Integer or String</command></term>
	    <listitem>
	    <para>Write a script <link linkend="functionref">function</link>
	      that determines if an argument passed to it is an integer
	      or a string. The function will return TRUE (0) if
	      passed an integer, and FALSE (1) if passed a string.</para>
            <para>Hint: What does the following expression return
	      when <varname>$1</varname> is <emphasis>not</emphasis> an
	      integer?</para>
            <para><varname>expr $1 + 0</varname></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Managing Disk Space</command></term>
	    <listitem>
	    <para>List, one at a time, all files larger than 100K in
	      the <filename class="directory">/home/username</filename>
	      directory tree. Give the user the option to delete or
	      compress the file, then proceed to show the next one. Write
	      to a logfile the names of all deleted files and the
	      deletion times.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Removing Inactive Accounts</command></term>
	    <listitem>
	    <para>Inactive accounts on a network waste disk space and may
	      become a security risk. Write an administrative script
	      (to be invoked by <emphasis>root</emphasis> or the <link
	      linkend="cronref">cron daemon</link>) that checks
	      for and deletes user accounts that have not been accessed
	      within the last 90 days.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Enforcing Disk Quotas</command></term>
	    <listitem>
	    <para>Write a script for a multi-user system that checks users'
	      disk usage. If a user surpasses the preset limit
	      (100 MB, for example) in her <filename
	      class="directory">/home/username</filename> directory,
	      then the script will automatically send her a warning
	      e-mail.</para>
            <para>The script will use the <link linkend="duref">du</link> and
	      <link linkend="commmail1">mail</link> commands. As an option,
	      it will allow setting and enforcing quotas using the <link
	      linkend="quotaref">quota</link> and <link
	      linkend="setquotaref">setquota</link> commands.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Logged in User Information</command></term>
	    <listitem>

	    <para>For all logged in users, show their real names and the time
              and date of their last login.</para>
	      
	    <para>Hint: use <link linkend="whoref">who</link>,
	      <link linkend="lastlogref">lastlog</link>,
	      and parse <filename>/etc/passwd</filename>.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Safe Delete</command></term>
	    <listitem>
	    <para>Write, as a script, a <quote>safe</quote> delete
	      command, <filename>srm.sh</filename>. Filenames passed
	      as command-line arguments to this script are not deleted,
	      but instead <link linkend="gzipref">gzipped</link> if not
	      already compressed (use <link linkend="fileref">file</link>
	      to check), then moved to a <filename
	      class="directory">/home/username/trash</filename>
	      directory. At invocation, the script checks the
	      <quote>trash</quote> directory for files older than 48
	      hours and deletes them.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Making Change</command></term>
	    <listitem>
	    <para>What is the most efficient way to make change for $1.68,
	      using only coins in common circulations (up to 25c)? It's
	      6 quarters, 1 dime, a nickel, and three cents.</para>
            <para>Given any arbitrary command line input in dollars and
	      cents ($*.??), calculate the change, using the minimum
	      number of coins. If your home country is not the United
	      States, you may use your local currency units instead. The
	      script will need to parse the command line input, then
	      change it to multiples of the smallest monetary unit (cents
	      or whatever). Hint: look at <xref linkend="ex61">.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Quadratic Equations</command></term>
	    <listitem>
	    <para>Solve a <quote>quadratic</quote> equation of the form
	      <emphasis>Ax^2 + Bx + C = 0</emphasis>. Have a script take
	      as arguments the coefficients, <userinput>A</userinput>,
	      <userinput>B</userinput>, and <userinput>C</userinput>,
	      and return the solutions to four decimal places.</para>

	    <para>Hint: pipe the coefficients to <link
	      linkend="bcref">bc</link>, using the well-known formula,
	      <emphasis>x = ( -B +/- sqrt( B^2 - 4AC ) ) / 2A</emphasis>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Sum of Matching Numbers</command></term>
	    <listitem>
	    <para>Find the sum of all five-digit numbers (in the range
	      10000 - 99999) containing <emphasis>exactly two</emphasis>
	      out of the following set of digits: { 4, 5, 6 }. These may
	      repeat within the same number, and if so, they count once
	      for each occurrence.</para>
	    <para>Some examples of matching numbers are
	      42057, 74638, and 89515.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Lucky Numbers</command></term>
	    <listitem>
	    <para>A "lucky number" is one whose individual digits add
	      up to 7, in successive additions. For example, 62431 is a
	      "lucky number" (6 + 2 + 4 + 3 + 1 = 16, 1 + 6 = 7). Find
	      all the "lucky numbers" between 1000 and 10000.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Alphabetizing a String</command></term>
	    <listitem>
	    <para>Alphabetize (in ASCII order) an arbitrary string
	      read from the command line.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Parsing</command></term>
	    <listitem>
	    <para>Parse <filename>/etc/passwd</filename>, and output
	      its contents in nice, easy-to-read tabular form.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Logging Logins</command></term>
	    <listitem>
	    <para>Parse <filename>/var/log/messages</filename> to
	      produce a nicely formatted file of user logins and login
	      times. The script may need to run as root. (Hint: Search
	      for the string <quote>LOGIN.</quote>)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Pretty-Printing a Data File</command></term>
	    <listitem>
	    <para>Certain database and spreadsheet packages use save-files
	      with <emphasis>comma-separated values</emphasis>
	      (CSVs). Other applications often need to parse these
	      files.</para>
	    <para>Given a data file with comma-separated fields,
	      of the form:
	        <programlisting>Jones,Bill,235 S. Williams St.,Denver,CO,80221,(303) 244-7989
Smith,Tom,404 Polk Ave.,Los Angeles,CA,90003,(213) 879-5612
...</programlisting>
	      Reformat the data and print it out to
	      <filename>stdout</filename> in labeled, evenly-spaced columns.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Justification</command></term>
	    <listitem>
	    <para>Given ASCII text input either from
	      <filename>stdin</filename> or a file, adjust
	      the word spacing to right-justify each line to a
	      user-specified line-width, then send the output to
	      <filename>stdout</filename>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Mailing List</command></term>
	    <listitem>
	    <para>Using the <link linkend="commmail1">mail</link> command,
	      write a script that manages a simple mailing list. The
	      script automatically e-mails the monthly company newsletter,
	      read from a specified text file, and sends it to all the
	      addresses on the mailing list, which the script reads from
	      another specified file.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Generating Passwords</command></term>
	    <listitem>
	    <para>Generate pseudorandom 8-character passwords, using
	      characters in the ranges [0-9], [A-Z], [a-z]. Each password
	      must contain at least two digits.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Checking for Broken Links</command></term>
	    <listitem>
	    <para>Using <link linkend="lynxref">lynx</link> with the
	      <option>-traversal</option> option, write a script that
	      checks a Web site for broken links.</para>
	    </listitem>
	  </varlistentry>

      </variablelist>


      <variablelist id="exdifficult">
        <title><anchor id="exdifficult1">DIFFICULT</title>

	  <varlistentry>
	    <term><command>Testing Passwords</command></term>
	    <listitem>
	    <para>Write a script to check and validate passwords. The object
	      is to flag <quote>weak</quote> or easily guessed password
	      candidates.</para>

	    <para>A trial password will be input to the script as a
	       command line parameter. To be considered acceptable,
	       a password must meet the following minimum qualifications:

            <itemizedlist>
	      <listitem>
	        <para>Minimum length of 8 characters</para>
	      </listitem>

	      <listitem>
	        <para>Must contain at least one numeric character</para>
	      </listitem>

	      <listitem>
	        <para>Must contain at least one of the following
		  non-alphabetic characters: <token>@</token>,
		  <token>#</token>, <token>$</token>, <token>%</token>,
		  <token>&</token>, <token>*</token>, <token>+</token>,
		  <token>-</token>, <token>=</token></para>
	      </listitem>
            </itemizedlist></para>

	     <para>Optional:

            <itemizedlist>
	      <listitem>
	        <para>Do a dictionary check on every sequence of at least
		  four consecutive alphabetic characters in the password under
		  test. This will eliminate passwords containing embedded
		  <quote>words</quote> found in a standard dictionary.</para>
	      </listitem>

	      <listitem>
	        <para>Enable the script to check all the passwords on your
		  system. These may or may not reside in
		  <filename>/etc/passwd</filename>.</para>
	      </listitem>
            </itemizedlist></para>

	     <para>This exercise tests mastery of <link
	       linkend="regexref">Regular Expressions</link>.</para>

	    </listitem>
	  </varlistentry>


	  <varlistentry>
	    <term><command>Logging File Accesses</command></term>
	    <listitem>
	    <para>Log all accesses to the files in <filename
	      class="directory">/etc</filename> during the course of
	      a single day. This information should include the filename,
	      user name, and access time. If any alterations to the
	      files take place, that should be flagged. Write this data
	      as neatly formatted records in a logfile.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Monitoring Processes</command></term>
	    <listitem>
	    <para>Write a script to continually monitor all running
	      processes and to keep track of how many child processes each
	      parent spawns. If a process spawns more than five children,
	      then the script sends an e-mail to the system administrator
	      (or root) with all relevant information, including the
	      time, PID of the parent, PIDs of the children, etc. The
	      script writes a report to a log file every ten minutes.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Strip Comments</command></term>
	    <listitem>
	    <para>Strip all comments from a shell script whose name
	      is specified on the command line. Note that the <quote>#!
	      line</quote> must not be stripped out.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>HTML Conversion</command></term>
	    <listitem>
	    <para>Convert a given text file to HTML. This non-interactive
	      script automatically inserts all appropriate HTML tags into
	      a file specified as an argument.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Strip HTML Tags</command></term>
	    <listitem>
	    <para>Strip all HTML tags from a specified HTML file, then
	      reformat it into lines between 60 and 75 characters
	      in length.  Reset paragraph and block spacing, as
	      appropriate, and convert HTML tables to their approximate
	      text equivalent.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>XML Conversion</command></term>
	    <listitem>
	    <para>Convert an XML file to both HTML and text format.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><anchor id="cspammers"><command>Chasing Spammers</command></term>
	    <listitem>

	    <para> Write a script that analyzes a spam e-mail by doing
	      DNS lookups on the IP addresses in the headers to identify
	      the relay hosts as well as the originating ISP. The
	      script will forward the unaltered spam message to the
	      responsible ISPs. Of course, it will be necessary to
	      filter out <emphasis>your own ISP's IP address</emphasis>,
	      so you don't end up complaining about yourself.</para>

            <para>As necessary, use the appropriate <link
              linkend="communinfo1">network analysis commands</link>.</para>

            <para>For some ideas, see <xref linkend="isspammer"> and <xref
	      linkend="isspammer2">.</para>

            <para>Optional: Write a script that searches through a batch of
	      e-mail messages and deletes the spam according to specified
	      filters.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Creating man pages</command></term>
	    <listitem>

	    <para>Write a script that automates the process of creating
	      <emphasis>man pages</emphasis>.</para>

            <para>Given a text file which contains information to be
	      formatted into a <emphasis>man page</emphasis>, the
	      script will read the file, then invoke the appropriate
	      <link linkend="groffref">groff</link> commands to
	      output the corresponding <emphasis>man page</emphasis>
	      to <filename>stdout</filename>. The text file contains
	      blocks of information under the standard <emphasis>man
	      page</emphasis> headings, i.e., <quote>NAME,</quote>
	      <quote>SYNOPSIS,</quote> <quote>DESCRIPTION,</quote>
	      etc.</para>

            <para>See <xref linkend="manview">.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Morse Code</command></term>
	    <listitem>
	    <para>Convert a text file to Morse code. Each character of the
	      text file will be represented as a corresponding Morse
	      code group of dots and dashes (underscores), separated by
	      whitespace from the next. For example, <quote>script</quote>
	      ===&gt; <quote>... _._. ._. .. .__. _</quote>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Hex Dump</command></term>
	    <listitem>
	    <para>Do a hex(adecimal) dump on a binary file
	      specified as an argument. The output should be in neat
	      tabular fields, with the first field showing the address,
	      each of the next 8 fields a 4-byte hex number, and the final
	      field the ASCII equivalent of the previous 8 fields.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Emulating a Shift Register</command></term>
	    <listitem>
	    <para>Using <xref linkend="stackex"> as an inspiration,
	      write a script that emulates a 64-bit shift register as
	      an <link linkend="arrayref">array</link>.  Implement
	      functions to <emphasis>load</emphasis> the register,
	      <emphasis>shift left</emphasis>, <emphasis>shift
	      right</emphasis>, and <emphasis>rotate</emphasis>
	      it. Finally, write a function that interprets the register
	      contents as eight 8-bit ASCII characters.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Determinant</command></term>
	    <listitem>
	    <para>Solve a 4 x 4 determinant.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Hidden Words</command></term>
	    <listitem>
	    <para>Write a <quote>word-find</quote> puzzle generator,
	      a script that hides 10 input words in a 10 x 10 matrix
	      of random letters. The words may be hidden across, down,
	      or diagonally.</para>
            <para>Optional: Write a script that <emphasis>solves</emphasis>
	      word-find puzzles. To keep this from becoming too difficult,
	      the solution script will find only horizontal and vertical
	      words. (Hint: Treat each row and column as a string, and
	      search for substrings.)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Anagramming</command></term>
	    <listitem>
	    <para> Anagram 4-letter input. For example, the
	      anagrams of <emphasis>word</emphasis> are:
	      <emphasis>do or rod row word</emphasis>. You may use
	      <filename>/usr/share/dict/linux.words</filename> as the
	      reference list.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><quote><command>Word Ladders</command></quote></term>
	    <listitem>
            <para>A <quote>word ladder</quote> is a sequence of words,
              with each successive word in the sequence differing from
              the previous one by a single letter.</para>

            <para>For example, to <quote>ladder</quote> from
              <emphasis>mark</emphasis> to
              <emphasis>vase</emphasis>:</para>

            <para>
	    <programlisting>mark --> park --> part --> past --> vast --> vase</programlisting>
            </para>

            <para>Write a script that solves <quote>word ladder</quote>
              puzzles. Given a starting and an ending word,
              the script will list all intermediate steps in the
              <quote>ladder</quote>. Note that <emphasis>all</emphasis>
              words in the sequence must be <quote>legal.</quote></para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Fog Index</command></term>
	    <listitem>

	    <para>The <quote>fog index</quote> of a passage of text
	      estimates its reading difficulty, as a number corresponding
	      roughly to a school grade level. For example, a passage
	      with a fog index of 12 should be comprehensible to anyone
	      with 12 years of schooling.</para>

	    <para>The Gunning version of the fog index uses the following
	      algorithm.</para>

             <orderedlist>

               <listitem><para>Choose a section of the text at least
                 100 words in length.</para></listitem>

               <listitem><para>Count the number of sentences (a portion of
                 a sentence truncated by the boundary of the text section
                 counts as one).</para></listitem>

               <listitem>
	         <para>Find the average number of words per
                   sentence.</para>
		   
		 <para>AVE_WDS_SEN = TOTAL_WORDS / SENTENCES</para>
               </listitem>

               <listitem>
		 <para>Count the number of <quote>difficult</quote>
		   words in the segment -- those containing at least
		   3 syllables. Divide this quantity by total words to
		   get the proportion of difficult words.</para>

                 <para>PRO_DIFF_WORDS = LONG_WORDS / TOTAL_WORDS</para>
               </listitem>

               <listitem>
                 <para>The Gunning fog index is the sum of the above two
                   quantities, multiplied by 0.4, then rounded to the
                   nearest integer.</para>

                 <para>G_FOG_INDEX = int ( 0.4 * ( AVE_WDS_SEN  + PRO_DIFF_WORDS ) )</para>
               </listitem>

             </orderedlist>

            <para>Step 4 is by far the most difficult portion of the
	      exercise. There exist various algorithms for estimating
	      the syllable count of a word. A rule-of-thumb formula
	      might consider the number of letters in a word and the
	      vowel-consonant mix.</para>
	      
	    <para>A strict interpretation of the Gunning fog index does
	      not count compound words and proper nouns as
	      <quote>difficult</quote> words, but this would enormously
	      complicate the script.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Calculating PI using Buffon's Needle</command></term>
	    <listitem>

            <para>The Eighteenth Century French mathematician de Buffon
	      came up with a novel experiment. Repeatedly drop a
	      needle of length <quote>n</quote> onto a wooden floor
	      composed of long and narrow parallel boards. The cracks
	      separating the equal-width floorboards are a fixed distance
	      <quote>d</quote> apart. Keep track of the total drops and
	      the number of times the needle intersects a crack on the
	      floor. The ratio of these two quantities turns out to be
	      a fractional multiple of PI.</para>

            <para>In the spirit of <xref linkend="cannon">, write a
              script that runs a Monte Carlo simulation of Buffon's
              Needle. To simplify matters, set the needle length equal to
	      the distance between the cracks, <emphasis>n = d</emphasis>.</para>

            <para>Hint: there are actually two critical variables:
              the distance from the center of the needle to the crack
              nearest to it, and the angle of the needle to that
              crack. You may use <link linkend="bcref">bc</link> to
              handle the calculations.</para>

	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>Playfair Cipher</command></term>
	    <listitem>

	    <para>Implement the Playfair (Wheatstone) Cipher in a
	      script.</para>

	    <para>The Playfair Cipher encrypts text by substitution
	      of <quote>digrams</quote> (2-letter groupings).  It is
	      traditional to use a 5 x 5 letter scrambled-alphabet
	      <emphasis>key square</emphasis> for the encryption and
	      decryption.</para>

             <para>
	     <programlisting>   C O D E S
   A B F G H
   I K L M N
   P Q R T U
   V W X Y Z

Each letter of the alphabet appears once, except "I" also represents
"J". The arbitrarily chosen key word, "CODES" comes first, then all
the rest of the alphabet, in order from left to right, skipping letters
already used.

To encrypt, separate the plaintext message into digrams (2-letter
groups). If a group has two identical letters, delete the second, and
form a new group. If there is a single letter left over at the end,
insert a "null" character, typically an "X."

THIS IS A TOP SECRET MESSAGE

TH IS IS AT OP SE CR ET ME SA GE

For each digram, there are three possibilities.
----------------------------------------------
1) Both letters will be on the same row of the key square
   For each letter, substitute the one immediately to the right, in that
   row. If necessary, wrap around left to the beginning of the row.

or

2) Both letters will be in the same column of the key square
   For each letter, substitute the one immediately below it, in that
   row. If necessary, wrap around to the top of the column.

or

3) Both letters will form the corners of a rectangle within the key
   square. For each letter, substitute the one on the other corner the
   rectangle which lies on the same row.


The "TH" digram falls under case #3.
G H
M N
T U           (Rectangle with "T" and "H" at corners)

T --&gt; U
H --&gt; G


The "SE" digram falls under case #1.
C O D E S     (Row containing "S" and "E")

S --&gt; C  (wraps around left to beginning of row)
E --&gt; S

=========================================================================

To decrypt encrypted text, reverse the above procedure under cases #1
and #2 (move in opposite direction for substitution). Under case #3,
just take the remaining two corners of the rectangle.


Helen Fouche Gaines' classic work, ELEMENTARY CRYPTANALYSIS (1939), gives a
fairly detailed rundown on the Playfair Cipher and its solution methods.</programlisting>
             </para>

             <para>This script will have three main sections</para>

             <orderedlist id="playfairexref" numeration="upperroman">
	       <listitem><para>Generating the <quote>key square</quote>,
	         based on a user-input keyword.</para></listitem>
	       <listitem><para>Encrypting a <quote>plaintext</quote>
	         message.</para></listitem>
	       <listitem><para>Decrypting encrypted
	         text.</para></listitem>
             </orderedlist>

	     <para>The script will make extensive use of <link
	       linkend="arrayref">arrays</link> and <link
	       linkend="functionref">functions</link>.</para>

	    </listitem>
	  </varlistentry>

      </variablelist>


	  <para>--</para>
          <para>Please do not send the author your solutions to these
            exercises. There are better ways to impress him with your
            cleverness, such as submitting bugfixes and suggestions for
            improving this book.</para>


    </sect1>
    <!-- End Writing Scripts section -->

  </appendix>
    <!-- End Exercises appendix -->



  <appendix id="revisionhistory">
    <title>修订记录</title>

    <synopsis>
      这份文档起始于2000年春天的一份60页的HOWTO文档. 
      从那以后, 它经历数次升级与修订. 
      如果没有Linux社团的帮助, 那就不可能有这本书, 
      在这里尤其要感谢<ulink url="http://www.tldp.org">Linux Documentation Project</ulink>的志愿者们. 
    </synopsis>


      <table frame=none>
	<title>修订历史</title>
	<tgroup cols="3" colsep=0 rowsep=0>
	  <thead>
	    <row>
	      <entry>版本</entry>
	      <entry>日期</entry>
	      <entry>注释</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>0.1</entry>
	      <entry>14 Jun 2000</entry>
	      <entry>Initial release.</entry>
	    </row>
	    <row>
	      <entry><option>0.2</option></entry>
	      <entry>30 Oct 2000</entry>
	      <entry>Bugs fixed, plus much additional material and more
	      example scripts.</entry>
	    </row>
	    <row>
	      <entry><option>0.3</option></entry>
	      <entry>12 Feb 2001</entry>
	      <entry>Major update.</entry>
	    </row>
	    <row>
	      <entry><option>0.4</option></entry>
	      <entry>08 Jul 2001</entry>
	      <entry>Complete revision and expansion of the book.</entry>
	    </row>
	    <row>
	      <entry><option>0.5</option></entry>
	      <entry>03 Sep 2001</entry>
	      <entry>Major update: Bugfixes, material added,
	      sections reorganized.</entry>
	    </row>
	    <row>
	      <entry><option>1.0</option></entry>
	      <entry>14 Oct 2001</entry>
	      <entry>Stable release: Bugfixes, reorganization, material
	      added.</entry>
	    </row>
	    <row>
	      <entry><option>1.1</option></entry>
	      <entry>06 Jan 2002</entry>
	      <entry>Bugfixes, material and scripts added.</entry>
	    </row>
	    <row>
	      <entry><option>1.2</option></entry>
	      <entry>31 Mar 2002</entry>
	      <entry>Bugfixes, material and scripts added.</entry>
	    </row>
	    <row>
	      <entry><option>1.3</option></entry>
	      <entry>02 Jun 2002</entry>
	      <entry>TANGERINE release: A few bugfixes, much more material and
	      scripts added.</entry>
	    </row>
	    <row>
	      <entry><option>1.4</option></entry>
	      <entry>16 Jun 2002</entry>
	      <entry>MANGO release: A number of typos fixed, more
	      material and scripts.</entry>
	    </row>
	    <row>
	      <entry><option>1.5</option></entry>
	      <entry>13 Jul 2002</entry>
	      <entry>PAPAYA release: A few bugfixes, much more material and
	      scripts added.</entry>
	    </row>
	    <row>
	      <entry><option>1.6</option></entry>
	      <entry>29 Sep 2002</entry>
	      <entry>POMEGRANATE release: Bugfixes, more material,
	      one more script.</entry>
	    </row>
	    <row>
	      <entry><option>1.7</option></entry>
	      <entry>05 Jan 2003</entry>
	      <entry>COCONUT release: A couple of bugfixes, more material,
	      one more script.</entry>
	    </row>
	    <row>
	      <entry><option>1.8</option></entry>
	      <entry>10 May 2003</entry>
	      <entry>BREADFRUIT release: A number of bugfixes, more scripts and
	      material.</entry>
	    </row>
	    <row>
	      <entry><option>1.9</option></entry>
	      <entry>21 Jun 2003</entry>
	      <entry>PERSIMMON release: Bugfixes, and more material.</entry>
	    </row>
	    <row>
	      <entry><option>2.0</option></entry>
	      <entry>24 Aug 2003</entry>
	      <entry>GOOSEBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>2.1</option></entry>
	      <entry>14 Sep 2003</entry>
	      <entry>HUCKLEBERRY release: Bugfixes, and more material.</entry>
	    </row>
	    <row>
	      <entry><option>2.2</option></entry>
	      <entry>31 Oct 2003</entry>
	      <entry>CRANBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>2.3</option></entry>
	      <entry>03 Jan 2004</entry>
	      <entry>STRAWBERRY release: Bugfixes and more material.</entry>
	    </row>
	    <row>
	      <entry><option>2.4</option></entry>
	      <entry>25 Jan 2004</entry>
	      <entry>MUSKMELON release: Bugfixes.</entry>
	    </row>
	    <row>
	      <entry><option>2.5</option></entry>
	      <entry>15 Feb 2004</entry>
	      <entry>STARFRUIT release: Bugfixes and more material.</entry>
	    </row>
	    <row>
	      <entry><option>2.6</option></entry>
	      <entry>15 Mar 2004</entry>
	      <entry>SALAL release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>2.7</option></entry>
	      <entry>18 Apr 2004</entry>
	      <entry>MULBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>2.8</option></entry>
	      <entry>11 Jul 2004</entry>
	      <entry>ELDERBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>3.0</option></entry>
	      <entry>03 Oct 2004</entry>
	      <entry>LOGANBERRY release: Major update.</entry>
	    </row>
	    <row>
	      <entry><option>3.1</option></entry>
	      <entry>14 Nov 2004</entry>
	      <entry>BAYBERRY release: Bugfix update.</entry>
	    </row>
	    <row>
	      <entry><option>3.2</option></entry>
	      <entry>06 Feb 2005</entry>
	      <entry>BLUEBERRY release: Minor update.</entry>
	    </row>
	    <row>
	      <entry><option>3.3</option></entry>
	      <entry>20 Mar 2005</entry>
	      <entry>RASPBERRY release: Bugfixes, much material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.4</option></entry>
	      <entry>08 May 2005</entry>
	      <entry>TEABERRY release: Bugfixes, stylistic revisions.</entry>
	    </row>
	    <row>
	      <entry><option>3.5</option></entry>
	      <entry>05 Jun 2005</entry>
	      <entry>BOXBERRY release: Bugfixes, some material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.6</option></entry>
	      <entry>28 Aug 2005</entry>
	      <entry>POKEBERRY release: Bugfixes, some material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.7</option></entry>
	      <entry>23 Oct 2005</entry>
	      <entry>WHORTLEBERRY release: Bugfixes, some material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.8</option></entry>
	      <entry>26 Feb 2006</entry>
	      <entry>BLAEBERRY release: Bugfixes, some material added.</entry>
	    </row>
	    <row>
	      <entry><option>3.9</option></entry>
	      <entry>15 May 2006</entry>
	      <entry>SPICEBERRY release: Bugfixes, some material added.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


  </appendix> <!-- End Revision History appendix -->

  <appendix id="trans_revisionhistory">
    <title>翻译版修订记录</title>
	<synopsis>
	翻译版起始于我对这本书的一份学习笔记(译者: 杨春敏), 随着笔记的增长, 
	我萌生了翻译它的想法, 并在<ulink url="http://www.linuxsir.org">linuxsir</ulink>的北南南北的帮助下, 发布了出来. 
	与此并行的是另一译者(黄毅)也同时在翻译此书, 我们两个那时翻译进度相仿. 
	因此在我发布之后, 我们两个在论坛上结识, 并相约共同翻译此书. 
	由此, 对应于原书3.75的翻译beta版终于面世了. 
	最后, 由我在beta版的基础上对正文重新较稿, 并共同努力产出了对应于原书3.91的正式翻译版. 
	</synopsis>
      <table frame=none>
	<title>翻译版修订历史</title>
	<tgroup cols="3" colsep=0 rowsep=0>
	  <thead>
	    <row>
	      <entry>版本</entry>
	      <entry>日期</entry>
	      <entry>注释</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>纯文本前10章</entry>
	      <entry>2006-01-08</entry>
	      <entry>我第一次放出的纯文本翻译版, 基于我最初的学习笔记, 对应于原书的3.75版. </entry>
	    </row>
	    <row>
	      <entry>纯文本beta版</entry>
	      <entry>2006-05-15</entry>
	      <entry>基于我原来的学习笔记最后完成的纯文本版. 对应于原书的3.75版. </entry>
	    </row>
	    <row>
	      <entry>html的beta版</entry>
	      <entry>2006-05-30</entry>
		  <entry>测试版中最完整的版本, 前2部分主要以我的纯文本版为基础, 
			  并大量参考了黄毅的前2部分内容, 第3部分由我翻译, 第4部分由黄毅翻译. 并最终由黄毅较稿完成发布. </entry>
	    </row>
	    <row>
	      <entry>1.0__3.91</entry>
	      <entry>2007-03-04</entry>
		  <entry>正月15完成, 第一个翻译完整版, 与原书作者采用相同的sgml发布. 
			  由我重新较稿并使用sgml的docbook形式重写, 黄毅修正了其中的许多问题. </entry>
	    </row>
	  </tbody>
	  </tgroup>
	  </table>
  </appendix> <!-- End trans_revision history appendix -->

  <appendix id="mirrorsites">
    <title>镜像站点</title>

      <para><ulink
			  url="http://thegrendel.150m.com/abs-guide-3.9.tar.bz2">这份文档最后的更新</ulink>, 
		  是以<quote>tar包</quote>的形式发布的, 其中包括SGML源码和编译好的HTML版本, 
		  你可以从作者的主页上下载. </para>

      <para>这份文档最主要的镜像站点就是<ulink
        url="http://www.tldp.org/LDP/abs/">Linux Documentation Project</ulink>,
        这个站点也维护了相当多的指南手册和HOWTO文档. </para>

      <para><ulink
      url="http://www.ibiblio.org/pub/Linux/docs/linux-doc-project/abs-guide/">Sunsite/Metalab/ibiblio.org</ulink>也是<emphasis>ABS指南</emphasis>的一个镜像站点. </para>

      <para>这份文档的另一个镜像站点是<ulink url="http://www.morethan.org">morethan.org</ulink>. </para>


  </appendix> <!-- Mirror Sites appendix -->


  <appendix id="todolist">
    <title>To Do列表</title>

            <itemizedlist>
	      <listitem>
	        <para>全面调查Bash与经典的Bourne shell之间的兼容性. 
		  </para>
	      </listitem>

	      <listitem>
	        <para>同上, 但需要调查的是Korn shell (ksh).</para>
	      </listitem>

	      <listitem>

	        <para>一个使用Bash来进行CGI编程的初级读本. </para>

		<para>下面是一个简单的CGI脚本, 你可以从这里开始. </para>

                  <example id="testcgi">
                     <title>打印服务器环境</title>
                     <programlisting>&testcgi;</programlisting>
                  </example>

	      </listitem>
            </itemizedlist>

       <para>有志愿者么? </para>

  </appendix> <!-- End Todo List appendix -->


  <appendix id="copyright">
    <title>版权</title>

    <para>The <citetitle pubwork="book">Advanced Bash Scripting
      Guide</citetitle> is <trademark class=copyright>copyright
      </trademark> 2000, by Mendel Cooper. The author also asserts
      copyright on all previous versions of this document.</para>

    <para>This blanket copyright recognizes and protects the rights of all
      contributors to this document.</para>


    <para>This document may only be distributed subject to the terms
      and conditions set forth in the Open Publication
      License (version 1.0 or later), <ulink url="
      http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</ulink>.
      The following license options also apply.
    </para>

    <para><programlisting>A.  Distribution of substantively modified versions of this document
    is prohibited without the explicit permission of the copyright holder.
    HOWEVER, in the event that the author or maintainer of this document
    cannot be contacted, the Linux Documentation Project will have the right
    to take over custodianship of the document and name a new maintainer,
    who would then have the right to update and modify the document.

B.  This document may NOT be distributed encrypted or with any form of
    DRM (Digital Rights Management) embedded in it. Nor may this document
    be bundled with other DRM-ed works.

C.  Distribution of the work or derivative of the work in any standard
    (paper) book form is prohibited unless prior permission is obtained from
    the copyright holder.</programlisting></para>
    

    <para><emphasis>Provision A</emphasis>, above, explicitly prohibits
      <emphasis>relabeling</emphasis> this document. An example of
      relabeling is the insertion of company logos or navigation bars
      into the cover, title page, or the text. The author grants the
      following exemptions.</para>

    <orderedlist>

      <listitem>
        <para>Non-profit organizations, such as the <ulink
          url="http://www.tldp.org">Linux Documentation Project</ulink>
          and <ulink url="http://ibiblio.org">Sunsite</ulink>.</para>
      </listitem>

      <listitem>
        <para><quote>Pure-play</quote> Linux distributors, such as Debian,
          Red Hat, Mandrake, SuSE, and others.</para>
      </listitem>

    </orderedlist> 

    <para>Without explicit written permission from the author,
      distributors and publishers (including on-line publishers) are
      prohibited from imposing any additional conditions, strictures,
      or provisions on this document or any previous version of it. As of
      this update, the author asserts that he has <emphasis>not</emphasis>
      entered into any contractual obligations that would alter the
      foregoing declarations.</para>

    <para>Essentially, you may freely distribute this book in
      <emphasis>unaltered</emphasis> electronic form. You must obtain
      the author's permission to distribute a substantially modified
      version or derivative work. The purpose of this restriction is to
      preserve the artistic integrity of this document and to prevent
      <quote>forking.</quote></para>

    <para>If you display or distribute this document or any previous
      version thereof under any license except the one above, then you
      are required to obtain the author's written permission. Failure
      to do so may terminate your distribution rights.</para>

    <para>These are very liberal terms, and they should not hinder any
      legitimate distribution or use of this book. The author especially
      encourages the use of this book for classroom and instructional
      purposes.</para>

    <note><para>Certain of the scripts contained in this document are,
      where noted, released into the Public Domain. These scripts are
      exempt from the foregoing license and copyright
      restrictions.</para></note>

    <para>The commercial print and other rights to this book are
      available. Please contact <ulink
      url="mailto:thegrendel@theriver.com">the author</ulink> if
      interested.</para>

    <para>The author produced this book in a manner consistent with the
      spirit of the <ulink url="http://www.tldp.org/manifesto.html">LDP
      Manifesto</ulink>.</para>


    <sidebar>
    <para>Linux is a trademark registered to Linus Torvalds.</para>
    <para>Unix and UNIX are trademarks registered to the Open Group.</para>
    <para>MS Windows is a trademark registered to the Microsoft Corp.</para>
    <para>Solaris is a trademark registered to Sun, Inc.</para>
    <para>OSX is a trademark registered to Apple, Inc.</para>
    <para>Yahoo is a trademark registered to Yahoo, Inc.</para>
    <para>Pentium is a trademark registered to Intel, Inc.</para>
    <para>Scrabble is a trademark registered to Hasbro, Inc.</para>
    <para>All other commercial trademarks mentioned in the body of this work
      are registered to their respective owners.</para>
      </sidebar>


    <para>Hyun Jin Cha has done a <ulink
      url="http://kldp.org/HOWTO/html/Adv-Bash-Scr-HOWTO/index.html">Korean
      translation</ulink> of version 1.0.11 of this book. Spanish,
      Portuguese, <ulink url="http://abs.ptithibou.org/">French</ulink>,
      <ulink url="http://abs.traduc.org/">(another French)</ulink>,
      German, <ulink
      url="http://it.tldp.org/guide/abs/index.html">Italian</ulink>,
      <ulink
      url="http://gazette.linux.ru.net/rus/articles/index-abs-guide.html">Russian</ulink>,
      <ulink url="http://premekvihan.net/bash">Czech</ulink>,
      Chinese, and Dutch translations are also available or in
      progress. If you wish to translate this document into another
      language, please feel free to do so, subject to the terms stated
      above. The author wishes to be notified of such efforts.</para>


  </appendix> <!-- End Copyright appendix -->


<!-- Uncomment line below to generate index. -->
<!--
&indice;
-->

</book>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-indent-step:2
sgml-indent-data:t
End:
-->
